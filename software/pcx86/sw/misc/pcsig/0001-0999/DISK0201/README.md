---
layout: page
title: "PC-SIG Diskette Library (Disk #201)"
permalink: /software/pcx86/sw/misc/pcsig/0001-0999/DISK0201/
machines:
  - id: ibm5170
    type: pcx86
    config: /machines/pcx86/ibm/5170/cga/1024kb/rev3/machine.xml
    diskettes: /machines/pcx86/diskettes.json,/disks/pcsigdisks/pcx86/diskettes.json
    autoGen: true
    autoMount:
      B: "PC-SIG Library Disk #0201"
    autoType: $date\r$time\rB:\rDIR\r
---

{% include machine.html id="ibm5170" %}

{% comment %}info_begin{% endcomment %}

## Information about "WORDSTART & FINANCIAL"

    This early collection of WordStar utilities is headlined by Version 2.1
    of UNDOWS, considered an answer to prayer by many word processors.  If
    you need to change WordStar files to ASCII in a hurry or want to remove
    those soft hyphens or embedded control characters that WordStar leaves
    in a file, UNDOWS does all that for you.  And more: two new options
    allow you to strip extra carriage return / line feed pairs and to
    remove embedded dot commands from your text.
    
    Other WordStar Helps: FIXWS converts Wordstar files to ASCII and UNDOWS
    which converts Wordstar to standard ASCII as well as WS-DOC.BAS, a
    BASIC program for doing both!  It also has some special word
    processors: FORMGEN.BAS, a BASIC and simple word processor and POW.COM,
    an equally small but effective word processor.
    
    The financial programs include: 78INT.BAS is a handy utility and BASIC
    program for calculating the Rule of 78's (interest/principle) and
    DISBURSE.BAS which handles disbursements register, single entry, with
    annual summaries.
    
    System Requirements:  BASIC
    
    How to Start:  For the BASIC programs, consult the Getting
    Started section for your configuration.  The rest run from DOS by
    entering the filename and pressing <ENTER>.
    
    File Descriptions:
    
    78INT    BAS  Rule of 78's interest/principle calculating utility
    DISBURSE TXT  Documentation
    DISBURSE BAS  Disbursements register, single entry,  annual summaries
    FIXWS    DOC  Documentation
    FIXWS    COM  Converts WORDSTAR files to ASCII
    FORMGEN  TXT  Documentation
    FORMGEN  BAS  Simple word processor
    UNDOWS   DOC  Documentation
    POW      COM  Simple word processor by Michael Maioli  (Version 3.0)
    POW      DOC  Documentation
    OUTPUTS  PRF  Part of DISBURSE.BAS
    UNDOWS   EXE  Version 2.1 by Gary Elfring converts Wordstar to ASCII
    WS-DOS   BAS  Converts WORDSTAR files to ASCII, and ASCII to WORDSTAR
{% comment %}info_end{% endcomment %}

{% comment %}samples_begin{% endcomment %}

## 78INT.BAS

{% raw %}
```bas
10 CLS
20 KEY OFF
30 PRINT "RULE OF 78'S INTEREST"
40 PU$="####     $$#,###,###.##  $$,###,###,###.##     $$#,###,###.##"
50 DEFDBL A-Z:DEFINT M,T
60 PRINT
70 PRINT "ENTER TOTAL INTEREST TO BE EARNED";
80 PRINT " TO MATURITY OF THE LOAN";
90 INPUT I
100 PRINT "ENTER NO. OF MONTHS DURATION";
110 PRINT " OF THE LOAN TO MATURITY";
120 INPUT T
130 T1=T*(T+1)/2
140 PRINT
150 PRINT " MONTH         MONTH'S          ACCUMULATED         BALANCE OF"
160 PRINT "OF LOAN        INTEREST           INTEREST           INTEREST"
170 A=0
180 REM PRINT TABLE
190 FOR M=1 TO T-1
200 J=INT(((T-M+1)*I/T1)*100+0.5)/100
210 A=A+J
220 B=I-A
230 PRINT USING PU$; M,J,A,B
240 NEXT M
250 PRINT USING PU$; T,B,A+B,0
260 PRINT SPC(24)"PENNY BREAKAGE ADJUSTED IN LAST MONTH"
270 PRINT
280 PRINT "WOULD YOU LIKE TO RERUN PROGRAM USING NEW DATA (Y/N)?"
290 Z$=INKEY$:IF Z$="" THEN 290
300 IF Z$="Y" OR Z$="y" THEN 60
310 IF Z$<>"N" AND Z$<>"n" THEN 280
320 END
```
{% endraw %}

## DISBURSE.BAS

{% raw %}
```bas
5 GOTO 4000
10 LPRINT CHR$(27)"N"CHR$(10)
20 LPRINT CHR$(15)
30 LPRINT "DISBURSE.BAS   ", DATE$;"   "; TIME$
40 LLIST 4000-
50 STOP
200 EDIE = TRUE
205 TIME1$ = "beginning search at loc 5760-  "
210 TIME2$ = "search completed at loc 5840-  "
220 TIME3$ = "Start build chart at loc 8010- "
230 TIME4$ = "Chart built but demi-sorted at loc 8221-  "
240 TIME5$ = "Sort completed at loc 8260-  "
250 CLS
260 RETURN
4000 PROGRAMID$ = "DISBURSE.BAS"     'DISBURSEMENTS BOOKEEPING
4010 TRUE = -1: FALSE = 0: CLS
4020 'INPUT "edie debugging"; EDIE$: IF EDIE$="y" OR EDIE$="Y" THEN GOSUB 200
4030 CLS: KEY OFF
4040 NOTICE$="COPYRIGHT (c) 1983 Edith S. Windsor"
4050 LOCATE 10,15: PRINT PROGRAMID$: LOCATE 14,15: PRINT NOTICE$
4060 LOCATE 24,15: PRINT "PRESS ANY KEY TO CONTINUE"
4070 A$=INKEY$: IF A$ = "" THEN 4070 ELSE CLS
4080 ' initialize
4090 COLOR 15,0: LOCATE 24,15
4100 INPUT "Debugging input(Y/N)",DE$: COLOR 7,0
4110 IF DE$ = "y" OR DE$="Y" THEN DEBUG= TRUE ELSE DEBUG = FALSE
4120 CLS:OPTION BASE 1
4130 DIM CHECKNO$(200),DAY$(200), PAYEE$(200), AMOUNT(200), CAT$(200)
4140 DIM CHART$(200), CHART(200)
4150 DIM MOTOT(13),CATLIST$(12,50),CATAMT(12,50),CATCT(15)
4160 ' ------Later, allow users to pre-define list of bank accounts
4170 WIDTH 80:LM = 3
4180 'LOCATE 10,7: INPUT "SCREEN WIDTH (40 OR 80)==>",WD%
4190 ' ------use this later to truncate screen listing------------!
4200 CLS
4210 COLOR 15,0: LOCATE 24,15
4220 INPUT "HARDCOPY(Y OR N)"; HARD$: COLOR 7,0
4230 IF HARD$="N" OR HARD$="n" THEN HARDCOPY = FALSE: GOTO 4360
4240 HARDCOPY = TRUE
4250 DEF SEG = 0
4260 STATUS = INP(957):  IF STATUS =71 THEN GOTO 4270 ELSE GOTO 4290
4270 LOCATE 2,10: COLOR 16,7: BEEP
4280 PRINT "   PRINTER OFF LINE   ": COLOR 7,0: PRINT: GOTO 4210
4290 IF STATUS <> 223 THEN GOTO 4300 ELSE GOTO 4320
4300 LOCATE 2,10: COLOR 16,7: BEEP
4310 PRINT "   PRINTER TURNED OFF   ": COLOR 7: PRINT: GOTO 4210
4320 '
4330 LPRINT CHR$(27); "N"; CHR$(6);
4340 LPRINT
4350 DEF SEG
4360 CLS:LOCATE 12,10,0: PRINT "(Don't forget device)"
4370 LOCATE 10,7,0
4380 INPUT "ENTER NAME OF INPUT FILE===>",FILENAME$
4390 OPEN FILENAME$ FOR INPUT AS #1
4400 DEV$=MID$(FILENAME$,2,1): IF DEV$ = ":" THEN FILENAME$=RIGHT$(FILENAME$,LEN(FILENAME$)-2)
4410 YEARTOTAL = 0: THISMONTH = 0
4420 CLS:LOCATE 12,7,0
4430 PRINT "(Suggest name/bank acct, as -Jones Chase Checking-)"
4440 LOCATE 10,7,0
4450 INPUT "SELECT PAGE IDENTIFIER ==>"; PAGEHEADING$
4460 '
4470 '
4480 '
4490 INPUT #1, CHECKNO$, DAY$,PAYEE$, AMOUNT, CAT$, SUBCAT  'read 1st month hdr
4500 THISMONTH =THISMONTH+1  '---Later, check this against month hdr in input-
4510 GOSUB 4650     'TREAT MONTHHEADER AND SET UP MONTH & PAGE HEADINGS
4520 GOSUB 4940     'READ, SAVE AND PRINT DATA RECORDS
4530 GOSUB 5160     'COMPUTE AND PRINT MONTH TOTAL DOLLARS
4540 GOSUB 5350     'COLLECT AND PRINT CATEGORIES THIS MONTH
4550 IF ENDOFFILEFLAG THEN GOSUB 5940 ELSE GOTO 4500
4560 PRINT "END OF INPUT FILE: "; FILENAME$
4570 LPRINT                  'TO EMPTY PRINT BUFFER
4580 LPRINT CHR$(27) + "F"   'RESTORE NORMAL PRINTING
4590 END
4600 ' *****************************end*********************
4610 '_____________________________________________________________
4620 ' subprogram to treat month header and set up page & column headings
4630 '           as well as reset totals for new month
4640 '____________________________________________________________
4650 ON ERROR GOTO 4820
4660 MONTH$ = PAYEE$: YR = AMOUNT     'in this case - "DIS, A, JAN, 81,,"
4670 '
4680 DISBURSEHDR$ = "DISBURSEMENTS FROM " + PAGEHEADING$
4690 IF NOT HARDCOPY GOTO 4760
4700 LPRINT TAB(LM+14); DISBURSEHDR$; TAB(LM+63); MONTH$;" 19";
4710 LPRINT USING"##";YR
4720 LPRINT
4730 LPRINT TAB(LM); "CHECK#"; TAB(LM+8); "DAY"; TAB(LM+12); "PAYEE";
4740 LPRINT TAB(LM+54);"AMOUNT"; TAB(LM+65); "CATEG"
4750 LPRINT TAB(LM); STRING$(74,95): LPRINT
4760 CLS: PRINT: PRINT DISBURSEHDR$;"  ";MONTH$
4770 PRINT
4780 TRANSCT = 0: LINECOUNT = 4
4790 RETURN
4800 '
4810 '--------------------------------------------------
4820 IF ERR = 24 THEN RESUME
4830 IF (ERR=62) AND (ERL=4950) THEN ENDOFFILEFLAG=TRUE:RESUME NEXT
4840 IF ERL = 6140 AND (ERR=53 OR ERR=52) THEN CLS ELSE GOTO 4860
4850 PRINT "file not found; re-enter complete file spec": RESUME 6110
4860 PRINT "ERR = "; ERR; "ERL = "; ERL
4870 INPUT "CONTINUE(Y OR N)";REPLY$
4880 IF REPLY$ = "Y" OR REPLY$ = "y" THEN RESUME
4890 STOP
4900 '
4910 '___________________________________________________________
4920 ' read, save and print data records
4930 '___________________________________________________________
4940 IF EOF(1) THEN ENDOFFILEFLAG = TRUE:RETURN
4950 INPUT #1, CHECKNO$, DAY$, PAYEE$, AMOUNT, CAT$, SUBCAT
4960 IF ENDOFFILEFLAG THEN RETURN
4970 FIRST$=LEFT$(CHECKNO$,1):A = ASC(FIRST$)
4980 IF A > 47 AND A < 58 THEN 5000 ELSE IF FIRST$ = "C" THEN 5000
4990 IF CHECKNO$ = "DIS" THEN RETURN ELSE GOTO 5300
5000 IF SUBCAT = 0 THEN CAT$=CAT$+" " ELSE CAT$ = CAT$+RIGHT$(STR$(SUBCAT),1)
5010 IF HARDCOPY = FALSE GOTO 5060
5020 LPRINT TAB(LM); CHECKNO$; TAB(LM+7);DAY$;TAB(LM+12);LEFT$(PAYEE$,35);
5030 LPRINT TAB(LM+51); USING "#####,.##"; AMOUNT;
5040 LPRINT TAB(LM+65); CAT$
5050 ' - - - -fix starting here to accomodate 40-char wide screen - - -
5060 PRINT TAB(LM); CHECKNO$; TAB(LM+7);DAY$;TAB(LM+12);LEFT$(PAYEE$,35);
5070 PRINT TAB(LM+51); USING "#####,.##"; AMOUNT;
5080 PRINT TAB(LM+65); CAT$
5090 '
5100 TRANSCT = TRANSCT + 1
5110 CHECKNO$(TRANSCT) = CHECKNO$: DAY$(TRANSCT) = DAY$
5120 PAYEE$(TRANSCT) = PAYEE$: AMOUNT(TRANSCT) = AMOUNT: CAT$(TRANSCT) = CAT$
5130 GOTO 4940
5140 '
5150 '_________________________________
5160 '  subprogram to compute month totals
5170 '________________________________
5180 MOTOT = 0
5190 FOR I = 1 TO TRANSCT: MOTOT = MOTOT + AMOUNT(I): NEXT I
5200 MOTOT(THISMONTH) = MOTOT
5210 IF HARDCOPY = FALSE GOTO 5240
5220 LPRINT: LPRINT TAB(LM+40); "TOTAL";
5230 LPRINT TAB(LM+51); USING "#####,.##"; MOTOT
5240 PRINT: PRINT TAB(LM+40); "TOTAL";
5250 PRINT TAB(LM+51); USING "#####,.##"; MOTOT
5260 RETURN
5270 '
5280 '______________________________________________________________
5290 '   process invalid entry - phoney now             DO SOMETHING NOW!
5300 PRINT "Checkno field is "; CHECKNO$
5310 PRINT "Day is "; DAY$; "    Payee is "; PAYEE$
5320 PRINT "Month is "; MONTH$
5330 RETURN
5340 '
5350 '-------------------------------------------------------------------
5360 'Collect and print categories with their totals this month
5370 '_______________________________________________________
5380 CATCT = 0
5390 FOR I = 1 TO TRANSCT
5400    IF CAT$(I) = "REM " THEN GOTO 5510
5410    IF CATCT > 0 THEN GOTO 5440
5420    CATCT = 1: CATLIST$(THISMONTH,1) = CAT$(I)
5430    CATAMT(THISMONTH,1) = AMOUNT(I):GOTO 5510
5440    FOR J = 1 TO CATCT
5450      IF CAT$(I) <>CATLIST$(THISMONTH,J) THEN 5470
5460      CATAMT(THISMONTH,J) = CATAMT(THISMONTH,J)+ AMOUNT(I): GOTO 5510
5470    NEXT J
5480 '  arrive here if no match so far
5490    CATCT = CATCT + 1
5500    CATLIST$(THISMONTH,CATCT)= CAT$(I):CATAMT(THISMONTH,CATCT)= AMOUNT(I)
5510 NEXT I
5520 ' sort them
5530 D=1
5540 D=2*D:  IF D <=CATCT THEN GOTO 5540
5550 D = INT((D-1)/2)
5560 IF D = 0 THEN GOTO 5670          'DONE
5570 LOCATE 25,7: COLOR 15,0: PRINT "SORTING"
5580 FOR I = 1 TO (CATCT-D): M=I
5590    L=M+D
5600    IF CATLIST$(THISMONTH,M) <= CATLIST$(THISMONTH,L) THEN 5640
5610    SWAP CATLIST$(THISMONTH,M), CATLIST$(THISMONTH,L)
5620    SWAP CATAMT(THISMONTH,M), CATAMT(THISMONTH,L)
5630    M=M-D: IF M>0 GOTO 5590
5640 NEXT I
5650 GOTO 5550
5660 '---print them
5670 COLOR 7,0: LOCATE 25,7: PRINT STRING$(30,32):IF NOT HARDCOPY GOTO 5710
5680 LPRINT: LPRINT "CATEGORY COUNT THIS MONTH: "; CATCT;
5690 LPRINT TAB(LM+63); MONTH$; "19";
5700 LPRINT USING "##"; YR
5710 PRINT "CATEGORY COUNT THIS MONTH: ";CATCT;"    "; MONTH$
5720 PRINT
5730 FOR K = 1 TO CATCT
5740 IF HARDCOPY = FALSE THEN GOTO 5770
5750    LPRINT TAB(LM);CATLIST$(THISMONTH,K);
5760    LPRINT TAB(LM+7);USING "######,.##"; CATAMT(THISMONTH,K)
5770    PRINT TAB(LM);CATLIST$(THISMONTH,K);
5780    PRINT TAB(LM+7); USING "######,.##"; CATAMT(THISMONTH,K)
5790     NEXT K
5800 CATCT(THISMONTH) = CATCT
5810 IF HARDCOPY THEN LPRINT:LPRINT CHR$(12):RETURN
5820 IF NOT DEBUG THEN RETURN
5830 LOCATE 25,7: COLOR 15,0: PRINT "PRESS ANY KEY TO CONTINUE"
5840 A$=INKEY$: IF A$="" THEN 5840 ELSE COLOR 7,0
5850 RETURN
5860 '----------------------------------------------------------
5870 '---------end-of-year processing--------------------------
5880 ' On arriving here, we have
5890 '   for I = 1 to 12 months
5900 '       catlist$(I,ksubi) and
5910 '       catamt(I,ksubi)
5920 '           where ksubi = catct(I)
5930 '
5940 CLOSE #1
5950 FOR I = 1 TO 12: YEARTOTAL = YEARTOTAL + MOTOT(I):NEXT I:PRINT YEARTOTAL
5960 SPACELEFT = FRE(0): PRINT "FREESPACE = "; SPACELEFT
5970 '---------determine if external chart-of-accounts in DIF-----------
5980 '---------or if user wants to create such by merging the ----------
5990 '---------categories collected by month.---------------------------
6000 CLS: LOCATE 7,7: PRINT "YOU MAY CHOOSE:"
6010 LOCATE 9,11:PRINT "1.  USE PREVIOUSLY CREATED CHART-OF-ACCOUNTS DIF FILE"
6020 LOCATE 10,15:PRINT "AND GENERATE DIF OF TOTALS"
6030 LOCATE 12,11:PRINT "2.  PROGRAM WILL CREATE A SORTED LIST OF CATEGORIES AND"
6040 LOCATE 13,15:PRINT "PRINT IT OUT WITH YEAR'S TOTALS"
6050 LOCATE 15,11:PRINT "3.  PROGRAM WILL DO 2. AND THEN CREATE A DIF OF RESULT"
6060 LOCATE 23,11: INPUT "PLEASE MAKE SELECTION==>"; CH
6070 IF CH=2 THEN DIF = FALSE ELSE DIF = TRUE:CLS
6080 ON CH GOTO 6090, 7150, 7150,12000    ' 12000 is error processing location
6090 '-------------------------------------------------------------------------
6100 LOCATE 10,10:PRINT "PROGRAM WILL READ `B:CHRTOFAC.DIF' UNLESS YOU SPECIFY OTHER HERE"
6110 LOCATE 12,10:INPUT "ENTER FILESPEC (or Enter for default spec)==> ";CHRTNA$
6120 FILNA$="B:CHRTOFAC.DIF": IF CHRTNA$<>"" THEN FILNA$=CHRTNA$
6130 LOCATE 25,15: COLOR 15: PRINT "READING ";FILNA$:COLOR 7
6140 OPEN FILNA$ FOR INPUT AS #1
6150 INPUT #1, TITLE$
6160 INPUT #1, TYPE,NUMBER
6170 INPUT #1, STRNG$
6180 IF TITLE$ = "VECTORS" THEN VECTORS = NUMBER
6190 IF TITLE$ = "TUPLES" THEN TUPLES = NUMBER
6200 IF TITLE$ <> "DATA" GOTO 6150
6210 PRINT "Reading in chart of accounts"
6220 'read the first tuple and throw it away - this is full-length version
6230 '                                       of chart of accounts - maybe save
6240 '                                       it and do something nice later.
6250 TUPLE = 1
6260 INPUT #1, TYPE, NUMBER
6270 INPUT #1, STRNG$
6280 '- - - - ->                   pUT SOME CODE HERE NOW!
6290 IF TYPE <>-1 THEN GOTO 12000
6300 IF STRNG$<> "BOT" GOTO 12000
6310 INPUT #1, TYPE, NUMBER         'READ AND IGNORE THE FIRST ENTRY
6320 INPUT #1, STRNG$
6330 FOR ROW = 1 TO (VECTORS-1)
6340    INPUT #1, TYPE, NUMBER
6350    INPUT #1, STRNG$
6360    IF TUPLE < TUPLES THEN GOTO 6380 ELSE CHART$(ROW)=LEFT$(STRNG$,4)
6370    IF LEN(CHART$(ROW)) = 3 THEN CHART$(ROW) = CHART$(ROW)+" "
6380 NEXT ROW
6390 IF TUPLE <TUPLES THEN TUPLE =TUPLE+1: GOTO 6260
6400 IF EDIE THEN LOCATE 16,5:PRINT TIME1$; TIME$
6410 CLOSE #1
6420 LOCATE 25,10: PRINT STRING$(30,32)
6430 FOR MONTH = 1 TO 12   ' FOR THIS ENTIRE ACCOUNT ADD UP TOTALS BY CATEGORY FOR YEAR
6440       FOR L = 1 TO CATCT(MONTH)
6450            X$ = CATLIST$(MONTH,L)
6460            GOSUB 7030    'TO SEARCH FOR INDEX OF X$ IN CHART$
6470            IF J<=0 GOTO 6950 ELSE CHART(J) = CHART(J)+CATAMT(MONTH,L)
6480            NEXT L
6490       NEXT MONTH
6500 IF EDIE THEN LOCATE 18,5:PRINT TIME2$; TIME$
6510 '
6520 GOSUB 6610     ' to write out the DIF column
6530 ' return from writing DIF column
6540 CATCT = VECTORS-1
6550 GOSUB 7620    'to print sorted chart of accounts with $ totals
6560 RETURN        'to main menu stream
6570 ' *******************************************************
6580 '-------------------------------------------------------
6590 ' Write a dif column of the entire chart(j) for j = 1 TO (VECTORS-1)
6600 ' To match the chrtofac, first entry in tuple is blank
6610 CLS: LOCATE 10,7:PRINT "ASSURE DISK MOUNTED TO RECEIVE OUTPUT"
6620 LOCATE 12,7:INPUT "ENTER OUTPUT FILENAME (d:name)==>";OUTF$
6630 QUOTE$=CHR$(34): NUL$ = QUOTE$+QUOTE$
6640 X = INSTR(OUTF$,"."): IF X = 0 THEN TEMP1$ = OUTF$: GOTO 6670
6650 TEMP1$ = LEFT$(OUTF$,X-1)
6660 '
6670 Y = INSTR(TEMP1$,":")
6680 IF Y = 0 THEN DV$= " ": COLHD$=TEMP1$: GOTO 6700
6690 DV$=LEFT$(TEMP1$,2): COLHD$=RIGHT$(TEMP1$,LEN(TEMP1$)-2)
6700 TEMP2$ = DV$+COLHD$
6710 COLHD$ = " " + COLHD$
6720 OUTFILE$ =TEMP2$ + ".DIF"
6730 ' PRINT DV$, COLHD$, TEMP2$, OUTFILE$: STOP
6740 OPEN OUTFILE$ FOR OUTPUT AS #2
6750 COLOR 15: LOCATE 25,15: PRINT "WRITING DIF COLUMN OF TOTALS TO ";OUTFILE$
6760 ' First the headers
6770 PRINT #2, "TABLE": PRINT #2, 0;",";1: PRINT #2, NUL$
6780 PRINT #2, "VECTORS": PRINT #2, 0;",";VECTORS: PRINT #2, NUL$
6790 PRINT #2, "TUPLES": PRINT #2, 0;",";1: PRINT #2, NUL$
6800 PRINT #2, "DATA": PRINT #2, 0;",";0: PRINT #2, NUL$
6810 'begin the tuple
6820 PRINT #2, -1;",";0: PRINT #2, "BOT"   'signal beginning of tuple
6830 PRINT #2, 1;","; 0: PRINT #2, COLHD$
6840 FOR ROW = 1 TO (VECTORS-1)
6850     PRINT #2, 0; ",";
6860     PRINT #2, USING "######.##"; CHART(ROW)
6870     PRINT #2, "V"
6880     NEXT ROW
6890 PRINT #2, -1;","; 0: PRINT #2, "EOD"
6900 CLOSE #2
6910 COLOR 7: CLS
6920 RETURN
6930 ' ------------------------------------------------------------
6940 ' Error process- category not found in chart of accounts
6950 PRINT "J = "; J;".  CATLIST$(MONTH,L) = "; X$, MONTH, L
6960 IF CATAMT(MONTH,L)=0 THEN GOTO 6480  'Dont worry about 0 amount
6970 IF CATLIST$(MONTH,L)= "LEG4" THEN CATLIST$(MONTH,L) = "LEG ": GOTO 6450
6980 ' above line is an edie personal fix to remove later
6990 STOP
7000 RESUME 6480
7010 STOP
7020 '-----------------------------------
7030 'BINARY SEARCH
7040 K=1: M = VECTORS-1
7050 WHILE K <=M
7060   F = (K+M)/2: J = INT(F)
7070   IF X$ = CHART$(J) GOTO 7110
7080   IF X$ < CHART$(J) THEN M = J-1 ELSE K = J+1
7090 WEND
7100 J=0
7110 RETURN
7120 ' -----------------------------------
7130 '--------------------------------------------------------
7140 '
7150 '__Enter here if no prior chart-of-accounts
7160 CATCT = CATCT(1)
7170 IF EDIE THEN LOCATE 19,5:PRINT TIME3$; TIME$
7180 FOR I = 1 TO CATCT
7190    CHART$(I)=CATLIST$(1,I): CHART(I)=CATAMT(1,I)
7200    NEXT I
7210  FOR MON = 2 TO 12
7220    FOR I = 1 TO CATCT(MON)
7230        FOR J = 1 TO CATCT
7240          IF CATLIST$(MON,I)<> CHART$(J) THEN GOTO 7260 'to get next J
7250          CHART(J) = CHART(J)+CATAMT(MON,I): GOTO 7290  'to get next I
7260         NEXT J
7270         CATCT=CATCT+1
7280         CHART$(CATCT) = CATLIST$(MON,I): CHART(CATCT)=CATAMT(MON,I)
7290    NEXT I :LOCATE 25,10:PRINT "MERGING THE CATEGORIES  "; TIME$
7300 NEXT MON
7310 IF EDIE THEN LOCATE 20,5:PRINT TIME4$;TIME$
7320 'use Shell sort here but come back later and replace code from 8000 on for
7330 ' more efficiency - since we're starting with 12 ordered lists.
7340 D=1
7350 D=2*D
7360 IF D <= CATCT THEN 7350
7370 D = INT((D-1)/2)
7380 IF D = 0 THEN 7470   'that is, sort is completed
7390 FOR I = 1 TO CATCT-D
7400    M=I
7410    L = M+D
7420    IF CHART$(M) < CHART$(L) THEN GOTO 7450
7430    SWAP CHART$(M), CHART$(L): SWAP CHART(M),CHART(L)
7440    M=M-D: IF M > 0 GOTO 7410
7450 NEXT I
7460 GOTO 7370
7470 IF EDIE THEN LOCATE 21,5:PRINT TIME5$;TIME$
7480 IF CHART(1) <>0 THEN GOTO 7530
7490 FOR I = 1 TO (CATCT-1)
7500     CHART$(I) = CHART$(I+1): CHART(I) = CHART(I+1)
7510 NEXT I
7520 CATCT=CATCT-1      ' adjust for removal of 0
7530 GOSUB 7620   'to print out the sorted list with annual totals
7540 IF NOT DIF THEN RETURN
7550 '
7560 VECTORS = CATCT + 1
7570 GOSUB 6610       ' to write a DIF file of totals
7580 GOSUB 8500       'go write dif column of categories
7585 RETURN
7590 ' *******************************************************
7600 '
7610 '
7620 ' Print out the sorted chart-of-accounts with $ totals for year
7630 '--------------------------------------
7640 IF HARDCOPY GOTO 7720
7650 COLOR 15,0: LOCATE 25,5
7660 INPUT "WOULD YOU LIKE HARDCOPY OF ACCOUNT LIST WITH TOTALS(Y/N)",RE$
7670 COLOR 7,0: LOCATE 25,5: PRINT STRING$(70,32)
7680 IF RE$ = "N" OR RE$ = "n" THEN GOTO 7840
7690 LOCATE 24,5:  PRINT "CHECK THAT PRINTER READY"
7700 COLOR 15,0: LOCATE 25,5: PRINT "PRESS ANY KEY WHEN READY"
7710 A$=INKEY$: IF A$="" THEN 7710 ELSE COLOR 7,0:CLS
7720 ON ERROR GOTO 7900
7730 LPRINT CHR$(12);
7740 LPRINT DISBURSEHDR$; TAB(LM+53); " 19";
7750 LPRINT USING "##";YR
7760 LPRINT: LPRINT
7770 FOR I = 1 TO CATCT
7780 LPRINT TAB(LM+8); CHART$(I); TAB(LM+20)
7790 LPRINT USING "#######,.##"; CHART(I)
7800 NEXT I
7810 LPRINT STRING$(39,45): LPRINT TAB(LM+8);"TOTAL";TAB(LM+20);
7820 LPRINT USING "#######,.##"; YEARTOTAL
7830 LPRINT
7840 PRINT: PRINT TAB(LM+8);"ACCOUNT (CATEGORY) LIST FOR YEAR": PRINT
7850 FOR I = 1 TO CATCT
7860   PRINT TAB(LM); CHART$(I);TAB(LM+20);
7870   PRINT USING "#######,.##"; CHART(I)
7880 NEXT I
7890 RETURN
7900 IF ERR = 24 THEN RESUME NEXT
7910 GOTO 4860
8500 ' ----------------------------------------------
8510 '  subroutine to write single-column DIF file of
8520 '  accumulated categories
8530 '-----------------------------------------------
8540 PRINT "ASSURE OUTPUT DISK STILL MOUNTED"
8550 '
8560 COLHD$="CHRTOFAC"
8570 OUTFILE$ = DV$+COLHD$+".DIF"
8580 COLOR 15: LOCATE 25,10: PRINT "WRITING "; OUTFILE$
8590 OPEN OUTFILE$ FOR OUTPUT AS #2
8600 ' first the headers
8610 PRINT #2, "TABLE": PRINT #2, 0;",";1: PRINT #2, NUL$
8620 PRINT #2, "VECTORS": PRINT #2, 0;",";VECTORS: PRINT #2, NUL$
8630 PRINT #2, "TUPLES": PRINT #2, 0;",";1: PRINT #2, NUL$
8640 PRINT #2, "DATA": PRINT #2, 0;",";0: PRINT #2, NUL$
8650 ' begin the tuple
8660 PRINT #2, -1; ","; 0: PRINT #2, "BOT"    'signal beginning of tuple
8670 PRINT #2, 1; ","; 0: PRINT #2, COLHD$
8680 FOR ROW = 1 TO (VECTORS-1)
8690      PRINT #2, 1; ",",0: PRINT #2, CHART$(ROW)
8700 NEXT ROW
8710 PRINT #2, -1;",";0: PRINT #2, "EOD"
8720 CLOSE #2
8730 COLOR 7: CLS
8740 RETURN
8750 '---------------------------------------------------------------------
8770 EDIT 8760
```
{% endraw %}

## FILES201.TXT

{% raw %}
```
--------------------------------------------------------------------------
Disk No 201   Wordstar and Financial Items                           v1.1
--------------------------------------------------------------------------
78INT    BAS  Rule of 78's interest/principle calculating utility
DISBURSE BAS  Disbursements register, single entry, with annual summaries
DISBURSE TXT  Documentation
FIXWS    COM  Converts Wordstar files to ASCII
FIXWS    DOC  Documentation
FORMGEN  BAS  Simple word processor
FORMGEN  TXT  Documentation
OUTPUTS  PRF  Part of DISBURSE.BAS
POW      DOC  Documentation
POW      COM  Simple word processor by Michael Maioli (V3.0)
UNDOWS   DOC  Documentation for UNDOWS.EXE v2.1
UNDOWS   EXE  V2.1 by Gary Elfring - converts Wordstar to standard ASCII
WS-DOS   BAS  Converts Wordstar files to ASCII, and ASCII to Wordstar
 
PC-SIG
1030D E. Duane Ave.
Sunnyvale, CA  94086
(408) 730-9291
(c) Copyright 1987 PC-SIG
```
{% endraw %}

## FIXWS.DOC

{% raw %}
```

                            F I X W S


The  FIXWS  command  is used to copy a  WORDSTAR  document  file, 
stripping out all of the WORDSTAR control sequences.  This allows 
the  file to be processed by other applications or transferred to 
a host system.

The command format used is:

     FIXWS   input-fileid   <output-fileid/CON/NUL>

Where:

     "Input-fileid"  is  the  DOS disk file  identifier  for  the 
     WORDSTAR file to be used as input to the FIXWS command. This 
     consists  of  a  drive identifier (optional),  a  file  name 
     (required), and a filename extension (optional).

     "Output-fileid"  is  the  DOS disk file identifier  for  the 
     output  file  to  be created  by  the  FIXWS  command.  This 
     consists of a drive identifier,  a filename,  and a filename 
     extension.  If  only the drive identifier is  supplied,  the 
     output  filename and extension will be the same as the input 
     filename and extension, respectively.

     The output file identifier is optional.  If it is completely 
     omitted, the converted output will be written to a temporary 
     file  which will replace the input file when all  processing 
     is  complete.  A  value of CON may be supplied in  order  to 
     write output to the display rather than disk. A value of NUL 
     may be supplied in order to suppress output completely  (not 
     very useful for this program).
     
65399 '** DONE - PRESS ENTER TO RETURN TO MENU **
ess output completel
```
{% endraw %}

## FORMGEN.BAS

{% raw %}
```bas
3 LPVST=60*VAL(MID$(TIME$,4))+VAL(MID$(TIME$,7)):RPVST=LPVST:UPVST=LPVST:RPVST=LPVST
4 A$="s=5:goto 1180"+CHR$(13)
5 KEY 1,A$:KEY 2,A$:KEY 3,A$:KEY 4,A$:KEY 5,A$:KEY 6,A$:KEY 7,"":KEY 8,"":KEY 9,"":KEY 10,""
6 DC=0
10 DEFINT A-Z
20 KEY OFF
30 CLS
40 TEM=255:FLAG=0:NEWF=0:RF=0
50 AMAP=133
60 LM=1:RM=80:TAB=5
70 DIM FORM$(AMAP),XX(AMAP)
80 FOR X=1 TO AMAP
90 FORM$(X)=STRING$(100,32)
95 XX(X)=X
100 MID$(FORM$(X),80,2)=CHR$(2)+CHR$(1)
110 NEXT
120 EP=67
130 FORM$(EP)=STRING$(79,"-")
140 ON ERROR GOTO 160
150 GOTO 165
160 IF ERR=53 THEN LOCATE 10,25:PRINT "no text files present";:RESUME 180
165 LOCATE 1,1:PRINT "..........................";:COLOR 8,7:PRINT "text files on this disk";:COLOR 7,0:PRINT ".............................";
170 LOCATE 2,1:FILES "*.txt"
171 FOR X=2 TO 18
172 FOR Y=1 TO 66 STEP 13
173 LOCATE X,Y+8:PRINT "    ";
174 NEXT Y
175 NEXT X
176 LOCATE 19,1:PRINT ".............................................................................";
180 LOCATE 20,25:INPUT "which text file ";FILE$
185 IF FILE$="" THEN RUN
186 IF INSTR(FILE$,".") >0 THEN 180
187 IF LEN(FILE$)>8 THEN BFILE$=MID$(FILE$,1,8):FILE$=BFILE$
190 FILE$=FILE$+".TXT"
200 BFILE$=FILE$
201 FOR X=1 TO LEN(FILE$)-4
202 IF ASC(MID$(FILE$,X,1))=32 THEN 180
203 NEXT X
205 IF MID$(FILE$,1,4)="HELP" OR MID$(FILE$,1,6)="SECRET" THEN LM=1:RM=2:GOTO 230
225 LM=1:RM=80:TB=5
230 GOSUB 2230
250 ON ERROR GOTO 510
280 LOCATE 12,30:COLOR 23,0:PRINT "loading the document":COLOR 7,0
290 GOTO 320
300 LM=1:RESUME 220
310 RM=80:RESUME 225
315 TB=5:RESUME 230
320 OPEN FILE$ FOR INPUT AS #1
330 INPUT #1, LE
340 IF LE>AMAP THEN LE=AMAP
350 FOR X=1 TO LE
355 IF X=EP THEN INPUT #1,Q$:GOTO 370
360 LINE INPUT #1,Q$
361 IF LEN(Q$)<80 THEN Q$=Q$+"                             "
362 IF MID$(Q$,1,1)=CHR$(2) THEN 370
365 MID$(FORM$(X),1,80)=Q$
370 NEXT
380 ON ERROR GOTO 410
385 IF MID$(FILE$,1,4)="help" OR MID$(FILE$,1,6)="secret" THEN TB=1:GOTO 420
390 INPUT #1, LM,RM,TB
400 GOTO 420
410 ON ERROR GOTO 0:RESUME 420
420 CLOSE #1
425 IF MID$(FILE$,1,4)="help" OR MID$(FILE$,1,6)="secret" THEN 500
430 M=INSTR(FILE$,"TXT")
440 MID$(BFILE$,M,3)="BAK"
450 NEWF=1
500 CLS:S=0
510 IF ERR=53 THEN CLOSE #1:LOCATE 23,20:PRINT "must be a new file......";:S=1:RESUME 520
520 ON ERROR GOTO 0
530 T=1:B=24
540 IF S=0 THEN GOTO 1190
550 CLS
560 V=1:H=LM:TEM=255
570 A$=" "
580 S=1:TEM$=STRING$(255,32)
590 LOCATE 25,42:PRINT " 2 ";:COLOR 8,7:PRINT "save";:COLOR 7,0:PRINT " 4 ";:COLOR 8,7:PRINT "quit";:COLOR 7,0:PRINT " 6 ";:COLOR 8,7:PRINT "alt";:COLOR 7,0:PRINT " 8 ";:COLOR 8,7:PRINT "reform";:COLOR 7,0
600 PRINT " 10 ";:COLOR 8,7:PRINT "print";:COLOR 7,0
601 LOCATE 25,1:PRINT "1 ";:COLOR 8,7:PRINT "LMs";:COLOR 7,0:PRINT " 3 ";:COLOR 8,7:PRINT "RMs";:COLOR 7,0:PRINT " 5 ";:COLOR 8,7:PRINT "TBs";:COLOR 7,0:PRINT " 7 ";:COLOR 8,7:PRINT " LINEi";:COLOR 7,0
602 PRINT " 9 ";:COLOR 8,7:PRINT "LINEd";:COLOR 7,0:PRINT "  ";CHR$(206);CHR$(205);CHR$(205);CHR$(205);CHR$(206);
605 KEY(1) ON
610 KEY(2) ON
615 KEY(3) ON
620 KEY(4) ON
625 KEY(5) ON
630 KEY(6) ON
635 KEY(7) ON
640 KEY (8) ON
645 KEY(9) ON
650 KEY (10) ON
660 KEY(11) ON
670 KEY(12) ON
680 KEY(13) ON
690 KEY(14) ON
695 ON KEY (1) GOSUB 2000
700 ON KEY (2) GOSUB 1150
705 ON KEY (3) GOSUB 2010
710 ON KEY (4) GOSUB 1740
715 ON KEY (5) GOSUB 2020
720 ON KEY (6) GOSUB 1820
725 ON KEY (7) GOSUB 2300
730 ON KEY (8) GOSUB 2800
735 ON KEY (9) GOSUB 2400
740 ON KEY (10) GOSUB 1950
750 ON KEY (11) GOSUB 1330
760 ON KEY (12) GOSUB 1360
770 ON KEY (13) GOSUB 1390
780 ON KEY (14) GOSUB 1420
790 GOSUB 1450
795 IF TEM<>255 THEN PRINT TEM
796 IF S=5 THEN S=1:GOTO 914
798 GOSUB 1900
799 GOSUB 1910
800 A$=INKEY$
810 IF A$="" AND MID$(A$,2,1)="" THEN 800
815 GOSUB 1900
820 IF ASC(A$)=0 THEN 910
830 IF ASC(A$)=8 THEN GOSUB 940
840 IF ASC(A$)=9 THEN GOSUB 1010
850 IF ASC(A$)=13 THEN PRINT MID$(FORM$(XX(V)),H,1);:CR=1:H=LM:GOSUB 1420
860 IF ASC(A$)<32 OR ASC(A$)>254 THEN 799
880 IF TEM<>255 THEN TEM=255
885 VL=INSTR(FORM$(XX(V)),CHR$(1))
890 PRINT A$;:MID$(FORM$(XX(V)),H)=A$:IF H<80 THEN MID$(FORM$(XX(V)),VL-1,1)=" "
900 H=H+1:GOSUB 1450
905 IF FLAG=1 THEN 799
910 IF ASC(MID$(A$,2))=82 THEN GOSUB 980
914 IF ASC(MID$(A$,2))=71 THEN V=1:T=1:B=24:S=4:GOSUB 1500
915 IF ASC(MID$(A$,2))=79 THEN T=LE-22:B=LE+1:V=B:S=4:GOSUB 1500
916 IF ASC(MID$(A$,2))=73 THEN T=T-24:B=B-24:V=B:S=4:GOSUB 1500
917 IF ASC(MID$(A$,2))=81 THEN T=T+24:B=B+24:V=T:S=4:GOSUB 1500
920 IF ASC(MID$(A$,2))=83 THEN GOSUB 1120
925 IF ASC(MID$(A$,2))=15 THEN GOSUB 1005
926 IF ASC(MID$(A$,2))=120 THEN GOSUB 2600
930 GOTO 799
940 DC=1:GOSUB 1360
941 IF TEM-1<=0 THEN BEEP:GOTO 1450
942 MID$(TEM$,TEM,1)=MID$(FORM$(XX(V)),H,1):MID$(FORM$(XX(V)),H,1)=CHR$(32):TEM=TEM-1
950 IF TEM >0 THEN 1450
980 MID$(FORM$(XX(V)),H+1)=MID$(FORM$(XX(V)),H)
990 MID$(FORM$(XX(V)),H)=" "
1000 GOTO 1125
1005 IF TEM=255 THEN PRINT MID$(FORM$(XX(V)),H,1);:H=INT((H-LM)/TB)*TB+LM-TB:GOTO 1450
1006 GOTO 1015
1010 IF TEM=255 THEN PRINT MID$(FORM$(XX(V)),H,1);:H=INT((H-LM)/TB)*TB+LM+TB:GOTO 1450
1015 TTEM=TEM+1:CL=255-TEM
1020 ROOM=RM-H+1
1030 IF ROOM>CL THEN 1100
1040 MID$(FORM$(XX(V)),H,ROOM)=MID$(TEM$,TTEM,ROOM)
1050 PRINT MID$(FORM$(XX(V)),H,ROOM-1);:IF ROOM=1 THEN PRINT " ";
1055 TTEM=TTEM+ROOM:CL=CL-ROOM
1060 CM=1:GOSUB 1600:CM=0
1070 FLAG=0
1080 GOTO 1020
1100 IF CL=0 THEN 1450
1101 MID$(FORM$(XX(V)),H,CL)=MID$(TEM$,TTEM,CL):PRINT MID$(FORM$(XX(V)),H,CL);
1110 MID$(FORM$(XX(V)),80,1)=" ":H=H+CL:GOTO 1450
1120 C=INSTR(FORM$(XX(V)),CHR$(1))
1121 MID$(FORM$(XX(V)),H)=MID$(FORM$(XX(V)),H+1)
1122 MID$(FORM$(XX(V)),C-1,2)=" "+CHR$(1)
1125 VV=V-T+1
1130 LOCATE VV,1:PRINT MID$(FORM$(XX(V)),1,79);:LOCATE VV,H
1140 GOTO 1450
1150 GOSUB 1900
1151 CLS
1160 IF B>LE THEN LE=B
1170 T=1:B=LE
1180 IF S<>5 THEN 1188
1182 A$=CHR$(0)+CHR$(71):GOTO 605
1188 IF S=1 THEN LOCATE 12,30:COLOR 23,0:PRINT "saving the document":COLOR 7,0
1189 IF S=3 THEN LOCATE 12,30:COLOR 23,0:PRINT "backing up document":COLOR 7,0
1190 IF S=0 OR S=4 THEN LOCATE 25,42:PRINT " 2 ";:COLOR 8,7:PRINT "save";:COLOR 7,0:PRINT " 4 ";:COLOR 8,7:PRINT "quit";:COLOR 7,0:PRINT " 6 ";:COLOR 8,7:PRINT "alt";:COLOR 7,0:PRINT " 8 ";:COLOR 8,7:PRINT "reform";:COLOR 7,0
1200 IF S=0 OR S=4 THEN PRINT " 10 ";:COLOR 8,7:PRINT "print";:COLOR 7,0
1201 IF S=0 OR S=4 THEN LOCATE 25,1:PRINT "1 ";:COLOR 8,7:PRINT "LMs";:COLOR 7,0:PRINT " 3 ";:COLOR 8,7:PRINT "RMs";:COLOR 7,0:PRINT " 5 ";:COLOR 8,7:PRINT "TBs";:COLOR 7,0:PRINT " 7 ";:COLOR 8,7:PRINT " LINEi";:COLOR 7,0
1202 IF S=0 OR S=4 THEN PRINT " 9 ";:COLOR 8,7:PRINT "LINEd";:COLOR 7,0:PRINT "  ";CHR$(206);CHR$(205);CHR$(205);CHR$(205);CHR$(206);
1210 IF NOT(S=1 OR S=3) THEN 1240
1211 IF S=3 OR NEWF=0  THEN 1220
1212 ON ERROR GOTO 1216
1213 KILL BFILE$
1214 ON ERROR GOTO 0:NAME FILE$ AS BFILE$
1215 GOTO 1220
1216 RESUME 1214
1220 IF S=1 THEN OPEN FILE$ FOR OUTPUT AS #1
1230 IF S=3 THEN OPEN BFILE$ FOR OUTPUT AS #1
1235 PRINT #1,LE
1240 FOR X=T TO B
1250 IF S=0 OR S=4 THEN LOCATE 24-B+X,1
1260 IF S=0 OR S=4  THEN IF MID$(FORM$(XX(X)),80,1)<>CHR$(2) THEN PRINT MID$(FORM$(XX(X)),1,79);
1265 ON ERROR GOTO 2500
1270 IF S=1 OR S=3 THEN IF MID$(FORM$(XX(X)),80,1)=CHR$(2) THEN PRINT #1,CHR$(2) ELSE PRINT #1,MID$(FORM$(XX(X)),1,81)
1280 NEXT X
1290 IF S=0 THEN H=LM:V=1: GOTO 580
1295 IF S=1 OR S=3 THEN PRINT#1, LM,RM,TB
1296 ON ERROR GOTO 0
1300 CLOSE #1
1305 GOSUB 1910
1310 IF S=3 OR S=4 THEN RETURN
1320 RUN
1330 GOSUB 1900
1331 IF H=80 THEN PRINT " "; ELSE PRINT MID$(FORM$(XX(V)),H,1);
1332 PRST=60*VAL(MID$(TIME$,4))+VAL(MID$(TIME$,7))
1333 IF PRST>LPVST+1 THEN Q=1 ELSE Q=Q+1
1334 LPVST=PRST
1340 V=V-Q:D=-1
1350 GOTO 1450
1360 GOSUB 1900
1361 IF H=80 THEN PRINT " "; ELSE PRINT MID$(FORM$(XX(V)),H,1);
1362 PRST=60*VAL(MID$(TIME$,4))+VAL(MID$(TIME$,7))
1363 IF PRST>RPVST+1 THEN Q=1 ELSE Q=Q+1
1364 RPVST=PRST
1365 IF DC=1 THEN DC=0:Q=1
1370 H=H-Q:D=-1
1380 GOTO 1450
1390 GOSUB 1900
1391 IF H=80 THEN PRINT " "; ELSE PRINT MID$(FORM$(XX(V)),H,1);
1392 PRST=60*VAL(MID$(TIME$,4))+VAL(MID$(TIME$,7))
1393 IF PRST>UPVST+1 THEN Q=1 ELSE Q=Q+1
1394 UPVST=PRST
1400 H=H+Q:D=1
1410 GOTO 1450
1420 GOSUB 1900
1421 IF CR=1 THEN 1422 ELSE IF H=80 THEN PRINT " "; ELSE PRINT MID$(FORM$(XX(V)),H,1);
1422 PRST=60*VAL(MID$(TIME$,4))+VAL(MID$(TIME$,7))
1423 IF PRST>DPVST+1 THEN Q=1 ELSE Q=Q+1
1424 DPVST=PRST
1425 IF CR=1 THEN CR=0:Q=1
1430 V=V+Q:D=1
1440 GOTO 1450
1450 IF V=AMAP AND H=RM THEN V=1:H=LM:B=24:T=1:S=4
1460 IF H<LM THEN H=RM-1:V=V-1
1470 IF EP=V THEN V=V+D
1480 IF V<T THEN T=T-18:B=B-18:S=4
1490 IF V>B OR (V=B AND H=RM) THEN T=T+18:B=B+18:S=4
1500 IF T<1 THEN BEEP:T=1:B=24:V=24
1510 IF B>AMAP THEN BEEP:B=AMAP:T=B-23:V=AMAP
1520 IF V>LE THEN LE=V
1530 IF S=4 THEN CLS:GOSUB 1190:S=1
1540 IF H>RM THEN H=LM:GOTO 1600
1550 IF DEL=1 THEN GOTO 1020
1560 LOCATE 25,36:PRINT USING "###";V;:PRINT " ";:PRINT USING "##";H;
1565 LOCATE 24-B+V,H
1570 COLOR 8,7:PRINT MID$(FORM$(XX(V)),H,1);:COLOR 7,0
1580 LOCATE 24-B+V,H
1585 IF DEL=2 THEN 1030
1586 GOSUB 1910
1590 FLAG=1:RETURN
1600 IF ASC(MID$(FORM$(XX(V)),RM,1))=32 OR ASC(MID$(FORM$(XX(V)),RM,1))=2 THEN V=V+1:H=LM:GOTO 1450
1610 XX=RM
1615 ON ERROR GOTO 0
1620 XX=XX-1
1630 IF XX=LM OR XX=LM-1 THEN PRINT "here":MID$(FORM$(XX(V)),80,1)=" ":V=V+1:H=1:GOTO 1460
1635 IF CM=1 AND XX<H THEN 1645
1640 IF ASC(MID$(FORM$(XX(V)),XX,1))<>32 THEN 1620
1645 IF EP=V+1 THEN EPS=2 ELSE EPS=1
1646 IF AMAP=V THEN EPS=0
1650 MID$(FORM$(XX(V+EPS)),LM,RM-XX)=MID$(FORM$(XX(V)),XX+1,RM-XX)
1660 MID$(FORM$(XX(V)),XX+1,RM-XX)=STRING$(RM-XX,32)
1670 VV=24-B+V
1680 LOCATE VV,XX+1
1685 IF V=AMAP THEN XX=XX+1
1690 PRINT MID$(FORM$(XX(V)),XX+1,RM-XX);
1700 IF S=5 THEN S=1
1705 V=V+EPS:GOSUB 1450:PRINT " ";:VV=24-B+V
1710 LOCATE VV,LM:PRINT MID$(FORM$(XX(V)),LM,RM-XX);:MID$(FORM$(XX(V)),80,1)=" "
1720 H=RM-XX+LM
1730 GOTO 1460
1740 GOSUB 1900
1741 CLS
1750 ON ERROR GOTO 1790
1760 IF MID$(FILE$,1,4)="help" OR MID$(FILE$,1,6)="secret" THEN RUN
1761 C=INSTR(FILE$,".")-1:IF FILE$=BFILE$ THEN 1770
1762 LOCATE 5,5:PRINT "WARNING everything you've changed or added to the original file ";MID$(FILE$,1,C)
1763 LOCATE 6,5:PRINT " will be lost "
1764 LOCATE 20,5:PRINT "Do you want to save your changes or additions (type Y or N) ";
1765 GOTO 1780
1770 LOCATE 5,5:PRINT "WARNING everything you've typed into the new file ";MID$(FILE$,1,C)
1771 LOCATE 6,5:PRINT " will be lost "
1772 LOCATE 20,5:PRINT "Do you want to save this file (type Y or N) ";
1780 INPUT A$:IF A$="y" OR A$="Y" THEN CLS:S=1:GOTO 1160
1781 IF A$="n" OR A$="N" THEN RUN
1790 IF ERR=53 THEN RESUME 1810 ELSE RESUME 1800
1795 CLS:GOTO 1761
1800 GOSUB 1910:S=0:CLS:GOTO 530
1810 ON ERROR GOTO 0:RUN
1820 GOSUB 1900
1830 IF MID$(FORM$(XX(V)),80,1)<>CHR$(2) THEN PRINT MID$(FORM$(XX(V)),H,1):H=1:V=V+1:GOSUB 1450:GOTO 1830
1835 MID$(FORM$(XX(V)),80,1)=" "
1836 H=1:GOSUB 1450
1840 FOR X=1 TO 6:PRINT CHR$(X);:MID$(FORM$(XX(V)),X,1)=CHR$(X):NEXT X
1850 FOR X=14 TO 27:PRINT CHR$(X);:MID$(FORM$(XX(V)),X-7,1)=CHR$(X):NEXT X
1860 FOR X=123 TO 181:PRINT CHR$(X);:MID$(FORM$(XX(V)),X-103,1)=CHR$(X):NEXT X
1865 V=V+1:GOSUB 1450
1870 IF MID$(FORM$(XX(V)),80,1)<>CHR$(2) THEN PRINT MID$(FORM$(XX(V)),H,1):V=V+1:GOSUB 1450:GOTO 1870
1874 MID$(FORM$(XX(V)),80,1)=" "
1875 FOR X=182 TO 255:PRINT CHR$(X);:MID$(FORM$(XX(V)),X-181,1)=CHR$(X):NEXT X
1876 PRINT MID$(FORM$(XX(V)),H,1);:V=V+1:GOSUB 1450
1880 GOSUB 1910
1890 GOTO 1450
1900 KEY (1) OFF:KEY (2) OFF:KEY (3) OFF:KEY (4) OFF:KEY (5) OFF:KEY (6) OFF:KEY (7) OFF: KEY (8) OFF:KEY (9) OFF:KEY (10) OFF:KEY (11) OFF:KEY (12) OFF:KEY (13) OFF:KEY (14) OFF:RETURN
1910 KEY (1) ON:KEY (2) ON:KEY (3) ON:KEY (4) ON:KEY (5) ON:KEY (6) ON:KEY (7) ON: KEY (8) ON:KEY (9) ON:KEY (10) ON:KEY (11) ON:KEY (12) ON:KEY (13) ON:KEY (14) ON:RETURN
1930 GOTO 1450
1940 RETURN 660
1950 ON ERROR GOTO 2285
1952 PRINT "normal (0) or emphasized (1) print"
1953 INPUT Z9
1954 LPRINT CHR$(27);"F":IF Z9=1 THEN LPRINT CHR$(27);"E"
1955 FOR X=1 TO LE
1960 IF X=EP THEN 1980
1970 LPRINT MID$(FORM$(XX(X)),1,79)
1980 NEXT
1985 LPRINT CHR$(27);"F"
1990 RETURN
2000 GOSUB 1900
2001 IF LM<>1 THEN LM=1:GOTO 2230
2008 LM=H:GOTO 2230
2010 GOSUB 1900
2011 IF RM<>80 THEN RM=80:GOTO 2230
2018 RM=H:GOTO 2230
2020 GOSUB 1900
2021 TB=H-LM:GOTO 2230
2230 BEEP:IF LM<1 THEN LM=1
2240 IF LM>78 THEN LM=78
2250 ON ERROR GOTO 510
2260 IF RM<3 THEN RM=3
2270 IF RM>80 THEN RM=80
2275 IF TB<1 THEN TB=1
2276 IF TB>78 THEN TB=78
2277 GOSUB 1910
2280 RETURN
2285 ON ERROR GOTO 0:RESUME 2280
2300 GOSUB 1900
2301 YY=XX(LE)
2302 IF RF=1 THEN 2310 ELSE PRINT MID$(FORM$(XX(V)),H,1);
2310 FOR X=LE-1 TO V STEP -1
2315 IF X=EP THEN XX(X+1)=XX(X-1):X=X-1:GOTO 2330
2320 XX(X+1)=XX(X)
2330 NEXT X
2335 IF LE=AMAP THEN XX(V)=YY:FORM$(XX(V))=STRING$(82,32):MID$(FORM$(XX(V)),80,2)=CHR$(2)+CHR$(1):GOTO 2345
2336 IF LE+1=EP THEN LE=LE+1
2340 XX(V)=XX(LE+1):XX(LE+1)=YY
2345 IF RF=1 THEN 2384
2350 LOCATE 24-B+V,1:PRINT STRING$(79,32);
2360 FOR X=V TO B
2362 LOCATE 24-B+X,1
2364 IF X=AMAP THEN 2370
2365 IF X=B THEN PRINT MID$(FORM$(XX(X)),1,78);:GOTO 2380
2366 IF MID$(FORM$(XX(X)),80,1)=CHR$(2) AND MID$(FORM$(XX(X+1)),80,1)=CHR$(2) THEN PRINT:GOTO 2380
2370 PRINT MID$(FORM$(XX(X)),1,79);
2380 NEXT
2384 IF LE=AMAP THEN 2390
2385 LE=LE+1
2390 GOTO 2480
2400 GOSUB 1900:YY=XX(V)
2401 IF V>LE THEN 2480
2402 IF RF=1 THEN 2403 ELSE LOCATE 24-B+V,H:PRINT " ";
2403 FOR X=V TO LE-1
2404 IF X=AMAP THEN 2420
2405 IF X=EP-1 THEN XX(X)=XX(X+2):X=X+1:GOTO 2420
2410 XX(X)=XX(X+1)
2420 NEXT X
2425 XX(LE)=YY
2430 FORM$(XX(LE))=STRING$(81,32):MID$(FORM$(XX(LE)),80,2)=CHR$(2)+CHR$(1)
2440 IF RF=1 THEN 2475
2445 LOCATE 24-B+V,1:PRINT MID$(FORM$(XX(V)),1,79);
2450 FOR X=V+1 TO B-1
2452 LOCATE 24-B+X,1
2455 IF MID$(FORM$(XX(X)),80,1)=CHR$(2) AND MID$(FORM$(XX(X-1)),80,1)=CHR$(2) THEN PRINT:GOTO 2470
2460 PRINT MID$(FORM$(XX(X)),1,79);
2470 NEXT X
2474 LOCATE 24,1:PRINT MID$(FORM$(XX(B)),1,78);
2475 LE=LE-1
2480 IF RF=1 THEN 2496 ELSE LOCATE 24-B+V,H
2490 COLOR 8,7:PRINT MID$(FORM$(XX(V)),H,1);:COLOR 7,0
2495 LOCATE 24-B+V,H
2496 GOSUB 1910:RETURN
2500 IF ERR=61 THEN KILL FILE$:ON ERROR GOTO 2505:RESUME 2502
2501 ON ERROR GOTO 0:RESUME
2502 NAME BFILE$ AS FILE$:LOCATE 20,10:PRINT "THIS DISK IS FULL, PLEASE INSERT ANOTHER BLANK, INITIALIZED DISK ";:FOR ZZ=1 TO 10000:NEXT ZZ:RESUME 1210
2505 LOCATE 20,10:PRINT "THIS DISK IS FULL, PLEASE INSERT ANOTHER BLANK, INITIALIZED DISK ";:FOR ZZ=1 TO 10000:NEXT ZZ:RESUME 1210
2510 ON ERROR GOTO 0:RESUME 1210
2600 SS=1:GOSUB 2700
2610 IF X=79 THEN RETURN ELSE L=X
2620 LOCATE 24-B+V,1:PRINT STRING$(79,32);
2630 SS=INSTR(X+1,FORM$(XX(V))," "):GOSUB 2700
2640 IF X<>79 THEN 2630
2645 IF SS=1 THEN RETURN
2650 R=79-SS:X=INT((L+R)/2+0.5):LOCATE 24-B+V,1:PRINT STRING$(X,32);MID$(FORM$(XX(V)),L,SS-L);
2660 FORM$(XX(V))=STRING$(X,32)+MID$(FORM$(XX(V)),L,80-X)+CHR$(1)
2665 GOSUB 1450:RETURN
2700 FOR X=SS TO 79
2710 IF MID$(FORM$(XX(V)),X,1)<>" " THEN RETURN
2720 NEXT X
2730 RETURN 2645
2800 OH=1:RH=LM:RF=1:FTF=1
2804 LOCATE 24-B+V,H:PRINT MID$(FORM$(XX(V)),H,1);:V=V-1
2805 GOSUB 3000:OLM=OH:OH=1
2806 V=V+1:GOSUB 3000
2807 IF OH>79 THEN IF OLM<LM THEN FTF=0 ELSE OLM=LM 'if sub olm=1 for ftf will  keep a one line parpagram margin otherwise lm justifies the line
2808 IF OH>79 THEN 2810
2809 IF OLM>=OH THEN OLM=OH ELSE 2999
2810 OH=1:GOSUB 2300
2820 GOSUB 3000
2821 IF FTF=2  THEN FTF=0:IF OH<>OLM THEN 2999
2822 IF FTF=1 THEN FTF=0:CL=EN:RH=LM:OH=OLM
2823 IF RH+CL>RM THEN V=V+1:GOSUB 2300:RH=LM
2824 IF EP=V+1 THEN Z=2 ELSE Z=1
2830 MID$(FORM$(XX(V)),RH,CL)=MID$(FORM$(XX(V+Z)),OH,CL):MID$(FORM$(XX(V)),80,2)=" "+CHR$(1):RH=RH+CL:OH=OH+CL:GOTO 2820
2999 S=4:GOSUB 1500:RF=0:GOTO 1450
3000 IF EP=V+1 THEN Z=2 ELSE Z=1
3004 IF MID$(FORM$(XX(V+Z)),OH,1)=" " THEN OH=OH+1:GOTO 3000
3005 IF FTF=1 THEN 3030
3010 IF MID$(FORM$(XX(V+Z)),OH,1)=CHR$(2) THEN RETURN 2999
3020 IF MID$(FORM$(XX(V+Z)),OH,1)=CHR$(1) THEN V=V+Z:FTF=2:GOSUB 2400:V=V-Z:OH=1
3030 EN=INSTR(OH,FORM$(XX(V+Z))," "):CL=EN-OH+1:RETURN
```
{% endraw %}

## FORMGEN.TXT

{% raw %}
```
 44 

This is a brief description of how to work this wordprocessor.                  

On the line below 1 stands for function key 1. If you press that key you reset  
the left margin.                                                                

On the line below 3 stands for function key 3. If you press that key you reset  
the right margin.                                                               

Similarly LINEi means insert a line, LINEd means delete a line, SAVE means save 
a what you have typed, QUIT means quit without saving, ALT gives you all the    
characters you normally can not type form the keyboard, REFORM reforms small    
paragraphs, and PRINT prints text.                                              

The numbers in the middle stand for the cursor row and column position.         

If this program bombs out on you try pushing F1 just after seeing the error     
message, usually you will go right back into the letter you were working on.    

All the keys on the keyboard such as Home, End, Pg UP, Pg DN, Ins, Del, Tab,    
backspace delete, tab and shift backtab work as you would expect.               

To move text eat the letters up with the backspace delete key, then move cursor 
where you want the text to appear and press the tab key. You can repeat this    
process.  To get the tab key acting normally, type in any usual character of    
the alphabet.                                                                   

To center text on a line type the 1 while holding down the ALT key.             

To get the cursor moving slowly wait one second between times you touch the     
arrow keys.  To get the cursor moving quickly, touch the arrow keys as quick as 
you can.                                                                        

For those of you with 48 K, change line 50 so that variable AMAP=66 instead of  
AMAP=133. For some of you, calling FORMGEN with trash still in your memory,     
will not work because it takes up every square bit, yet fits all                
the way in there!                                                               



This program creates a Backup file of the previous letter. You can activate it  
through BASIC or DOS by renaming it with the extension TXT.                     


 1             80            5 
```
{% endraw %}

## POW.DOC

{% raw %}
```
:PN 1 :DM 5,75 :SP 1 :PT 5,3 :PB 5,3 :PL 56 :DB 1,10 :JT
:TM 1,The IBM Personal Computer POW Manual			     Version 3
:BM 37,Page :
:JE
GE	    THE POW WORD PROCESSOR	 
	=== === ==== =========	     
:LF 1
    ON THE IBM PERSONAL COMPUTER    
    == === === ======== ========    
:JT :LF 3
:CM GE(Version 3.0)
:LF 39
:JE
					Michael V. Maieli
					Raleigh, NC
					January, 1983
HF
:JT :NP :JE
GAbstract
--------
H :JT :BP
This manual describes the POW (Processor Of Words) word processing program that
is currently available for the IBM Personal Computer.
Originally designed for the Intel 8080 CPU by Clyde Roby in a program called
PRINTER, POW is a subsequent modification of PRINTER enabling similar usage
with the Intel 8088, the central processing unit used in the IBM Personal
Computer.
:LF 3 :JE
GIntroduction
------------
H :JT :BP
POW is a word processing program capable of executing on the IBM Personal
Computer.
Like most other text formatters, POW accepts inputs in the form of files
which have been created using a program editor.
These files contain two types of data: {1} the reserved keywords (operators),
including their parameters, which together obey the POW syntax rules, and {2}
the actual word text (operands) in upper and lower case which is manipulated
through the use of the reserved keywords in a predetermined way.
Keywords are freely inserted into the source text when it is prepared.
POW has the ability to set and dynamically alter margins, tabs, spacing,
justification, and indentation, and can provide automatic centering.
Automatic pagination including top and bottom titles and/or page numbering is
also available.
:BP
Since POW executes under IBM PC-DOS (MS-DOS), filename conventions for DOS also
apply to POW.
Refer to page 2-8 in the "Disk Operating System" manual for a list of these
conventions.
Additionally, in order to distinguish POW files from all other types of files,
the required file extension '.POW' is used.
:LF 3 :JE
GInvocation
----------
H :JT :BP
To invoke POW, first ensure that the system file POW.COM is on a diskette
which is accessible by the system.
Next, while under the PC-DOS environment, type "POW".
A startup message will be received and POW then waits for user response.
Three options are available to the user at this point; loading, processing, or
exiting.
Normal operation is as follows: {1} Reply with the letter L (capital letter),
{1} Reply with the letter L (capital letter), informing POW that you want to
load a source file.
{2} Input the entire file specification of that source file (i.e.,
d:filename.ext using all capital letters) at which time POW processes the
source file.
{3} Reply with the letter P (capital letter) informing POW to print the output
document.
{4} Upon completion, reply with the letter Q (capital letter) informing POW to
quit and return to PC-DOS (you may, of course, exit POW at any time by
inputting a CTRL-C).
:LF 3 :JE
GPOW Syntax
--- ------
H :JT :BP
Reserved keywords, or commands, are the operators POW uses to carry out tasks.
Commands consist of the same basic format, which is a colon (:) immediately
followed by a two letter command name (an abbreviation resembling the function
to be performed) specified in capital letters.
Some commands do not require any more clarification than this and so would end
at this point with a terminator.
Other commands do require additional clarification, but because of exisiting
defaults, optional parameters need only be supplied if the defaults are to
be overridden.
Delimiters separate options from the command name and from each other, and are
concluded with a terminator.
Delimiters are either a comma (,) or a space ( ), and a terminator can be a
comma (,), a space ( ), or null ().
This allows maximum freedom from rigid command syntax.
:BP
There is no 'literal' command (as there is in SCRIPT/370), but it is still
possible to print out the colon (:) if needed as text data.
The CTRL-K key preceeding any character causes that character to be printed as
it appears without decoding.
Hence, CTRL-K: causes the colon to be printed without any associated POW
meaning.
:BP
The POW commands are examined on the next few pages.
They are presented in alphabetical order, and for each command there exist 5
different sections to describe it.
First, the full command name is given, with capital letters highlighting the
2-character abbreviation.
This 2-character abbreviation is again shown in the second section, syntax,
preceeded by a colon and followed by command parameters, if applicable.
Command semantics make up the third section.
This is the largest section, and it is here that the command is described as
to its function, its parameter requirements and the forms they must take,
its usage in a text file, and any noteworthy points including some examples.
The fourth section show parameter defaults, or the values the parameters will
take if they are not explicitly overridden.
Finally, references to other commands of the same general category or of mutual
dependence are presented.
:NP
ECommand    - Bottom Message
:LF 1
FSyntax     - :BM a,b
:LF 1
Semantics  - The :BM command instructs POW to define a bottom title to be
printed on every page.
Parameter a is numeric; it is the horizontal character position at which the
message will begin.
Parameter b is alphanumeric; it is the actual text of the message.
The colon character, when used in the bottom title, provides automatic page
numbering.
:LF 1
Default    - None
:LF 1
References - See command(s) :TM, :PB
:LF 3
ECommand    - Begin Paragraph
:LF 1
FSyntax     - :BP
:LF 1
Semantics  - The :BP command instructs POW to start a new paragraph.
Upon encountering this command, POW first closes the present line.
It then performs a previously specified number of line feeds (vertical spacing)
and indents to a previously specified character position (horizontal spacing).
:LF 1
Default    - None
:LF 1
References - See command(s) :DB
:LF 3
ECommand    - Close Centering
:LF 1
FSyntax     - :CC
:LF 1
Semantics  - The :CC command instructs POW to stop centering text which was
started with the :CT command.
This command must be paired with the :CT command.
:LF 1
Default    - None
:LF 1
References - See command(s) :CT, :CM
:LF 3
ECommand    - Center Message
:LF 1
FSyntax     - :CM a
:LF 1
Semantics  - The :CM command instructs POW to center a piece of text between
the predefined left and right margins.
The parameter a is alphanumeric; it is the text to be centered.
This command need not be closed by the :CC command because only 1 line of
text will be centered.
:LF 1
Default    - None
:LF 1
References - See command(s) :CC, :CT
:LF 3
ECommand    - Center Text
:LF 1
FSyntax     - :CT a,b
:LF 1
Semantics  - The :CT command instructs POW to center text around a
specified position.
Different from the :CM command, POW will continue to center source text
until a :CC command is encountered.
The parameter a is numeric; it is the position about which text is to be
centered (counting from the left side of the page, NOT the left margin).
The parameter b is alphanumeric; it is the actual text to be centered.
The text will not be printed until the :CC command is encountered.
:LF 1
Default    - None
:LF 1
References - See command(s) :CC, :CM
:LF 3
ECommand    - Define Begin paragraph
:LF 1
FSyntax     - :DB a,b
:LF 1
Semantics  - The :DB command instructs POW to establish paragraph formatting
characteristics.
The parameter a is numeric; it is the number of line feeds (vertical spacing)
to skip before beginning the next paragraph.
The parameter b is numeric; it is the number of character positions
(horizontal spacing) to indent the first line of every paragraph.
The indentation can be set to any position right or left of the left margin.
This can allow for versatile indention formatting.
:LF 1
Default    - a = 1, b = the left margin
:LF 1
References - See command(s) :BP, :DM
:LF 3
ECommand    - Define Margins
:LF 1
FSyntax     - :DM a,b
:LF 1
Semantics  - The :DM command instructs POW to establish left and right
margins.
The parameter a is numeric; it is the position of the left margin.
The parameter b is numeric; it is the position of the right margin.
:LF 1
Default    - a = 10, b = 70
:LF 1
References - See command(s) :DB
:LF 3
ECommand    - Define Tabs
:LF 1
FSyntax     - :DT a,b,c,d...
:LF 1
Semantics  - The :DT command instructs POW to set up tabs.
A maximum of 14 tabs can be set.
The parameters a, b, c, d... are numeric; they are the positions of the tabs.
Tabs must be in ascending order and no error checking is done on them.
:LF 1
Default    - a = 15, b = 22, c = 30, d = 45
:LF 1
References - None
:LF 3
ECommand    - Justification End
:LF 1
FSyntax     - :JE
:LF 1
Semantics  - The :JE command instructs POW to close the present line and end
all justification (formatting).
:LF 1
Default    - None
:LF 1
References - See command(s) :JL, :JT
:LF 3
ECommand    - Justification Left
:LF 1
FSyntax     - :JL
:LF 1
Semantics  - The :JL command instructs POW to begin justification
(formatting) with respect to the left margin only.
It produces what is known as "ragged right" formatting.
:LF 1
Default    - None
:LF 1
References - See command(s) :JE, :JT
:LF 3
ECommand    - Justification Total
:LF 1
FSyntax     - :JT
:LF 1
Semantics  - The :JT command instructs POW to begin total justification
(formatting) with respect to both the left and right margins.
Automatic space filling is performed.
:LF 1
Default    - None
:LF 1
References - See command(s) :JE, :JL
:LF 3
ECommand    - Line Feed
:LF 1
FSyntax     - :LF a
:LF 1
Semantics  - The :LF command instructs POW to skip a specified number of
vertical spaces.
The parameter a is numeric; it is the the number of carriage return/line
feed sequences desired.
:LF 1
Default    - a = 1
:LF 1
References - None
:LF 3
ECommand    - New Page
:LF 1
FSyntax     - :NP
:LF 1
Semantics  - The :NP command instructs POW to eject to a new page.
It forces the close of the present page, feeds it out of the printer,
and then begins a new page.
:LF 1
Default    - None
:LF 1
References - See command(s) :PN
:LF 3
ECommand    - OFf printer
:LF 1
FSyntax     - :OF
:LF 1
Semantics  - The :OF command instructs POW to turn off the printer.
The program continues to process text as if the printer were on, but there
is no output.
By using the :OF and :ON commands, non-printable commentary can reside in
the source text.
:LF 1
Default    - None
:LF 1
References - See command(s) :ON
:LF 3
ECommand    - ON printer
:LF 1
FSyntax     - :ON
:LF 1
Semantics  - The :ON command instructs POW to turn on the printer after it
has been turned off by the :OF command.
By using these two commands, a section of text input can be skipped over
without printing.
:LF 1
Default    - None
:LF 1
References - See command(s) :OF
:LF 3
ECommand    - Page Bottom
:LF 1
FSyntax     - :PB a,b
:LF 1
Semantics  - The :PB command instructs POW to reserve a bottom-of-page
section, acting as a page trailer.
The parameter a is numeric; it specifies how many lines are to be dedicated
to the trailer.
If this parameter is zero, text printing continues to the absolute bottom of
the page.
The parameter b is numeric; it specifies which line into the trailer (counting
sequentially from the bottom of this reserved section) will contain the bottom
title if one was specified.
A value of zero for this parameter cancels bottom title printing.
:LF 1
Default    - a = 10, b has no default
:LF 1
References - See command(s) :PT, :BM, :PL
:LF 3
ECommand    - PaGe
:LF 1
FSyntax     - :PG
:LF 1
Semantics  - The :PG command instructs POW to immediately force the beginning
of a new page, regardless of whether the present page is finished or not.
:LF 1
Default    - None
:LF 1
References - See command(s) :NP
:LF 3
ECommand    - Page Length
:LF 1
FSyntax     - :PL a
:LF 1
Semantics  - The :PL command instructs POW as to how long the text portion of
the page will be.
The parameter a is numeric; it is the length of the text portion of the page.
This parameter can be changed to allow the program to adapt to any physical
size of paper, but should be chosen carefully to perfectly match the logical
page size to the physical page size.
For instance, if the paper being used is the standard 8.5 inch by 11 inch white
bond paper and the character print is set at 6 lines per inch, then 66 lines can
fit on a physical page.
Therefore, the command parameters which affect logical page size (i.e., the
"a" parameters on :PT, :PL, and :PB commands) should all be chosen such that
their sum equals exactly 66.
:LF 1
Default    - a = 45
:LF 1
References - See command(s) :PB, :PT
:LF 3
ECommand    - Page Number
:LF 1
FSyntax     - :PN a
:LF 1
Semantics  - The :PN command instructs POW to set the page number to a
specified value.
The maximum value is 256.
:LF 1
Default    - a = 0
:LF 1
References - None
:LF 3
ECommand    - Page Top
:LF 1
FSyntax     - :PT a,b
:LF 1
Semantics  - The :PT command instructs POW to reserve a top-of-page section,
acting as a page header.
The parameter a is a numeric; it specifies how many lines are to be dedicated
to the header.
If this parameter is zero, text printing begins at the absolute top of the
page.
The parameter b is a numeric; it specifies which line into the header (counting
sequentially from the bottom of this reserved section) will contain the top
title if one was specified.
A value of zero for this parameter cancels top title printing.
:LF 1
Default    - a = 10, b has no default
:LF 1
References - See command(s) :PB, :TM, :PL
:LF 3
ECommand    - SPacing
:LF 1
FSyntax     - :SP a
:LF 1
Semantics  - The :SP command instructs POW to set the line spacing for the
output text.
The parameter a is numeric; it specifies the line spacing.
A value of 1 for this parameter indicates single spacing, 2 double spacing,
3 triple spacing, etc.
:LF 1
Default    - a = 1
:LF 1
References - None
:LF 3
ECommand    - Top Message
:LF 1
FSyntax     - :TM a,b
:LF 1
Semantics  - The :TM command instructs POW to define a top title to be
printed on every page.
Parameter a is numeric; it is the horizontal character position at which the
message will begin.
Parameter b is alphanumeric; it is the actual text of the message.
The colon character, when used in the top title, provides automatic page
numbering.
:LF 1
Default    - None
:LF 1
References - See command(s) :BM, :PT
:JT :NP :JE
GFont Usage
---- -----
H :JT :BP
POW is capable of using all of the 12 fonts available on the IBM 80-CPS
Personal Computer printer (Epson MX-80) for text processing.
Fonts are subject only to the normal constraints imposed by PC-DOS.
:BP
Here is an example:
:JE :LF 1
This is the standard font (80 cpl, 6 lpi) activated on startup.
    CNT-O activates the compressed font (132 cpl), effective until a
CNT-R is issued whereupon the standard font is reactivated.
CNT-N starts expanded font (40 cpl) &
CNT-T allows the standard font to be reactivated.
  CNT-O/CNT-N foster the compressed/expanded font (66 cpl)
with CNT-R/CNT-T reactivating the standard font.
:LF 1
This is the standard mode.
GESC-G activates double strike mode, usable by the standard font,
    or the compressed font,
or the expanded font,
  or the compressed/expanded font.
HESC-H stops the double strike mode, and starts the standard mode.
EESC-E activates emphasized mode, usable by the standard font,
or the expanded font,
but not with the compressed font or the compressed/expanded font.
FESC-F deactivates the emphasized mode, and starts the standard mode.
GEESC-G/ESC-E is the double strike/emphasized mode for standard font
or the expanded font,
but not with the compressed font or the compressed/expanded font.
HFESC-H/ESC-F reactivates the standard mode.
:LF 3 :JE
GFunctional Limitations
---------- -----------
H :JT :BP
POW is a simple word processor (it only possesses 22 commands).
It has minor similarity to IBM's program product SCRIPT/370 in that commands are
two character abbreviations preceeded by a special symbol (a colon in POW's
syntax) which can appear freely throughout the user text.
It can perform the most fundamental (and most frequently used) format
techniques, but SCRIPT users may be frustrated at POW's lack of
sophisticated function.
POW doesn't have the capabilty to do some trivial tasks, such as underlining,
character translation, imbed functions, or roman numerals, nor can it perform
more difficult tasks like storing a table of contents or an index, keeping
a section of text immune from page ejects, or having any run time processing
logic.
POW makes no distinction between line spaces and line skips; every :LF is a
line space regardless of whether is just occurred on a new page.
Additionally, no macro facility is provided to invent such routines.
There is no way to store output from POW in a file or send it to the video
monitor for a quick review before printing.
Graphics are limited to character graphics (that which is available on the
printer), and, without the use of a SPOOL program to keep the printer operating
independent of the system unit, POW will only process and print text one page
at a time.
This means the user has to stay and hit the enter key after each page has
finished printing.
However, a SPOOL program will alleviate this problem, and when compared to
some word processing programs currently marketed for the IBM PC, POW's
simplicity makes it easy to use and remember.
The adjustment from SCRIPT to POW is much easier than from SCRIPT to
EasyWriter.
(This document was composed using POW.
For tips and techniques used, display the source of this manual.)
:LF 3 :JE
GPOW Idiosyncracies
--- --------------
H :JT :BP
There do exist some bizarre idiosyncracies with this program.
:BP
When using POW, the user must insure that the logical page size, as determined
by some of the commands, equal the physical page size, as determined by the
number of lines printed per inch times the number of inches on the page.
That is, the first parameter on the :PT (page top) and :PB (page bottom)
commands (indicating reserved lines for every page) and the parameter on
the :PL (page length) command (indicating how many lines on each page will be
devoted to text) must sum to the total number of lines on the page.
Normally, this number is 66 (11 inch paper with 6 lpi).
This is not unusual.
What is strange is that if the printer has the print head adjacent to the first
line on the paper, the first page of the document is offset by the number of
lines specified in the first parameter of the :PT command.
All subsequent pages, although logically the right length, are physically
in the wrong position on the paper.
This can be compensated for by turning the printer offline and hitting the line
feed button the number of times specified on the first parameter of the :PT
command.
POW will support other line-per-inch options (such as 8 lpi and 10 lpi), but
the appropriate compensation must be made within the aforementioned
commands.
:BP
Another problem with POW has to do with expanded fonts.
In forming titles, for instance, POW will concatenate following lines of
text to fill out the 40 characters per line allowed in this font.
Even when an attempt is made to pad out the title with suceeding blanks,
POW truncates all but one of the blanks.
To compensate for this, use an unprintable character (such as a CTRL-G) as
the last line of the title to hold the places of all the needed blanks.
POW will "print" a CTRL-G as the last character of the title, but all this
does is just send an audible beep to the printer.
CTRL-K also works and without the alarm.
In effect, we fake out POW.
:BP
The double strike mode is turned on with an ESC-G and turned off with an ESC-H.
The emphasized mode is turned on with an ESC-E and turned off with an ESC-F.
For highlighting purposes, both these modes are used either singly or in
conjunction with one another.
To highlight one line of text, the ESC-G and/or ESC-E starts the line in the
source document.
However, placing an ESC-H and/or ESC-F at the end of the line will not turn
off the hightlight, and the rest of the document remains in the most recently
set highlight mode.
To correct this problem, the ESC-H and/or ESC-F must appear on the next line of
source text.
This turns off the highlight, but, in the case of double strike mode, an extra
blank line will appear in the output text in some instances.
:BP
Actual page numbering only begins with the number "2".
Logical page number integrity is maintained, however, based on the input POW
received on the :PN command.
:JT :NP :JE
GCommand Summary
------- -------
H :JT :BP
Below is a quick summary of all the POW commands, giving command names,
command syntax, and parameter syntax.
:LF 3 :JE
----------------------------------------------------------------------
:BM a,b     Bottom Message	 a = horizontal indentation, b = text
----------------------------------------------------------------------
:BP	     Begin Paragraph
----------------------------------------------------------------------
:CC	     Close Centering
----------------------------------------------------------------------
:CM a	     Center Message	 a = text (single line)
----------------------------------------------------------------------
:CT a,b     Center Text	 a = numeric centering pivot, b = text
----------------------------------------------------------------------
:DB a,b     Define Begin para.  a = # line feeds, b = # spaces
----------------------------------------------------------------------
:DM a,b     Define Margins	 a = left margin, b = right margin
----------------------------------------------------------------------
:DT a,b,... Define Tabs	 a, b,... = tabular column set(s)
----------------------------------------------------------------------
:JE	     Justification End
----------------------------------------------------------------------
:JL	     Justification Left
----------------------------------------------------------------------
:JT	     Justification Total
----------------------------------------------------------------------
:LF a	     Line Feed		 a = # carriage return/line feeds
----------------------------------------------------------------------
:NP	     New Page
----------------------------------------------------------------------
:OF	     OFf printer
----------------------------------------------------------------------
:ON	     ON printer
----------------------------------------------------------------------
:PB a,b     Page Bottom	 a = # trailer lines, b = title line
----------------------------------------------------------------------
:PG	     PaGe
----------------------------------------------------------------------
:PL a	     Page Length	 a = # text lines
----------------------------------------------------------------------
:PN a	     Page Number	 a
----------------------------------------------------------------------
:PT a,b     Page Top		 a = # header lines, b = title line
----------------------------------------------------------------------
:SP a	     SPacing		 a = # of blank spaces between lines
----------------------------------------------------------------------
:TM a,b     Top Message	 a = horizontal indentation, b = text
----------------------------------------------------------------------
:JT :NP :JE
GReferences
----------
H :JE :LF 1
1.) "POWTEXT.POW" document; public IBM PC software library.
:LF 1
2.) "POWCMDS.POW" document; public IBM PC software library.
:LF 1
3.) "SCRIPT/370:User's Guide"; IBM program product.
:LF 3 :JE
GAuthor's Note
-------- ----
H :JT :BP
Legal information was not supplied with POW when it was obtained by the author
of this manual.
No copyright notices are apparent in the program, either on startup or when
using the PC-DOS DEBUG facility.
Additionally, no copyright notices appear with the supplied documentation.
By virtue of these facts, and the fact that program distribution is free (as
witnessed by public PC software library status), no infringement is
committed by using POW.
However, it is safe to assume that the original program from which POW evolved,
PRINTER, was copyrighted by Clyde Roby, and due to similarities between the
two programs, private marketing of POW is not advised.
:BP
The information contained in this manual has been obtained from a variety of
sources and is believed to be correct and reliable, however the author makes
no warranty of any kind, either expressed or implied, with regard to the
program or the documentation contained in this manual.
The author shall not be liable in any event for incidental or consequential
damages in connection with, or arising out of, the furnishing, performance,
or use of this program and its accompanying documentation.
Any changes, errors, and ommissions called to my attention will be greatly
appreciated and the corrections will be made in the next edition.
:LF 5
Michael V. Maieli
:LF 1
January, 1983
:LF 1
=================

```
{% endraw %}

## UNDOWS.DOC

{% raw %}
```












                                     UNDOWS

                                 UN-DO WordStar

                                      V 2.1












                         Copyright 1986, by Gary Elfring







































                                 UNDOWS  V 2.1


           Need to change WordStar files to ASCII in a hurry?   Or do you 
        need  to  remove  the embedded control characters  that  WordStar 
        leaves  in a file?   How about those soft hyphens?   Do you  have 
        WordStar  files with embedded dot commands?   Or do you just want 
        to limit carriage returns to the end of a paragraph?

           Version  2.1  of UNDOWS does all  that  for  you.   First,  it 
        converts WordStar from 8 bit characters to 7 bit ASCII.   It then 
        removes  all control characters,  with the exception of  carriage 
        returns, line feeds, tabs, form feeds, and ^Zs (end of file).  In 
        the  process  it removes those annoying soft hyphens that are  in 
        the middle of a line.   Soft hyphens at the end of a line will be 
        turned into true hyphens.

           Two  new  options have been added for version 2.1  of  UNDOWS.  
        You  can  now strip extra carriage return / line  feed  pairs  by 
        using  the  "s" option.   The only carriage returns left will  be 
        those found at the end of a paragraph.  This option makes it much 
        easier to transfer WordStar files to other word processors.

           The  second  option  forces  UNDOWS  to  remove  embedded  dot 
        commands from your text.  Using this option does slow UNDOWS down 
        since it has to make a second pass through your file.   To remove 
        dot commands use the "d" option.

           UNDOWS  has  been optimized for speed.   On an IBM PC  it  can 
        convert a 40K file on floppy disk in under 15 seconds.  On a hard 
        disk or an AT it is lightning fast.

           To  run UNDOWS you need a source file in WordStar format and a 
        destination file name.  Type:

        UNDOWS source destination [s] [d]{cr}

           Where {cr} stands for the enter/return key.   The "s" and  "d" 
        options  do  not have to be used and can be input in  any  order.  
        UNDOWS  checks for file errors and reports them to you.   DO  NOT 
        use  the  same  file name for the source and  destination  files.  
        Unpredictable things will happen!

        UNDOWS infile outfile{cr}          (normal conversion)

        UNDOWS infile outfile s{cr}        (strip excess CRs)

        UNDOWS infile outfile d{cr}        (remove dot commands)

        UNDOWS infile outfile s d{cr}      (both options)

        UNDOWS infile outfile d s{cr}      (both options)







                                        1






                                 UNDOWS  V 2.1


                               DISTRIBUTION NOTICE 

        This  program  is  protected by United States Copyright  law  and         
        by International Treaty provisions.  You may distribute, or share 
        this  version of this program with anyone provided the  following 
        conditions are met.   This version of UNDOWS is being distributed 
        on a "shareware" basis to all who are interested in it.  To those 
        of you unfamiliar with this approach, it works like this.  UNDOWS 
        is  distributed to various BBS systems and user groups.   You may 
        copy the program and try it for no charge.  Gary Elfring does not 
        handle the actual distribution of this program.   Try the program 
        out.   If the product does not meet your needs,  you pay nothing.  
        If  the product does meet your needs,  and you can use  it,  then 
        send me a fee of $12.50.   If you include a self addressed mailer 
        with  a  blank formatted disk I will supply you with  the  source 
        code for UNDOWS (Lattice C V3.00).  Send your contribution to:

           Gary Elfring
           4N899 West Mary Drive
           St. Charles, Illinois  60174

           Even if you do not contribute,  you are encouraged to copy and 
        distribute  the BBS version of the product freely subject to  the 
        following restrictions: 

        1. Do not distribute altered copies.   If you have suggestions or 
           fixes  you  would like to see,  send us a  written  note.   We 
           welcome all responses.

        2. This product must be distributed complete including the files: 
           UNDOWS.EXE, and UNDOWS.DOC. 

        3. No  fee is to be charged for copying or distributing the  pro-
           gram  without   an   express   WRITTEN  agreement  with   Gary 
           Elfring.  The ONLY exception to this rule is:  a small charge, 
           ($5  to $10),  may be leveled if this program is included on a 
           set of public domain disks. This charge must be reasonable and 
           represent only copying and disk fees. 

        4. Commercial  sale of this product in any manner  is  prohibited 
           without Gary Elfring's written permission. 

        User Groups/Clubs:  Gary Elfring's products may be distributed by 
        Clubs and User Groups subject to the same restrictions.  We would 
        ask  only  that  contributions  to  our  continuing  efforts   be 
        encouraged by those performing such distribution. 

        Computer  Bulletin  Boards:   Gary  Elfring's products   may   be 
        distributed  by  BBS's  subject to   the  same  restrictions  and 
        contribution encouragement. 






                                        2






                                 UNDOWS  V 2.1


                                    WARRANTY

        Gary Elfring specifically disclaims all warranties,  expressed or 
        implied,  including  but  not limited to,  implied warranties  of 
        merchantability and fitness for a particular purpose with respect 
        to defects in the disk or documentation,  and the program license 
        granted herein.  In no event shall Elfring be liable for any loss 
        of  profit  or any other commercial  damage,  including  but  not 
        limited to special, incidental, consequential, or other damages.


                            English Language Warranty

        You  get what you pay for.   If you did not pay for the product I 
        don't care what your problems are.   If you pay for it and have a 
        legitimate complaint,  as determined by me, I will attempt to fix 
        it.   That's it.   What do you want for $12.50?   Send a disk and 
        get the source.






































                                        3




```
{% endraw %}

## WS-DOS.BAS

{% raw %}
```bas
2 ' WS-DOS.BAS
4 ' BY ANDREW FLUEGELMAN
6 ' COPYRIGHT 1983, THE HEADLANDS PRESS, INC.
8 '
10 DEFINT A-Z: ON ERROR GOTO 9000
15 A = 0: A$ = "": L$ = "": P = 0 ' OPTIMIZE KEY VARIABLES
20 CRLF$ = CHR$(13)+CHR$(10): HBLF$ = CHR$(141)+CHR$(10)  ' HARD & SOFT CR/LF
25 SP$ = CHR$(32): TB$ = CHR$(9)  ' SPACE AND TAB
30 SH$ = CHR$(31): PB$ = CHR$(20)  ' SOFT HYPHEN AND PLACEBO
35 DT = 19: DIM D$(19): FOR P = 1 TO DT: READ D$(P): NEXT  ' READ DOT COMMANDS
40 EN = 4: DIM EN(4), ENO$(4), ENC$(4), MRK(4)  ' DIM AND READ ENHANCEMENT CYMBOLS
45 FOR P = 1 TO EN: READ EN(P),ENO$(P), ENC$(P): MRK(P) = 0: NEXT
100 KEY OFF: CLS
105 PRINT "        ==== CONVERT ====="
110 PRINT
115 PRINT "          1 - DOS TO WS"
120 PRINT "          2 - WS TO DOS"
900 PRINT "          X - EXIT"
905 PRINT
910 LOCATE ,10: PRINT "CHOOSE:" ;
915 INPUT "",Q$: IF Q$ = "X" OR Q$ = "x" THEN SYSTEM
920 ON VAL(Q$) GOTO 1000,2000
925 BEEP: GOTO 100
930 '
1000 CLS
1005 PRINT "          === DOS-to-WORDSTAR CONVERTER ==="
1010 PRINT
1015 PRINT "THIS ROUTINE WILL CONVERT A SRANDARD DOS FILE INTO THE FORMAT
1020 PRINT "  REQUIRED BY WORDSTAR FOR PARAGRAPH REFORMING BY CONVERTING
1025 PRINT "  'HARD' CARRIAGE RETURNS (ASCII 13) INTO 'SOFT' CR's (ASCII 141).
1030 PRINT "IF THE FILE CONTAINS BLANK LINES BETWEEN PARAGRAPHS OR INDENTED
1035 PRINT "  PARAGRAPHS, HARD CR's WILL BE PRESERVED AT THE END OF EACH PARAGRAPH.
1040 PRINT
1045 GOSUB 8000: IF FL$ = "" THEN 100
1050 PRINT : PRINT " CONVERSION IS IN PROGRESS...";
1055  IF EOF(1) THEN 8045 ELSE LINE INPUT #1, L$
1060  IF EOF(1) THEN PRINT #2, L$+CRLF$;: GOTO 8045
1065 LINE INPUT #1, A$
1070 IF A$ = "" THEN 1090 ' TEST FOR BLANK LINE
1075 IF LEFT$(A$,2) = SP$+SP$ THEN 1090 ' TEST FOR INDENT
1080 IF LEFT$(A$,1) = TB$ THEN 1090 ' ALSO TEST FOR TAB
1085 PRINT #2,L$ + HBLF$;: L$ = A$: GOTO 1060 ' WRITE LINE WITH SOFT CARRIAGE RETURN
1090 PRINT #2,L$ + CRLF$;:L$ = A$: PRINT PB$;: GOTO 1060 ' WRITE LINE WITH HARD CARRIAGE RETURN
1095 '
2000 CLS
2005 PRINT"             === WORDSTAR-TO-DOS CONVERTER ==="
2010 PRINT
2015 PRINT "THIS ROUTINE CONVERTS A WORDSTAR 'DOCUMENT' FILE
2020 PRINT "  INTO STANDARD DOS FORMAT.  ALL HIGH BIT CHARACTERS
2025 PRINT "  ARE CONVERTED INTO THEIR LOW BIT EQUIVALENTS.
2030 PRINT "ALL SOFT HYPHENS ARE STRIPPED, EXCEPT THAT ANY HYPHENS
2035 PRINT "  AT THE ENDS OF LINES ARE RETAINED.
2040 PRINT
2045 PRINT "YOU CAN EITHER STRIP OR RETAIN LINES THAT CONTAIN DOT COMMANDS.
2050 PRINT "AS ANOTHER OPTION, YOU CAN EITHER STRIP ALL PRINT ENHANCEMENTS
2055 PRINT "  OR REPLACE CERTAIN ENHANCEMENT CODES AS FOLLOWS:
2060 PRINT
2065 PRINT "     UNDERLINE (^H) BECOMES << ... >>
2070 PRINT "      BOLDFACE (^B) BECOMES <<< ... >>>
2075 PRINT "   SUPERSCRIPT (^T) BECOMES <^ ... ^>
2080 PRINT "     SUBSCRIPT (^V) BECOMES <_ ... _>
2085 PRINT
2090 PRINT : INPUT "STRIP OR RETAIN DOT COMMANDS (S/R): ", Q$
2095 IF Q$ = "S" OR Q$ = "s" THEN STRIPDOT = -1 ELSE STRIPDOT = 0
2100 INPUT"STRIP OR REPLACE PRINT ENHANCEMENTS (S/R): ",Q$
2105 IF Q$ = "R" OR Q$ = "r" THEN ENHANCE = -1 ELSE ENHANCE = 0
2110 GOSUB 8000: IF FL$ = "" THEN 100
2115 PRINT :PRINT "CONVERSION IN PROGRESS.....";
2120 L$ = ""
2125 IF EOF(1) THEN 8045 ELSE A$ = INPUT$(1,#1): A = ASC(A$): IF A > 30 AND A < 128 THEN L$ = L$ + A$: GOTO 2125 ' SOFT HYPHEN OR NORMAL ASCII, PROCEED
2130 IF A > 127 THEN A = A - 128: A$ = CHR$(A) ' CONVERT TO LOW BIT CHARACTER
2135 IF A > 31 THEN L$ = L$ + A$: GOTO 2125 ' NOW IF NORMAL ASCII, PROCEED
2140 IF A = 13 THEN GOSUB 2170: A$ = INPUT$(1,#1): GOTO 2120 ' EOL, PROCESS AND REMOVE LF
2145 IF NOT ENHANCE THEN 2125
2150  ' DEAL WITH ENHANCEMENTS
2155 FOR P = 1 TO EN: IF A <> EN(P) THEN 2165 ' FIND SPECIAL CHARACTERS
2160 IF MRK(P) THEN L$ = L$ + ENC$(P): MRK(P) = 0 ELSE L$ = L$ + ENO$(P): MRK(P) = -1 ' CONVERT
2165 NEXT: GOTO 2125
2170 ' SUBROUTINE TO STRIP OFF SOFT HYPHENS AND DOT COMMANDS
2175 P = INSTR(L$,SH$): IF P = 0 OR P >= LEN(L$)-1 THEN 2180 ELSE L$ = LEFT$(L$,P-1) + RIGHT$(L$,LEN(L$)-P): GOTO 2175 ' STRIP SOFT HYPHENS
2180 IF RIGHT$(L$,1) = SH$ THEN MID$(L$,LEN(L$),1) = "-"  ' EXCEPT AT EOL
2185  '
2190 IF STRIPDOT AND (LEFT$(L$,1) = ".") THEN 2200 ' POSSIBLE DOT COMMAND
2195 PRINT  #2,L$: PRINT PB$;: RETURN ' WRITE LINE TO DISK
2200 B$ = MID$(L$,2,1): A = ASC(B$): IF A > 64 AND A < 91 THEN A = A + 32: B$ = CHR$(A)
2205 C$ = MID$(L$,3,1): A = ASC(C$): IF A > 64 AND A < 91 THEN A = A + 32: C$ = CHR$(A)
2210 DUMP = 0: FOR P = 1 TO DT: IF B$ + C$ = D$(P) THEN DUMP = -1 ' SEARCH FOR DOT COMMANDS
2215 NEXT: IF DUMP THEN RETUTN ELSE GOTO 2195 ' DUMP LINE IF DOT COMMAND
2220 '
8000 ' FILE SPECS
8005 INPUT "FILE TO CONVERT: ",FL$: IF FL$ = "" THEN RETURN
8010 IF LEFT$(FL$,1) = "?" THEN GOSUB 8035: GOTO 8005
8015 OPEN FL$ FOR INPUT AS #1
8020 INPUT "CONVERT TO FILE: ",FL$: IF FL$ = "" THEN 8005
8025 IF LEFT$(FL$,1) = "?" THEN GOSUB 8035: GOTO 8020
8030 OPEN FL$ FOR OUTPUT AS #2: RETURN
8035 IF LEN$(FL$) > 1 THEN FL$ = RIGHT$(FL$,LEN(FL$)-1) ELSE FL$ = "*.*"
8040 PRINT : FILES FL$: PRINT : RETURN
8045 CLOSE: BEEP: PRINT : PRINT "DONE!": GOTO 105
8050 '
9000 ' ERROR TRAPPING
9005 IF ERL = 8015 THEN CLOSE: BEEP: PRINT "===FILESPEC ERROR ===": RESUME 8005
9010 IF ERL = 8030 THEN CLOSE 2: BEEP: PRINT "=== FILESPEC ERROR ===": RESUME 8020
9015 IF ERL = 8040 THEN CLOSE: BEEP: PRINT "=== FILE(S) NOT FOUND ===": RESUME 8005
9020 ON ERROR GOTO 0
9025 '
10000 DATA bp,uj,po,cw,ig,cp,fo,fm,he,hm,lh,mb,mt,pa,op,pn,pc,sr,pl
10005 DATA 19,"<<",">>"
10010 DATA 2,"<<<",">>>"
10015 DATA 22,"<_","_>"
10020 DATA 20,"<^","^>"
```
{% endraw %}

{% comment %}samples_end{% endcomment %}

### Directory of PC-SIG Library Disk #0201

     Volume in drive A has no label
     Directory of A:\

    78INT    BAS       896   1-24-83   1:48a
    DISBURSE BAS     15744   3-01-83   1:06p
    DISBURSE TXT     21235   3-01-83  12:25p
    FIXWS    COM      1536  10-16-83   4:46p
    FIXWS    DOC      1536  10-16-83   4:45p
    FORMGEN  BAS     12160   6-18-82   9:20a
    FORMGEN  TXT      2432
    OUTPUTS  PRF      6528   3-01-83   9:35a
    POW      COM      3165  12-11-81
    POW      DOC     25771   1-01-80  12:10a
    UNDOWS   DOC      7040   6-04-86   3:15p
    UNDOWS   EXE     11926   6-04-86   3:24p
    WS-DOS   BAS      4739   2-01-84   1:54a
    FILES201 TXT       960   1-28-87   5:52p
    GO       BAT       699   1-28-87  12:37p
           15 file(s)     116367 bytes
                           40960 bytes free
