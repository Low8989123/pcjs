---
layout: page
title: "PC-SIG Diskette Library (Disk #335)"
permalink: /software/pcx86/sw/misc/pcsig/0001-0999/DISK0335/
machines:
  - id: ibm5160
    type: pcx86
    config: /machines/pcx86/ibm/5160/cga/256kb/machine.xml
    diskettes: /machines/pcx86/diskettes.json,/disks/pcsigdisks/pcx86/diskettes.json
    autoGen: true
    autoMount:
      B: "PC-SIG Library Disk #0335"
    autoType: $date\r$time\rB:\rDIR\r
---

{% include machine.html id="ibm5160" %}

{% comment %}info_begin{% endcomment %}

## Information about "MODS FOR PC-TALK III"

    This disk contains BBS-TALK.EXE [and various support programs].
    BBS-TALK adds functions to PC-TALK v3.0 level 830424.  BBS-TALK.MRG
    represents an effort to bring together a large number of merge files
    into one, giant merge for PC-TALK III. If you are a fan of this
    program, this disk will add even more likable features.
    
    System Requirements:  PC-TALK III
    
    How to Start:  To read the documentation on BBS-TALK, enter TYPE
    BBS-TALK.DOC <ENTER>. To run it, enter BBS-TALK <ENTER>.
    
    File Descriptions:
    
    READ     ME   Notes on this disk
    BBS-TALK BAS  BASIC version of BBS-TALK.EXE
    PCT-XMOD DOC  Notes PCTRLX.MRG
    ???      OBJ  Other object files used with BBS-TALK.EXE
    CHDIR    OBJ  Object file linked with BBS-TALK to change sub-directories
    BBS-TALK MRG  Basic [Ascii format] file when merged with PC-TALK v3.0
    BBS-TALK EXE  Executable PC-TALK including new functions
    BBS-TALK DOC  Details added functions to PC-TALK v3.0, level 83024
    DISKSPAC OBJ  Object file to link with BBS-TALK to give space remaining
    COMPILE  BAT  Batch file to automatically compile and link BBS-TALK.EXE
    SPD      COM  Put in your autoexec.bat file and run with BBS-TALK.
    GETDIR   OBJ  Object file linked witn BBS-TALK to support PATH commands
{% comment %}info_end{% endcomment %}

{% comment %}samples_begin{% endcomment %}

## BBS-TALK.BAS

{% raw %}
```bas
1 '**** Will run under Multi-Link version 2.07 *************
2 '
3 '
4 '
5 '
6 '
7 '
8 '
9 '
10 '
11 '
12 '
13 '
14 '
15 '
16 '
17 '
18 '
19 '
20 '
21 '
22 '
23 '
24 '
25 '
26 '
27 '
50 SCREEN 0,1,0:WIDTH 80:CLS:KEY OFF:LOCATE ,,0
52 '
54 '
56 '
58 '
60 '
62 '
64 '
66 '
68 '
70 '
72 '
74 '
76 '
78 '
80 '
82 '
100 '
110 CLOSE:DEFINT A-Z:OPTION BASE 1:ON ERROR GOTO 9000
111 CLS:GOSUB 65000:PRINT
115 I=0:P=0:A$="":RC=0:PR=0:LF$="":BS$="":NS=0:DIM S$(3):DIM R$(3):SET=0:PSE=0:XF$="":XN$="":HLT=0:X$="":Y$="":Z$="":B$="":C$="":J=0:M=0
116 SP=0:CLIN$=STRING$(79,32)
117 IB=0
120 FLN!=0:CNT!=0:SD=32767
125 DIM ALT$(10):DIM K$(40):DIM F2BUF$(5)
126 DPSE=0
130 FOR I=1 TO 10:KEY I,"":NEXT
135 BS$=CHR$(8):LF$=CHR$(10):CR$=CHR$(13)
140 RCV$="":TRN$="":DIAL$="":STRT$="--":GO$="===Proceed ...
145 DIM KPG$(4):KPG$(1)="Func":KPG$(2)=" Alt":KPG$(3)="Shft":KPG$(4)="Ctrl
150 DIM DS$(3):DIM DR$(3)
155 VL$=CHR$(179):EF$=CHR$(26):BL$=CHR$(7):ENT$=CHR$(17)+CHR$(196)+CHR$(217)
160 XN$=CHR$(17):XF$=CHR$(19):SOH$=CHR$(1):EOT$=CHR$(4):ACK$=CHR$(6):NAK$=CHR$(21):CAN$=CHR$(24)
165 DFIL$="pc-talk.dir":KFIL$="pc-talk.key":FFIL$="pc-talk.def":IFIL$="INITIALIII"
170 CLOSE #1:OPEN "LDAPPEND.DAT" FOR INPUT AS #1:INPUT #1,APPEND1$:INPUT #1,APPEND2$:CLOSE #1
200 '
210 DFNUM=29:DIM DP$(29):DIM D$(29):DIM DT$(29)
215 CLOSE #1:OPEN FFIL$ FOR INPUT AS #1
220 INPUT #1,Q$:IF Q$<>IFIL$ THEN 245
225 FOR I=1 TO DFNUM:INPUT #1,DP$(I),D$(I):NEXT
230 'Modified for 450 Baud by Dorn W. Stickle - Voice 214-349-6492
235 INPUT #1,Q$:IF Q$<>IFIL$ THEN 245
240 GOSUB 5600:GOTO 311
245 BEEP:PRINT"*** Re-initializing Default File ***":CLOSE #1:KILL FFIL$:GOTO 5400
250 GOTO 311
300 '
310 LOCATE 25,1:PRINT"Hit any key to continue ...";
311 I=1:LOCATE ,,0:P=0
315 EVWAIT!=1:GOSUB 40800:P=P+1:
316 BGI=BG:FGI=FG:IFLAG=0:BFLAG=0:ESC=0:C$=""
320 COLOR FG,BG,BG:CLS:LOCATE 1,39:COLOR BG,FG:PRINT SPACE$(5);"MAKE SURE THAT YOUR MODEM IS ON"SPACE$(4):COLOR FG,BG:PRINT:RESTORE 355
325 PRINT TAB(39) CHR$(213);STRING$(38,205);CHR$(184)
330 FOR I=1 TO 5:READ A$:PRINT TAB(39) VL$;A$;SPACE$(38-LEN(A$));VL$:NEXT
335 PRINT TAB(39) VL$;STRING$(38,196);VL$
340 FOR I=1 TO 5:READ A$:PRINT TAB(39) VL$;A$;SPACE$(38-LEN(A$));VL$:NEXT
341 PRINT TAB(39);VL$;STRING$(38,196);VL$
343 FOR I=1 TO 8:READ A$:PRINT TAB(39) VL$;A$;SPACE$(38-LEN(A$));VL$:NEXT
345 PRINT TAB(39) CHR$(212);STRING$(38,205);CHR$(190);
350 '
355 DATA"      =====   PC-TALK III    =====
360 DATA"        COLOR - MUSIC - WINDOWS
361 DATA"
365 DATA"       Communications Program for
370 DATA"       The IBM Personal Computer
375 DATA"          ORIGINAL VERSION BY
376 DATA"           ANDREW FLUGELMAN
377 DATA"                - - - -
378 DATA"        Additional modifications
379 DATA"            by many people.
380 DATA"
381 DATA" Press: <Home> for command summary
384 DATA"        <Alt>-A for I.B.M.
385 DATA"                3101 Operation
390 DATA"        <Alt>-E if you can't see
391 DATA"               your keyboard input
392 DATA"        <Ctr>-Home for Split
393 DATA"              Screen Operation
395 DATA"        <Alt>-P for 450 Baud change
400 '
405 CLOSE #2:OPEN KFIL$ AS #2:FIELD #2,126 AS K$,2 AS L$
410 GET#2,1:IF LEFT$(K$,LEN(IFIL$))<>IFIL$ THEN GOSUB 7425
415 FOR I=1 TO 40:GET#2,I+1:LN=CVI(L$):IF LN=0 THEN 420 ELSE K$(I)=LEFT$(K$,LN)
420 NEXT:CLOSE #2:
425 CLOSE #1:OPEN COMM$ AS #1:PRINT #1,MODMINIT$
430 ROW=1:COL=1:GOSUB 2820:LOCATE 1,1,1:PRINT GO$:PLAY "MBL32N35N38L16N32"
435 '
500 '
510 '
515 IF TR THEN IF TR$="X" THEN 4860 ELSE 4060
517 IF TMP$="" AND SP THEN XPOS=1
520 B$=INKEY$:IF B$="" THEN 560
525 IF LEN(B$)>1 THEN 1500
530 IF B$=BS$ THEN CCNT=CCNT-1:IF ECH THEN GOSUB 2655:IF PR THEN PR$=PR$+B$:GOSUB 800:GOTO 555 ELSE 555 ELSE 555
535 IF MARG<=0 THEN 550
540 IF INSTR(B$,CR$)<>0 THEN CCNT=0:GOTO 550
545 CCNT=CCNT+LEN(B$):IF CCNT>=MARG AND CCNT<MARG+10 THEN BEEP
550 IF ECH THEN PRINT B$;:IF PR THEN PR$=PR$+B$:GOSUB 800
555 IF SP THEN 11010
558 PRINT #1,B$;
560 IF EOF(1) THEN 515 ELSE 605
600 '
605 IF LOF(1)<128 THEN GOTO 606 ELSE GOTO 610
606 PSE=-1:PRINT #1,XF$;
610 IF EOF(1) THEN 710
612 IF SP THEN LOCATE ROW,COL,0
615 A$=INPUT$(LOC(1),#1):IF NS=0 THEN 635
620 FOR I=1 TO NS
625 P=INSTR(A$,S$(I)):IF P=0 THEN 628 ELSE A$=LEFT$(A$,P-1)+R$(I)+                  RIGHT$(A$,LEN(A$)-P):GOTO 625
628 P=INSTR(A$,CHR$(0)):IF P=0 THEN 630 ELSE A$=LEFT$(A$,P-1)+                      RIGHT$(A$,LEN(A$)-P):GOTO 625
630 NEXT
635 IF RC THEN PRINT #2,A$;
636 IF IB THEN 13030
637 X = LEN(A$):P=INSTR(A$,LF$):IF P=0 THEN 638 ELSE A$=LEFT$(A$,P-1)+RIGHT$(A$,X-P):GOTO 637
638 FOR I = 1 TO X:Z$=MID$(A$,I,1)
639 IF (Z$=CHR$(127)) THEN 655
640 IF ASC(Z$) = 27 THEN ESC=1
641 IF Z$=BS$ THEN GOSUB 2650:GOTO 655
645 IF ESC=1 THEN C$=C$+Z$ ELSE GOTO 650
646 IF LEN(C$)>1 THEN FF = INSTR("fmJ"+CHR$(14)+CHR$(93)+CHR$(124)+CHR$(91)+CHR$(27),Z$) ELSE 655
647 IF FF=0 THEN GOTO 655 ELSE GOSUB 12000:ESC=0:C$="":GOTO 655
650 PRINT Z$;
655 NEXT I
660 IF SP THEN ROW=CSRLIN:COL=POS(0):LOCATE 25,XPOS,1
661 IF PR THEN PR$=PR$+A$:GOSUB 800
700 '
705 IF SET THEN 715
710 B$=INKEY$:IF B$<>"" THEN 525
715 IF LOC(1)>0 THEN 605
720 IF PSE THEN PSE=0:PRINT #1,XN$;
725 IF SET THEN ROW=CSRLIN:COL=POS(0):GOTO 1000
730 GOTO 515
800 '
805 P=INSTR(PR$,BS$):IF P=0 THEN 810 ELSE IF LEN(PR$)>1 THEN PR$=LEFT$(PR$,P-2)+RIGHT$(PR$,LEN(PR$)-P):GOTO 805
810 P=INSTR(PR$,CR$):IF P=0 THEN 815 ELSE PRINT #3,LEFT$(PR$,P);:PR$=RIGHT$(PR$,LEN(PR$)-P):GOTO 810
815 IF LEN(PR$)>220 THEN PRINT #3,PR$;:PR$="":RETURN
820 RETURN
825 '
1000 '
1010 IF ALTSET THEN LOCATE 25,17 ELSE LOCATE 25,15+LEN(ALT$)
1015 C$=INKEY$:IF C$="" THEN IF EOF(1) THEN 1015 ELSE SET=-1:LOCATE ROW,COL:GOTO 605
1020 IF NOT ALTSET THEN 1035
1025 LOCATE 25,19:IF ASC(C$)>=49 AND ASC(C$)<=57 THEN ALTKY=ASC(C$)-48ELSE IF ASC(C$)=48 THEN ALTKY=10 ELSE BEEP:GOTO 1010
1030 IF ALTSET THEN ALTSET=0:SET=-1:LOCATE 25,1:PRINT STRING$(5,16);" Alt-";ALTKY;CHR$(198);"    ";CHR$(181);:GOTO 1010
1035 IF LEN(ALT$)>=51 THEN ALT$=LEFT$(ALT$,49):LOCATE 25,64:PRINT" ";CHR$(181);:LOCATE 25,66:BEEP:PRINT"(max 50 chrs.)";:GOTO 1010
1040 IF C$=BS$ THEN IF ALT$="" GOTO 1010 ELSE GOSUB 2650:ALT$=LEFT$(ALT$,LEN(ALT$)-1):GOTO 1010
1045 IF C$=CHR$(13) THEN 1070
1050 IF C$>CHR$(31) THEN PRINT C$; ELSE COLOR HI,BG:PRINT CHR$(ASC(C$)+64);:COLOR FG,BG
1055 PRINT"    ";CHR$(181);
1060 IF C$=XCR$ THEN C$=CHR$(13)
1065 ALT$=ALT$+C$:GOTO 1010
1070 IF ALT$<>"" THEN IF ALT$=" " THEN ALT$(ALTKY)="" ELSE ALT$(ALTKY)=ALT$
1075 ALT$="":SET=0:GOTO 1200
1080 '
1200 '
1210 P=1:FOR I=1 TO 10:LOCATE 25,P:IF I=10 THEN PRINT"0";:COLOR BG,FG:GOTO 1220
1215 PRINT USING "#";I;:COLOR BG,FG
1220 FOR J=1 TO 7:Z$=MID$(ALT$(I),J,1):IF POS(0)=80 THEN 1235
1225 IF J>LEN(ALT$(I)) THEN PRINT" ";:GOTO 1235
1230 IF Z$>=" "THEN PRINT Z$; ELSE IF Z$=CR$ THEN PRINT XCR$; ELSE COLOR HI,FG:PRINT CHR$(ASC(Z$)+64);:COLOR BG,FG
1235 NEXT J:COLOR FG,BG:P=P+8:NEXT I
1240 FOR I=1 TO 10:IF ALT$(I)<>"" THEN EXIT=-1
1245 NEXT:IF EXIT THEN EXIT=0:LOCATE ROW,COL:GOTO 605
1250 LOCATE ROW,COL:GOSUB 2820:GOTO 515
1255 '
1500 '
1510 EX=0:ROW=CSRLIN:COL=POS(0)
1515 IF LEN(B$)=2 THEN EX=ASC(MID$(B$,2,1)) ELSE EX=0
1517 IF IB AND EX=72 THEN B$=CHR$(30):GOTO 535
1518 IF IB AND EX=71 THEN B$=CHR$(11):GOTO 535
1519 IF IB AND EX=80 THEN B$=CHR$(31):GOTO 535
1520 IF EX=35 THEN 1850
1525 IF EX=75 THEN B$=CHR$(29):GOTO 535
1526 IF EX=77 THEN B$=CHR$(28):GOTO 535
1530 IF EX=71 THEN 2000
1535 IF EX=19 OR EX=81 THEN EX=19:GOTO 3000
1540 IF EX=47 THEN 3400
1545 IF EX=20 OR EX=73 THEN EX=20:GOTO 3200
1550 IF EX=25 THEN 5000
1555 IF EX=32 THEN 6000
1560 IF EX=36 OR EX=37 THEN 7000
1565 '
1570 IF EX>=59 AND EX<=68 THEN B$=K$(EX-58):GOTO 535
1575 IF EX>=104 AND EX<=113 THEN B$=K$(EX-93):GOTO 535
1580 IF EX>=84 AND EX<=103 THEN B$=K$(EX-63):GOTO 535
1585 IF EX>=120 AND EX<=129 THEN B$=ALT$(EX-119):GOTO 535
1590 IF EX=15 THEN:BEEP:LOCATE 25,1:PRINT"  set Alt-(1-0):  ";CHR$(181);:ALTSET=     -1:GOTO 1000
1595 '
1600 IF EX=18 THEN BEEP:PRINT:IF ECH=0 THEN ECH=-1:PRINT"===ECHO ON===":GOTO 515 ELSE ECH=0:PRINT"===ECHO OFF===":GOTO 515
1605 IF EX=50 THEN BEEP:PRINT:IF MSG=0 THEN MSG=-1:PRINT"===MESSAGES ON===":GOTO 515 ELSE MSG=0:PRINT"===MESSAGES OFF===":GOTO 515
1610 IF EX=114 OR EX=132 THEN BEEP:PRINT:IF PR=0 THEN PR=-1:PRINT"===PRINTOUT ON===":CLOSE #3:OPEN PRNTPORT$ AS #3:PRINT #3,PRNTINIT$;:GOTO 515 ELSE PR=0:CLOSE #3:PRINT"===PRINTOUT OFF===":GOSUB 2715:GOTO 515
1615 '
1620 IF EX=44 THEN 8200
1625 IF EX=16 THEN IF DIAL$<>"" THEN 8000 ELSE BEEP:PRINT"(nothing to redial)":PRINT GO$:GOTO 515
1630 IF EX=31 THEN 3800
1635 IF EX=33 THEN 5200
1640 IF EX=45 THEN BEEP:CLS:PRINT"===EXIT TO DOS===":PRINT:PRINT"WARNING!  If you proceed you will terminate the program.":PRINT"Do you want to do this (y/n)?";:Q$=INPUT$(1):GOSUB 2555:IF Q$<>"Y" THEN PRINT :PRINT GO$:GOTO 515 ELSE 8915
1645 '
1650 IF EX=38 THEN BEEP:PRINT:PRINT"===SPECIFY LOGGED DRIVE===":PRINT"Current default for file specs: ";DRIV$:PRINT"New default: ";:QL=2:GOSUB 2500:IF Q$="" THEN PRINT:PRINT GO$:GOTO 515 ELSE DRIV$=LEFT$(Q$,1)+":":PRINT:PRINT GO$:GOTO 515
1655 IF EX=21 THEN 3900
1660 IF EX=46 THEN PRINT CHR$(12):GOSUB 2800:GOTO 515
1665 IF EX=17 THEN BEEP:PRINT"===SPECIFY WIDTH ALARM===":PRINT"Current setting for right margin:";MARG:PRINT"New setting: ";:QL=3:GOSUB 2500:IF Q$="" THEN PRINT:PRINT GO$:GOTO 515 ELSE MARG=VAL(Q$):PRINT:PRINT GO$:GOTO 515
1670 IF EX=117 THEN OLDVAL=INP(LCR):BRKVAL=OLDVAL OR 64:OUT LCR,BRKVAL:EVWAIT!=3:GOSUB 40800:EVWAIT!=1:GOSUB 40800:OUT LCR,OLDVAL:GOTO 515
1675 IF EX=15 THEN RESTORE 9999:READ Q$:PRINT Q$:GOTO 515
1680 '
1682 IF EX=119 THEN 10000
1684 IF EX=30 THEN 13000
1685 '
1690 '
1692 IF EX=34 THEN GOTO 11100
1693 IF EX=23 THEN GOTO 11130
1694 IF EX=22 THEN GOTO 11160
1696 IF EX=24 THEN GOTO 515
1699 GOTO 515
1850 IF NOT EOF(1) THEN Q$=INPUT$(LOC(1),#1):Q$="" ELSE Q$=""
1855 PLAY "MFL32N46L16N36":EVWAIT!=1:GOSUB 40800:PRINT #1,"+++";:EVWAIT!=30:GOSUB 40800:EVWAIT!=1:GOSUB 40800
1860 IF LOC(1)>0 THEN Q$=INPUT$(LOC(1),1) ELSE GOTO 1890
1865 IF INSTR(Q$,"OK")<>0 THEN Q$="":GOTO 1870 ELSE GOTO 1890
1870 PRINT #1,"ATH0":PLAY "MFL32N42L16N32":EVWAIT!=1:GOSUB 40800:Q1=0
1875 IF LOC(1)>0 THEN Q$=INPUT$(LOC(1),1)
1880 IF INSTR(Q$,"OK")<>0 OR INSTR(Q$,"NO CARRIER")<>0 THEN Q$="":GOTO 1895 ELSE GOSUB 1881
1881 IF Q1=1 THEN PRINT "Failed on the first try . . . Hold on...........I AM retrying . . .":RETURN
1882 IF Q1=2 THEN PRINT "Failed on the second try . . . . WAIT ONE . . . Let's try it again!":RETURN
1883 IF Q1=3 THEN PRINT "Failed on the third try . . . . . . . . Let's try it one more time!":RETURN
1885 Q1=Q1+1:IF Q1<4 AND INSTR(Q$,"NO CARRIER")=0 GOTO 1870
1890 Q1=Q1+1: IF INSTR(Q$,"NO CARRIER")<>0 GOTO 1895 ELSE IF Q1<4 THEN GOSUB 1881:GOTO 1850 ELSE GOSUB 1900:GOTO 1895
1895 Q1=0:CLOSE #1:OPEN COMM$ AS #1:PLAY "MFL64N36":EVWAIT!=1:GOSUB 40800:PLAY "MFL64N36":PRINT:PRINT GO$:GOTO 515
1900 COLOR HI,BG:PRINT "I haven't received HANGUP VERIFICATION after 4 tries":       COLOR FG,BG:PRINT"Check Modem CD lite.  If lit, try ALT-H again."
1910 CLOSE #1:OPEN COMM$ AS #1:PLAY "MFL64N36":EVWAIT!=1:GOSUB 40800:PLAY "MFL64N36":RETURN
2000 '
2010 LOCATE 1,39:PRINT CHR$(213)+STRING$(38,205)+CHR$(184)
2015 LOCATE 2,39:PRINT VL$;"  ===PC-TALK III  COMMAND SUMMARY===  ";VL$
2020 LOCATE 3,39:PRINT CHR$(195)+STRING$(38,196)+CHR$(180)
2025 RESTORE 2050:LOCATE 4,39:READ B$:PRINT VL$;" ";CAN$;B$;SPACE$(36-LEN(B$));VL$
2030 FOR I=5 TO 23:LOCATE I,39:READ B$:PRINT VL$;B$;SPACE$(38-LEN(B$));VL$:NEXT
2035 LOCATE 24,39:PRINT CHR$(212)+STRING$(38,205)+CHR$(190);
2040 LOCATE ROW,COL:GOTO 515
2045 '
2050 DATA" PrtSc Print Screen Contents
2055 DATA" ^PrtSc Continuous Printout (^PgUp)
2060 DATA" XMODEM '=x'  Pacing '=p'  Binary '=b'
2065 DATA" Shft-TAB  Set/Clear Temp Alt Keys
2070 DATA" Alt-A  3101 Terminal Emulation
2075 DATA" Alt-C  Clearscreen   Alt-D  Dial Nmbr
2080 DATA" Alt-E  Echo Toggle   Alt-F  Defaults
2085 DATA" Alt-G  New Sub Dir   Alt-H  Hang up
2090 DATA" Alt-I  Set Alt-1/0 from file
2095 DATA" Alt-K  Set/Clear Func Keys (Alt-J)
2100 DATA" Alt-L  Change Default Drive
2105 DATA" Alt-M  Messages     Alt-P  Com Parms
2110 DATA" Alt-Q  Redial Nmbr  Alt-R  Recv File
2115 DATA" Alt-S  Screendump   Alt-T  Xmit File
2120 DATA" Alt-U  Unload Alt-1/0 to file
2125 DATA" Alt-V  View File    Alt-W  Mrgn Alarm
2130 DATA" Alt-X  eXit to DOS
2135 DATA" Alt-Y  Delete a File    Alt-Z  Time
2140 DATA" ? @ Alt-T -R -V shows Free Disk Space
2145 DATA"Ctrl-End = Send Sustained Break Signal
2150 '
2500 '
2505 Q$="":IF QL=0 THEN QL=255
2510 QI$=INKEY$:IF QI$="" THEN 2510
2515 IF QI$=CHR$(13) THEN RETURN
2520 IF QI$<>CHR$(8) THEN 2530 ELSE IF Q$="" THEN BEEP:GOTO 2510
2525 IF QI$=CHR$(8) THEN GOSUB 2650:Q$=LEFT$(Q$,LEN(Q$)-1):GOTO 2510
2530 IF LEN(Q$)=QL THEN BEEP:GOTO 2510
2535 IF LEN(QI$)=1 THEN 2545 ELSE IF QI$<>CHR$(0)+CHR$(3) THEN BEEP:GOTO 2510 ELSE QI$=CHR$(0)
2545 IF ASC(QI$)>31 OR QI$=CHR$(27) THEN PRINT QI$; ELSE COLOR HI,BG:PRINT CHR$(ASC(QI$)+64);:COLOR FG,BG
2550 IF QI$=XCR$ THEN Q$=Q$+CHR$(13):GOTO 2510 ELSE Q$=Q$+QI$:GOTO 2510
2555 '
2560 FOR J=1 TO LEN(Q$):P=ASC(MID$(Q$,J,1)):IF P<97 OR P>122 THEN 2570
2565 MID$(Q$,J,1)=CHR$(P AND 95)
2570 NEXT:RETURN
2600 '
2605 MSG$=LEFT$(MSG$,77):ROW=CSRLIN:COL=POS(0):LOCATE 25,1:COLOR 31,BG:PRINT         CHR$(16);:COLOR BG,FG:PRINT MSG$+SPACE$(77-LEN(MSG$));:COLOR 31,BG:PRINT        CHR$(17);:COLOR FG,BG:LOCATE ROW,COL:RETURN
2650 '
2655 PRINT CHR$(29);" ";CHR$(29);:RETURN
2700 '
2705 CLOSE #2:IF RC THEN OPEN RCV$ FOR APPEND AS #2
2710 RETURN
2715 CLOSE #3:IF PR THEN OPEN PRNTPORT$ FOR OUTPUT AS #3
2720 IF TR THEN OPEN TRN$ AS #3 LEN=128:FIELD #3,128 AS X$
2725 RETURN
2800 '
2805 ROW=CSRLIN:COL=POS(0)
2810 EXIT=0:FOR I=1 TO 10:IF ALT$(I)<>"" THEN EXIT=-1:NEXT
2815 IF EXIT THEN EXIT=0:LOCATE ,,1:GOTO 1210
2820 IF MENU=0 THEN 2830
2825 LOCATE 25,1:PRINT" ";:COLOR BG,FG:PRINT"^PrtSc=prnt  Alt- T=tran R=recv V=view D=dial E=echo M=mesg X=exit <Home>=Help";:COLOR FG,BG:LOCATE ROW,COL:RETURN
2830 LOCATE 25,1:PRINT SPACE$(79);:LOCATE ROW,COL:RETURN
2835 '
3000 '
3010 IF RC THEN RC=0:RC$="":BEEP:PRINT:PRINT"===RECEIPT OF FILE ";RCV$;              " TERMINATED===":GOSUB 3247:PRINT:GOSUB 2700:GOSUB 2800:IF MSG THEN             PRINT #1,BL$;CR$;"===FILE RECEIVED===":GOTO 515 ELSE 515
3015 BEEP:FIL$=DRIV$:GOSUB 3641:PRINT :PRINT
3016 RC$="":PRINT"===RECEIVE A FILE===":GOTO 3500
3020 IF RC$="X" THEN CLOSE #2:KILL RCV$:OPEN RCV$ AS #2 LEN=128:FIELD #2,128 AS X$:GOTO 3030
3025 IF MSG THEN PRINT #1,BL$;CR$;"===READY TO RECEIVE===
3030 MSG$=" Receiving "+RCVX$+"  (ALT-R or PgDn to Terminate)":GOSUB 2600
3035 RC=-1:IF RC$="X" THEN 4500 ELSE 605
3040 '
3200 '
3210 IF TR THEN TR=0:TR$="":MSG1$="===TRANSMISSION OF FILE ":MSG2$=                  " TERMINATED===":GOSUB 3247:BEEP:PRINT:PRINT MSG1$;TRN$;MSG2$:GOSUB 2715:       GOSUB 2800:IF MSG THEN PRINT #1,CR$;MSG1$;MSG2$,BL$:GOTO 515 ELSE 515
3215 IF TR THEN TR=0:TR$="":MSG1$="===END OF FILE":MSG2$="===":BEEP:PRINT:           GOSUB 3247:PRINT MSG1$;" ";TRN$;MSG2$:GOSUB 2715:GOSUB 2800:IF MSG THEN         PRINT #1,"65529 '";MSG1$;MSG2$;BL$:GOTO 515 ELSE 515
3220 TR$="":BEEP:PRINT :PRINT :PRINT:PRINT"===TRANSMIT A FILE===":GOTO 3500
3225 CLOSE #3:OPEN TRN$ AS #3 LEN=128:FIELD #3,128 AS X$
3230 MSG$=" Transmitting "+TRNX$+" (ALT-T to terminate)":IF TR$="X" THEN MSG$=MSG$+"  # of blocks:" ELSE IF TR$="P" THEN MSG$=MSG$+"  percent remain:" ELSE MSG$=MSG$+"   min. remain:"
3235 GOSUB 2600:IF TR$="X" THEN ROW=CSRLIN:COL=POS(0):LOCATE 25,74:CNT!=FIX(LOF(3)/128):FLN!=LOF(3)/128:IF CNT!=FLN! THEN PRINT CNT!;:LOCATE ROW,COL ELSE PRINT CNT!+1;:LOCATE ROW,COL:GOTO 3245
3240 IF MSG THEN PRINT #1,CR$;"0 '===START OF FILE===";BL$
3245 TR=-1:FLN!=LOF(3):IF TR$<>"X" THEN 4000 ELSE 4700
3247 '
3248 GOSUB 40000:RETURN
3250 '
3400 '
3410 BEEP:PRINT :PRINT :PRINT "`     ?'  and Disk identifier shows Free Disk Space  (example: ?A: or ?E:)"
3411 PRINT"===VIEW A FILE===":GOTO 3500
3415 MSG$=" Viewing "+VEWX$+"  Hit <space> to continue  (Alt-V to terminate)":GOSUB 2600:PRINT:PRINT:PRINT
3420 WHILE NOT EOF(3):FOR I=1 TO 20:LINE INPUT #3,X$:J=LEN(X$):IF J<80 THEN PRINT X$ ELSE PRINT X$;:IF J>80 THEN I=I+FIX(J/80)
3425 NEXT
3430 Q$=INKEY$:IF Q$="" THEN 3430 ELSE IF Q$=" " THEN 3420 ELSE IF Q$=CHR$(0)+CHR$(47) THEN 3445 ELSE BEEP:GOTO 3430
3435 WEND
3440 BEEP:PRINT:PRINT"===END OF FILE ";VEW$;" ===":GOTO 3450
3445 BEEP:PRINT:PRINT"===VIEWING OF FILE ";VEW$;" TERMINATED===
3450 GOSUB 2715:GOSUB 2800:GOTO 515
3455 '
3500 '
3510 EXIT=0:PRINT"   specification:";
3515 Q$=INKEY$:IF Q$="" THEN 3515 ELSE IF Q$=CR$ OR Q$=BS$ THEN FIL$="":PRINT:GOTO 3540
3520 IF LEN(Q$)>1 THEN Q=ASC(MID$(Q$,2,1)):IF Q>=59 AND Q<=68 THEN Q$=K$(Q-58) ELSE IF Q>=104 AND Q<=113 THEN Q$=K$(Q-93) ELSE IF Q>=84 AND Q<=103 THEN Q$=K$(Q-63) ELSE BEEP:GOTO 3515
3525 IF Q$<>" " THEN PRINT Q$;:QL=128:GOSUB 2510:GOSUB 2555:FIL$=Q$:PRINT:LOCATE,,1:GOTO 3540
3530 IF EX=19 THEN FIL$=RCVX$ ELSE IF EX=20 THEN FIL$=TRNX$ ELSE IF EX=47 THEN FIL$=VEWX$
3535 Q$=FIL$:PRINT Q$;:QL=128:GOSUB 2510:GOSUB 2555:FIL$=Q$:PRINT:LOCATE,,1
3540 IF FIL$="" THEN BEEP:PRINT"===CANCELLED===":GOTO 515
3545 IF LEFT$(FIL$,1)="?" THEN GOSUB 3625:GOTO 3510
3550 P=INSTR(FIL$,":"):IF P=0 THEN FIL$=DRIV$+FIL$
3555 IF EX=19 THEN RCVX$=FIL$ ELSE IF EX=20 THEN TRNX$=FIL$ ELSE IF EX=47 THEN VEWX$=FIL$
3560 P=INSTR(FIL$,"="):IF P=0 THEN IF EX<>20 OR PC$="" OR EXIT=-1 THEN 3595 ELSE EXIT=-1:Q$=FIL$+PC$:LOCATE CSRLIN-1,18:BEEP:GOTO 3525
3565 Q$=RIGHT$(FIL$,LEN(FIL$)-P):FIL$=LEFT$(FIL$,P-1)
3570 IF Q$="B" THEN TR$="B" 
3575 IF Q$="X" THEN IF EX=19 THEN RC$="X" ELSE IF EX=20 THEN TR$="X
3580 IF LEFT$(Q$,1)="P" THEN TR$="P":PROMPT$=RIGHT$(Q$,LEN(Q$)-1):DEL!=VAL(PROMPT$)
3585 IF TR$="B" OR TR$="X" OR RC$="X" THEN IF DTA$<>"8" THEN BEEP:PRINT"*** Automatically converting to 8 DATA BITS for binary or XMODEM ***"
3590 IF TR$="X" OR RC$="X" THEN IF NS<>0 THEN BEEP:PRINT"*** Stripping disabled for XMODEM ***":NS=0
3595 IF EX=19 THEN CLOSE #2:OPEN FIL$ FOR APPEND AS #2 ELSE CLOSE #3:OPEN FIL$ FOR INPUT AS #3
3600 PRINT STRING$(18+LEN(FIL$),61):IF EX=19 THEN RCV$=FIL$:GOTO 3020
3605 IF EX=20 THEN TRN$=FIL$:GOTO 3225
3610 IF EX=47 THEN VEW$=FIL$:GOTO 3415
3615 IF EX=21 THEN 3915
3620 '
3625 IF LEN(FIL$)=1 THEN FIL$=DRIV$+"*.*":GOTO 3640 ELSE FIL$=RIGHT$(FIL$,LEN(FIL$)-1):IF LEFT$(FIL$,1)=" " THEN FIL$=RIGHT$(FIL$,LEN(FIL$)-1)
3630 P=INSTR(FIL$,":"):IF P=0 THEN FIL$=DRIV$+FIL$
3635 IF LEN(FIL$)=P THEN FIL$=FIL$+"*.*
3640 PRINT:FILES FIL$:PRINT
3641 AVAIL!=0:DR=0:BYTES!=0
3642 IF LEFT$(FIL$,2)="A:" OR LEFT$(FIL$,2)="a:" THEN DR=1 ELSE IF LEFT$(FIL$,2)="B:" OR LEFT$(FIL$,2)="b:" THEN DR=2 ELSE IF LEFT$(FIL$,2)="C:" OR LEFT$(FIL$,2)="c:" THEN DR=3
3643 IF LEFT$(FIL$,2)="D:" OR LEFT$(FIL$,2)="d:" THEN DR=4 ELSE IF LEFT$(FIL$,2)="e:" OR LEFT$(FIL$,2)="E:" THEN DR=5 ELSE IF LEFT$(FIL$,2)="f:" OR LEFT$(FIL$,2)="F:" THEN DR=6
3644 TOTAL.BYTES!=AVAIL!*BYTES!*SECTORS!
3645 NAME DRV$+"1" AS DRV$+"1"
3646 CALL DISKSPAC(DR,AVAIL):TOTAL.BYTES!=(BYTES!+AVAIL)*512
3647 AVAIL!=AVAIL:DR!=DR:BYTES!=BYTES
3648 ACUM$=STR$(TOTAL.BYTES!)+" Bytes of free disk space"
3649 PRINT "Space available on the disk is"+ACUM$
3650 RETURN
3800 '
3810 PLAY "MBL32N33":CLOSE #2:OPEN DUMP$ FOR APPEND AS #2:MSG$=" Appending to "+DUMP$+" at "+TIME$:GOSUB 2600
3815 FOR I=1 TO 24:Y$="":FOR J=1 TO 79:X=SCREEN(I,J):Y$=Y$+CHR$(X):NEXT J:PRINT #2,Y$:NEXT I:PRINT #2,STRING$(79,45);CR$;LF$;"===PC-TALK SCREENDUMP - ";DATE$;" at ";TIME$;"===";CR$;LF$;STRING$(79,61):CLOSE #2
3820 SOUND 660,2:BEEP:GOSUB 2705:GOSUB 2800:LOCATE ROW,COL:GOTO 515
3825 '
3900 '
3910 BEEP:PRINT:PRINT"===DELETE A FILE===":GOTO 3500
3915 PRINT"***The first 5 lines are:":FOR I=1 TO 5:IF NOT EOF(3) THEN LINE INPUT #3,X$:PRINT X$
3920 NEXT:PRINT"***ARE YOU SURE (y/n)?";:Q$=INPUT$(1):PRINT Q$:GOSUB 2555:IF Q$="Y" THEN CLOSE #3:KILL FIL$:BEEP:PRINT" (deleted)":GOTO 3930
3925 PRINT" (not deleted)":PRINT GO$:GOTO 515
3930 PRINT GO$:GOTO 515
3935 '
4000 '
4010 IF TR$="B" THEN PRINT"(sending file as binary...)
4015 RATE!=VAL(BAU$)*6:CNT!=0:ROW=CSRLIN:COL=POS(0):GOTO 4060
4020 LOCATE 25,74:IF TR$<>"P" THEN PRINT USING"###.#";(FLN!-(CNT!*128))/RATE!; ELSE PRINT USING".##";(FLN!-CNT!*128)/FLN!;
4025 GET#3,CNT!:Y$=X$:LOCATE ROW,COL
4030 IF TR$="P" THEN GOSUB 4400:IF NOT ABORT THEN 4050 ELSE ABORT=0:GOTO 1500
4035 PRINT #1,Y$;:IF TR$="B" THEN 4050
4040 P=INSTR(1,Y$,LF$):IF P=0 THEN 4045 ELSE Y$=LEFT$(Y$,P-1)+RIGHT$(Y$,LEN(Y$)-P):GOTO 4040
4045 FOR I=1 TO 128:PRINT MID$(Y$,I,1);:NEXT
4050 ROW=CSRLIN:COL=POS(0):GOSUB 4070:B$=INKEY$:IF B$="" THEN 4060
4055 IF LEN(B$)>1 THEN 1500
4060 CNT!=CNT!+1:IF CNT!*128<FLN! THEN 4020 ELSE GET#3,CNT!:Y$=X$:GOTO 4200
4065 '
4070 IF EOF(1) THEN 4085 ELSE A$=INPUT$(LOC(1),#1)
4075 P=INSTR(1,A$,XF$):IF P<>0 THEN HLT=-1:COLOR HI,BG:PRINT"<<XOFF>>";:COLOR FG,BG
4080 IF HLT THEN P=INSTR(1,A$,XN$):IF P=0 THEN 4085 ELSE HLT=0:RETURN
4085 IF HLT THEN Q$=INKEY$:IF Q$<>"" THEN IF LEN(Q$)<>2 THEN 4070 ELSE IF ASC(RIGHT$(Q$,1))=24 THEN HLT=0:RETURN ELSE 4070 ELSE 4070
4090 RETURN
4200 '
4205 I=0:CNT!=(CNT!-1)*128
4210 I=I+1:CNT!=CNT!+1
4211 IF I>255 THEN 4230 ELSE Z$=MID$(Y$,I,1)
4215 IF TR$="B" THEN IF CNT!<=FLN! THEN 4235 ELSE 4230
4220 IF Z$<>EF$ THEN 4235 ELSE 4230
4225 IF CNT!<=FLN! THEN 4235
4230 IF EOF(1) THEN 3215 ELSE DMMY$=INPUT$(LOC(1),#1):GOTO 4230
4235 IF TR$="P" THEN IF Z$=LF$ THEN 4210
4240 PRINT #1,Z$;:IF TR$="P" THEN IF Z$=CR$ THEN PRINT Z$;:GOSUB 4425:GOTO 4210
4245 IF TR$="B" OR Z$=LF$ THEN 4210
4250 PRINT Z$;:GOTO 4210
4400 '
4405 FOR I=1 TO LEN(Y$):Z$=MID$(Y$,I,1):IF Z$=LF$ THEN 4415 ELSE IF Z$<>CR$ THEN PRINT #1,Z$;:PRINT Z$;:GOTO 4415 ELSE PRINT #1," "+CR$;:PRINT CR$;:B$="":GOSUB 4420
4410 IF ABORT THEN RETURN
4415 NEXT:RETURN
4420 IF LEN(B$)>1 THEN ABORT=-1:RETURN
4425 IF (INP(LSR) AND 96)<>96 THEN 4425
4430 IF DEL!>0 THEN EVWAIT!=18*DEL!:GOSUB 40800:EVWAIT!=1:GOSUB 40800:RETURN
4435 Z$="":WHILE NOT EOF(1):Z$=Z$+INPUT$(LOC(1),#1):WEND:PRINT Z$;:IF Z$="" THEN Z$=CHR$(0) ELSE IF LEN(Z$)>128 THEN Z$=""
4440 P=INSTR(Z$,PROMPT$):B$=INKEY$:IF P<>0 OR B$=" " THEN RETURN ELSE 4420
4445 '
4500 '
4510 PRINT"===RECEIVE FILE WITH XMODEM===":PRINT
4512 '
4513 OPAR$=PAR$:ODTA$=DTA$:PAR$="N":DTA$="8":GOSUB 40000:PAR$=OPAR$:DTA$=ODA$
4515 Y$="":BLK=1:SEC=1:CK=0:ECNT=0:DEDD=0:DEDD=0
4520 PRINT"***Holding for Start...":GOSUB 4975:PRINT #1,NAK$;
4525 GOSUB 4925:IF ABORT THEN 4645 ELSE 4535
4530 GOSUB 4905:IF Z$="" THEN 4545
4535 Y$=Y$+Z$:IF LEN(Y$)<=131 THEN 4530
4540 '
4545 IF LEN(Y$)=132 THEN LSET X$=MID$(Y$,4,128):N=132:GOTO 4580
4550 IF LEN(Y$)=131 THEN LSET X$=MID$(Y$,3,128):N=131:GOTO 4580
4555 IF LEN(Y$)>132 THEN PRINT"**Long  Block in #";BLK:GOTO 4615
4560 IF Y$=EOT$ THEN 4635
4565 IF Y$=CAN$ THEN 4640
4570 IF Y$="" THEN PRINT"***Timeout":GOSUB 4975:PRINT #1,NAK$:GOTO 4525
4575 PRINT"**Short Block in #";BLK:GOTO 4615
4580 IF (ASC(MID$(Y$,1,1)) AND ASC(MID$(Y$,2,1)) AND ASC(MID$(Y$,3,1)))<>0 THEN PRINT"**Error in SOH":Y$="":PRINT #1,NAK$:GOTO 4525
4585 IF ASC(MID$(Y$,2,1))=SEC-1 THEN PRINT"**Requesting Next Block":PRINT #1,ACK$:GOTO 4520
4590 IF SEC<>ASC(MID$(Y$,2,1)) THEN PRINT"**Block # Error in #";BLK:GOTO 4615
4595 IF (SEC XOR 255)<>ASC(MID$(Y$,3,1)) THEN PRINT"**Complement Error in #";BLK:GOTO 4615
4600 FOR I=1 TO 128:CK=CK+ASC(MID$(X$,I,1)):NEXT
4605 IF (CK AND 255)=(ASC(MID$(Y$,N,1))) THEN 4620
4610 PRINT"**Checksum Error in #";BLK:
4615 PRINT #1,NAK$;:ECNT=ECNT+1:IF ECNT<10 THEN 4625 ELSE IF DEDD<3 THEN EVWAIT!=10:GOSUB 40800:EVWAIT!=1:GOSUB 40800:GOTO 4625 ELSE 4645
4620 PRINT"Received Block #";BLK;:SEC=255 AND (SEC+1):PUT#2,BLK:BLK=BLK+1:PRINT #1,ACK$;:PRINT"- verified":ECNT=0:DEDD=0
4625 Y$="":CK=0:GOSUB 4965:IF ABORT THEN 4645 ELSE 4530
4630 '
4635 PRINT "*** End of File - verified":PRINT #1,ACK$;:GOSUB 40000:GOTO 3010
4640 PRINT "*** Cancelled by Transmitter":GOSUB 40000:GOTO 3010
4645 PRINT "*** Cancelled by Receiver ":PRINT #1,CAN$;:GOSUB 4975:GOSUB 40000:GOTO 3010
4650 '
4700 '
4710 PRINT"===TRANSMIT FILE WITH XMODEM===":PRINT
4712 '
4713 OPAR$=PAR$:ODTA$=DTA$:PAR$="N":DTA$="8":GOSUB 40000:PAR$=OPAR$:DTA$=ODTA$
4715 SEC=0:BLK=0:CNT!=0:ECNT=0:DEDD=0:EOT=0:ETT=0:GOSUB 4815
4720 PRINT"***Holding for Start...":GOSUB 4975:ABORT=0:SECZ=0:GOSUB 4985
4725 WHILE NOT EOF(1):Z$=INPUT$(1,#1)
4730 IF Z$=NAK$ THEN 4800
4735 IF Z$=CAN$ THEN 4855
4740 WEND:GOSUB 4965:IF ABORT THEN 4860
4745 GOSUB 4990:IF NOT TENSEC THEN 4725 ELSE GOSUB 4995:GOTO 4725
4750 '
4755 ABORT=0:SECZ=0:GOSUB 4985
4760 WHILE NOT EOF(1)
4761 Z$=INPUT$(LOC(1),#1)
4765 IF Z$=ACK$ THEN ECNT=0:DEDD=0:PRINT "- verified ":IF NOT EOT THEN 4800 ELSE IF NOT ETT THEN 4845 ELSE 4850
4770 IF Z$=NAK$ THEN ECNT=ECNT+1:IF ECNT>10 THEN GOSUB 40900:GOTO 4860 ELSE IF NOT EOT THEN 4805 ELSE 4845
4775 IF Z$=CAN$ THEN 4855
4780 WEND:GOSUB 4965:IF ABORT THEN 4860
4785 GOSUB 4990:IF NOT TENSEC THEN 4760
4790 GOSUB 4995:IF NOT ABORT THEN IF NOT EOT THEN 4805 ELSE 4845 ELSE 4860
4800 A$=Y$:PRINT"Sending Block #";BLK;:PRINT #1,A$;:IF CNT!<FLN! THEN GOSUB 4815:GOTO 4755 ELSE EOT=-1:GOTO 4755
4805 ECNT=ECNT+1:IF ECNT>10 THEN GOSUB 40950:GOTO 4860 ELSE PRINT:PRINT"***Re-sending block...";:PRINT #1,A$;:GOTO 4755
4810 '
4815 BLK=BLK+1:CNT!=CNT!+128:GET#3,BLK:Y$=X$:IF CNT!<=FLN! THEN 4825
4820 Y$=MID$(Y$,1,128-(CNT!-FLN!))+STRING$(CNT!-FLN!,CHR$(0))
4825 CK=0:FOR I=1 TO LEN(Y$):CK=CK+ASC(MID$(Y$,I,1)):NEXT:CK=(CK AND 255)
4830 IF CK>256 THEN CK=CK-256:GOTO 4830
4835 SEC=(255 AND BLK):Y$=SOH$+CHR$(SEC)+CHR$(SEC XOR 255)+Y$+CHR$(CK):RETURN
4840 '
4845 PRINT #1,EOT$;:PRINT"***Sending End Marker ";:ETT =-1:GOTO 4755
4850 CLOSE #3:GOTO 3215
4855 PRINT:PRINT"***Cancelled by Receiver":CLOSE #3:GOTO 3210
4860 PRINT:PRINT"***Cancelled by Transmitter":CLOSE #3:PRINT #1,CAN$;:GOTO 3210
4865 '
4900 '
4905 Z$="":ZA=0
4910 IF NOT EOF(1) THEN Z$=INPUT$(LOC(1),#1):RETURN ELSE EVWAIT!=1:GOSUB 40800:ZA=ZA+1
4915 IF ZA>72 THEN RETURN ELSE 4910
4920 '
4925 ABORT=0:SECZ=0:GOSUB 4985
4930 GOSUB 4905:GOSUB 4965:IF ABORT THEN RETURN
4935 IF LEFT$(Z$,1)=SOH$ THEN RETURN
4940 IF LEFT$(Z$,1)=EOT$ THEN RETURN
4945 IF LEFT$(Z$,1)=CAN$ THEN RETURN
4950 GOSUB 4975:PRINT #1,NAK$;
4955 GOSUB 4990:IF NOT TENSEC THEN 4955 ELSE GOSUB 4995:GOTO 4930
4960 '
4965 B$=INKEY$:IF LEN(B$)<2 THEN RETURN ELSE Q$=MID$(B$,2,1):IF Q$=CHR$(19) OR Q$=CHR$(20) THEN ABORT=-1:RETURN ELSE RETURN
4970 '
4975 WHILE NOT EOF(1):Z$=INPUT$(LOC(1),#1):WEND:RETURN
4980 '
4985 SECX=60*VAL(MID$(TIME$,4,2))+VAL(MID$(TIME$,7,2)):RETURN
4990 TENSEC=0:SECY=60*VAL(MID$(TIME$,4,2))+VAL(MID$(TIME$,7,2)):IF SECY-SECX<10 THEN RETURN ELSE TENSEC=-1:RETURN
4995 IF SECZ<9 THEN GOSUB 4985:SECZ=SECZ+1:RETURN ELSE ABORT=-1:RETURN
4996 '
5000 '
5010 BEEP:CLS:PRINT:PRINT"===COMMUNICATIONS PARAMETERS===
5015 PRINT:PRINT"Present parameters: ";:GOSUB 5100:PRINT"Options:
5020 PRINT"   1 -  300,E,7,1  (text)      2 -  300,N,8,1  (binary)
5025 PRINT"   3 - 1200,E,7,1  (text)      4 - 1200,N,8,1  (binary)
5026 PRINT"   5 -  450,E,7,1  (text)      6 -  450,N,8,1  (binary)
5030 PRINT SPACE$(15);"F - reset params to defaults
5035 PRINT SPACE$(15);"X - exit to terminal
5040 PRINT"Choose: ";
5045 Q$=INPUT$(1):GOSUB 2555
5050 IF Q$="X" THEN PRINT Q$:PRINT:PRINT"(Present parameters still in effect)":GOTO 5095
5055 IF Q$="F" THEN PRINT Q$:GOSUB 5815:PRINT:PRINT"Parameters reset to:";:DORN=0:GOSUB 5100:GOTO 5095
5060 DORN=0:Q=VAL(Q$):IF Q<1 OR Q>6 THEN BEEP:GOTO 5045 ELSE PRINT Q
5065 BAU$="300":PAR$="E":DTA$="7":STP$="1
5070 IF Q=2 THEN PAR$="N":DTA$="8"
5075 IF Q=3 THEN BAU$="1200
5080 IF Q=4 THEN BAU$="1200":PAR$="N":DTA$="8"
5081 IF Q=6 THEN PAR$="N":DTA$="8"
5085 LOCATE ,,1:COMM$=COMMPORT$+BAU$+","+PAR$+","+DTA$+","+STP$+COMMINIT$:CLOSE #1:OPEN COMM$ AS #1
5086 IF Q=5 OR Q=6 THEN GOSUB 11000
5090 PRINT:PRINT"New parameters are: ";:GOSUB 5100
5095 IF MDFLG THEN RETURN ELSE PRINT GO$:GOSUB 2800:GOTO 515
5100 COLOR BG,FG:IF DORN=1 THEN 5101 ELSE PRINT MID$(COMM$,6,10);:COLOR FG,BG:PRINT:PRINT:GOTO 5105
5101 PRINT "450,"+PAR$+","+DTA$+","+STP$;:COLOR FG,BG:PRINT:PRINT
5105 PRINT"Echo-";:IF ECH=-1 THEN PRINT"Y"; ELSE PRINT"N";
5110 PRINT" Mesg-";:IF MSG=-1 THEN PRINT"Y"; ELSE PRINT"N";
5115 PRINT" Strip-";:IF NS=0 THEN PRINT"N"; ELSE PRINT USING"#";NS;
5120 PRINT" Pace-";:IF PC$="" THEN PRINT"N" ELSE PRINT PC$
5125 IF NS=0 THEN PRINT:RETURN ELSE FOR I=1 TO NS:PRINT"Strip #";:PRINT USING"#";I;:PRINT" - /";:PRINT USING"###";ASC(S$(I));:PRINT"/";:IF R$(I)="" THEN PRINT"000"; ELSE PRINT USING"###";ASC(R$(I));
5130 PRINT"/":NEXT:PRINT:RETURN
5135 '
5200 '
5210 CLS:BEEP:PRINT"===SET NEW DEFAULTS===":PRINT:COLOR BG,FG:PRINT" Present program defaults:";SPACE$(53);:COLOR FG,BG:EXIT=0
5215 FOR I=1 TO DFNUM:J=I+4:P=1:IF I>15 THEN J=I-11:P=32
5220 LOCATE J,P,0:PRINT DP$(I);:LOCATE J,P+16:IF D$(I)>=" " THEN PRINT D$(I); ELSE IF D$(I)="" THEN PRINT "''"; ELSE IF D$(I)=CHR$(0) THEN PRINT "0"; ELSE COLOR HI,BG:PRINT CHR$(ASC(D$(I))+64);:COLOR FG,BG
5225 IF I<15 THEN PRINT SPACE$(12-LEN(D$(I))); ELSE PRINT SPACE$(30-LEN(D$(I)));
5230 NEXT:LOCATE ,,1:IF EXIT THEN 5280 ELSE FOR I=1 TO DFNUM:DT$(I)=D$(I):NEXT
5231 '
5235 LOCATE 21,1:COLOR BG,FG:PRINT" Enter ";ENT$;" to leave unchanged - <space>";ENT$;" for 'null' value - <ESC>";ENT$;" to quit ":COLOR FG,BG
5240 PRINT"*** Enter new values":ABORT=0:FOR I=1 TO DFNUM:J=I+4:P=1:IF I>15 THEN J=I-11:P=32
5245 IF ABORT THEN 5265
5250 IF D$(I)<>"" THEN LOCATE J,P+17+LEN(D$(I)) ELSE LOCATE J,P+19
5255 IF I>15 THEN QL=16 ELSE QL=4
5260 GOSUB 2500:IF Q$=CHR$(27) THEN GOSUB 2655:GOSUB 2655:ABORT=-1 ELSE IF           Q$<>"" THEN DT$(I)=Q$:IF DT$(I)=" " THEN DT$(I)=""
5265 NEXT
5270 GOSUB 5295:PRINT"*** New values ok (y/n)?";:Q$=INPUT$(1):PRINT Q$:GOSUB         2555:IF Q$="N" THEN GOSUB 5295:LOCATE 21,1:PRINT SPACE$(79);:LOCATE 21,1:       PRINT"(Default Routine Cancelled)":GOTO 5290 ELSE FOR I=1 TO DFNUM:D$(I)=   DT$(I):NEXT
5271 '
5275 EXIT=-1:GOSUB 5295:PRINT"*** Make these changes permanent (y/n)?";:Q$=INPUT$(1):PRINT Q$+" ...wait";:GOSUB 2555:IF Q$="Y" THEN GOSUB 5440:GOTO 5215 ELSE GOSUB 5600:GOTO 5215
5280 GOSUB 5815:CLOSE #1:OPEN COMM$ AS #1
5285 GOSUB 5295:LOCATE CSRLIN-1,1:PRINT SPACE$(79);:LOCATE CSRLIN,1
5290 COLOR FG,BG,BG:PRINT GO$:GOSUB 2800:GOTO 515
5295 LOCATE 22,1:PRINT SPACE$(79);:LOCATE 22,1:RETURN
5400 '
5405 RESTORE 5410:FOR I=1 TO DFNUM:READ DP$(I),D$(I):NEXT:GOSUB 5440:GOTO 311
5410 DATA Baud rate,300,Parity,E,Data bits,7,Stop bits,1,Echo,N,Messages,N
5415  DATA"STRIP #1",0,REPLACE #1,0,"STRIP #2",0,REPLACE #2,0,"STRIP #3",0,REPLACE #3,0,PACING P=,,LOGGED DRIVE,"A:",MARGIN WIDTH,70
5420 DATA SCREENDUMP FILE,"A:SCRNDUMP.PCT",REDIAL DELAY,20,CONNECT PROMPT,CONNECT
5425 DATA Line 25 help,Y,Foreground,7,Background,0,High inten.,15
5430 DATA "Print port","LPT1:","Print init.",,"Print width",80
5435 DATA Comm. port,"COM1:",Comm. init.,",CS,DS",Modem init.,,C/R subst.,"}"
5440 CLOSE #1:OPEN FFIL$ FOR OUTPUT AS #1:WRITE#1,IFIL$:FOR I=1 TO DFNUM:WRITE#1,DP$(I),D$(I):NEXT:WRITE#1,IFIL$:GOSUB 5600:RETURN
5600 '
5605 BAU$=D$(1):PAR$=D$(2):DTA$=D$(3):STP$=D$(4)
5610 I=5:GOSUB 5805:IF D$(5)="Y" THEN DECH=-1 ELSE D$(5)="N":DECH=0
5615 I=6:GOSUB 5805:IF D$(6)="Y" THEN DMSG=-1 ELSE D$(6)="N":DMSG=0
5620 DNS=0:FOR J=1 TO 3:I=2*J+5:GOSUB 5810
5625 DS$(J)=CHR$(VAL(D$(I))):IF DS$(J)<>CHR$(0) THEN DNS=DNS+1 ELSE D$(I)="0"
5630 NEXT:FOR J=1 TO 3:I=2*J+6:GOSUB 5810
5635 DR$(J)=CHR$(VAL(D$(I))):IF DR$(J)=CHR$(0) THEN DR$(J)="":D$(I)="0"
5640 NEXT:IF D$(13)<>"" THEN DPC$="=P"+D$(13) ELSE DPC$=""
5645 D$(14)=LEFT$(D$(14),1)+":":DRIV$=D$(14)
5650 MARG=VAL(D$(15)):DUMP$=D$(16):QDELAY=VAL(D$(17)):CONNECT$=D$(18)
5655 I=19:GOSUB 5805:IF D$(19)="N" THEN MENU=0 ELSE MENU=-1
5660 FG=VAL(D$(20)):BG=VAL(D$(21)):HI=VAL(D$(22))
5665 PRNTPORT$=D$(23):PRNTINIT$=D$(24):WIDTH PRNTPORT$,VAL(D$(25))
5670 I=18:GOSUB 5805:COMMPORT$=D$(26):IF COMMPORT$="COM1:" THEN LSR=&H3FD:LCR=&H3FB ELSE LSR=&H2FD:LCR=&H2FB
5675 COMMINIT$=D$(27):DCOMM$=COMMPORT$+BAU$+","+PAR$+","+DTA$+","+STP$+COMMINIT$:MODMINIT$=D$(28):XCR$=LEFT$(D$(29),1)
5680 GOSUB 5815:RETURN
5800 '
5805 Q$=D$(I):GOSUB 2555:D$(I)=Q$:RETURN
5810 IF VAL(D$(I))<0 OR VAL(D$(I))>255 THEN D$(I)="0":RETURN ELSE RETURN
5815 COMM$=DCOMM$
5820 ECH=DECH:MSG=DMSG:NS=DNS:FOR J=1 TO 3:I=2*J+5:S$(J)=DS$(J):R$(J)=DR$(J):        NEXT:PC$=DPC$:RETURN
5825 '
6000 '
6010 BEEP:CLOSE #2:OPEN DFIL$ AS #2:IF DPAGE=0 THEN DPAGE=1
6015 FIELD #2,24 AS N$,36 AS R$,2 AS X$,4 AS B$,1 AS P$,1 AS D$,1 AS S$,1 AS E$,1 AS M$,2 AS T$,26 AS C$,3 AS L$,2 AS G$
6020 GET#2,1:IF LEFT$(N$,LEN(IFIL$))<>IFIL$ THEN I1=1:I2=60:GOSUB 6870
6025 '
6030 I1=(DPAGE-1)*15+1:I2=(DPAGE-1)*15+15
6035 CLS:LOCATE 1,53,0:PRINT"===DIALING DIRECTORY "DPAGE"===
6040 GET#2,2:MODM$=RIGHT$(R$,CVI(X$)):LOCATE 1,1:PRINT"Modem dialing command = "MODM$
6045 GET#2,3:SERV1$=RIGHT$(R$,CVI(X$)):LOCATE 2,1:PRINT"Long distance service +# = "LEFT$(SERV1$,24):LOCATE 2,52:PRINT "| +Append: ";APPEND1$
6050 GET#2,4:SERV2$=RIGHT$(R$,CVI(X$)):LOCATE 3,23:PRINT"-# = "LEFT$(SERV2$,24):LOCATE 3,52:PRINT"| -Append: ";APPEND2$
6055 LOCATE 4,1:COLOR BG,FG:PRINT"   Name"SPACE$(29)"Phone #   Comm Param  Echo Mesg Strip Pace ";:COLOR FG,BG:LOCATE 5,1
6060 FOR I=I1 TO I2:GET#2,I+4
6065 PRINT USING "##";LOC(2)-4;:PRINT"-";N$;"  ";RIGHT$(R$,14);"   ";B$;"-";P$;"-";D$;"-";S$;"    ";E$;"    ";M$;"   ";:IF CVI(T$)=0 THEN PRINT " N "; ELSE PRINT CVI(T$);
6070 PRINT"  ";:IF CVI(G$)=0 THEN PRINT "  N" ELSE PRINT "p="+L$
6075 NEXT
6080 '
6085 LOCATE 21,1:PRINT"Dial entry #:             | or...
6090 LOCATE 21,39:PRINT"Enter: R to revise or add to directory
6095 LOCATE 22,46:PRINT"M for manual dialing
6100 LOCATE 23,42:PRINT"F / B to page through directory
6105 LOCATE 24,46:PRINT"X to exit to terminal";
6110 LOCATE 25,27:PRINT"| For long distance service, precede entry # with +/-";
6115 LOCATE 21,14,1:QL=3:GOSUB 2500:GOSUB 2555
6120 IF LEFT$(Q$,1)="+" THEN SERV1=-1:Q$=RIGHT$(Q$,LEN(Q$)-1) ELSE SERV1=0
6125 IF LEFT$(Q$,1)="-" THEN SERV2=-1:Q$=RIGHT$(Q$,LEN(Q$)-1) ELSE SERV2=0
6130 IF Q$="R" THEN 6400
6135 IF Q$="F" THEN IF DPAGE=4 THEN DPAGE=1:GOTO 6030 ELSE DPAGE=DPAGE+1:GOTO 6030
6140 IF Q$="B" THEN IF DPAGE=1 THEN DPAGE=4:GOTO 6030 ELSE DPAGE=DPAGE-1:GOTO 6030
6145 IF Q$="X" THEN CLOSE #2:GOSUB 2700:CLS:LOCATE 1,1,1:PRINT GO$:GOSUB 2800:GOTO 515
6150 IF Q$="M" THEN CLOSE #2:GOSUB 2700:CLS:LOCATE 1,1,1:GOSUB 6305:GOSUB 2800:GOTO 515
6155 IF VAL(Q$)<1 OR VAL(Q$)>60 THEN BEEP:LOCATE 21,14:PRINT SPACE$(LEN(Q$))        :GOTO 6115
6200 '
6205 GET#2,VAL(Q$)+4:BAU$=B$:PAR$=P$:DTA$=D$:STP$=S$:IF LEFT$(BAU$,1)=" " THEN BAU$=RIGHT$(BAU$,3)
6210 COMM$=COMMPORT$+BAU$+","+PAR$+","+DTA$+","+STP$+COMMINIT$
6215 CLOSE #1:OPEN COMM$ AS #1
6220 IF E$="Y" THEN ECH=-1 ELSE ECH=0
6225 IF M$="Y" THEN MSG=-1 ELSE MSG=0
6230 NS=CVI(T$):IF NS=0 THEN 6255
6235 FOR I=0 TO NS-1:P=VAL(MID$(C$,I*8+1,3)):IF P>255 THEN P=0
6240 J=VAL(MID$(C$,I*8+5,3)):IF J>255 THEN J=0
6245 S$(I+1)=CHR$(P):IF J=0 THEN R$(I+1)="" ELSE R$(I+1)=CHR$(J)
6250 NEXT
6255 IF CVI(G$)<>0 THEN PC$="=P"+LEFT$(L$,CVI(G$)) ELSE PC$=""
6257 FOR X=1 TO LEN(N$):IF MID$(N$,X,1)<>" " THEN LECOUNT=X
6258 NEXT X:LECOUNT=LECOUNT+1
6260 CLS:LOCATE 1,1,1:PRINT"===DIALING ";LEFT$(N$,LECOUNT);" -  ";
6265 DIAL$=RIGHT$(R$,CVI(X$))
6266 FOR X=1 TO LEN(DIAL$):IF (MID$(DIAL$,X,1)>="0" AND MID$(DIAL$,X,1)<="9") THEN TEMP$=TEMP$+MID$(DIAL$,X,1)
6267 NEXT X:SWAP DIAL$,TEMP$
6268 IF (SERV1 OR SERV2) AND LEFT$(DIAL$,1)="1" AND LEN(DIAL$)>10 THEN DIAL$=RIGHT$(DIAL$,LEN(DIAL$)-1)
6270 IF SERV1 THEN DIAL$=SERV1$+DIAL$+APPEND1$
6275 IF SERV2 THEN DIAL$=SERV2$+DIAL$+APPEND2$
6280 PRINT TEMP$:TEMP$="":PRINT:PRINT #1, MODM$+DIAL$:STRT$=TIME$
6285 CLOSE #2:GOSUB 2700:GOSUB 2800:GOTO 515
6300 '
6305 MDFLG=0:LOCATE 7,1:PRINT"Current Comm Parameters are: ";COMM$:PRINT: PRINT      "Options: 1) Use Current  2) Use Default  3) Change (1/2/3 cr=Current) ";
6306 B$=INKEY$:IF B$="" GOTO 6306 ELSE IF VAL(B$)<>1 AND VAL(B$)<>2 AND              VAL(B$)<>3 AND B$<>CHR$(13) THEN BEEP:GOTO 6306 ELSE PRINT B$
6307 IF VAL(B$)=1 OR B$=CHR$(13) THEN GOSUB 5820:MCOM$=COMM$:GOTO 6308 ELSE IF       VAL(B$)=2 THEN GOSUB 5820:MCOM$=DCOMM$:GOTO 6308 ELSE MDFLG=-1:GOSUB 5010:      MDFLG=0:MCOM$=COMM$:GOSUB 5820
6308 PRINT:PRINT"===DIAL PHONE # w/o Dial Command: (cr=Cancel) ";:QL=36:             GOSUB 2500:R$=Q$:N$="
6310 IF R$="" THEN PRINT"(cancelled)":PRINT GO$:LOCATE,,1:RETURN
6315 IF LEFT$(R$,1)="+" THEN DIAL$=SERV1$+RIGHT$(R$,LEN(R$)-1) ELSE DIAL$=R$
6320 IF LEFT$(R$,1)="-" THEN DIAL$=SERV2$+RIGHT$(R$,LEN(R$)-1)
6325 CLOSE #1:OPEN MCOM$ AS #1:PRINT #1,MODM$+DIAL$:STRT$=TIME$:PRINT:LOCATE,,1:       RETURN
6400 '
6405 GOSUB 6900:LOCATE 21,1,0:PRINT"Revise/add entry #:       | or...
6410 LOCATE 21,39:PRINT"Enter:  M to change modem command
6415 LOCATE 22,43:PRINT"+ / - to change long distance #s
6420 LOCATE 23,47:PRINT"C to clear directory entries
6425 LOCATE 24,47:PRINT"X to exit to dialing prompt";
6430 LOCATE 21,20,1:QL=2:GOSUB 2500:GOSUB 2555
6435 IF Q$="M" THEN 6830
6440 IF Q$="+" THEN 6835
6445 IF Q$="-" THEN 6840
6450 IF Q$="C" THEN GOSUB 6850:GOTO 6030
6455 IF Q$="X" THEN 6030
6460 IF VAL(Q$)<I1 OR VAL(Q$)>I2 THEN BEEP:LOCATE 21,20:PRINT SPACE$(LEN(Q$)):GOTO 6430
6465 DE$=Q$:GET#2,VAL(DE$)+4:Q=VAL(DE$)-I1+1
6470 '
6475 GOSUB 6900:LOCATE 22,1:PRINT"Name: ";:QL=24:GOSUB 2500:NI$=Q$
6480 IF NI$="" THEN NI$=N$
6485 LOCATE Q+4,4:PRINT NI$;SPACE$(25-LEN(NI$));:GOSUB 6910
6490 PRINT"Phone number: ";:QL=36:GOSUB 2500:RI$=Q$:XI=LEN(RI$):IF RI$="" THEN RI$=R$:XI=CVI(X$)
6495 LOCATE Q+4,30:IF XI>14 THEN PRINT RIGHT$(RI$,14) ELSE PRINT SPACE$(14-XI)+RIGHT$(RI$,XI)
6500 '
6505 GOSUB 6910:PRINT"Communications parameters ok (y/n)? ";:QL=1:GOSUB 2500:GOSUB 2555
6510 IF Q$="Y" OR Q$="" THEN BI$=B$:PI$=P$:DI$=D$:SI$=S$:GOTO 6555
6515 GOSUB 6910:PRINT"Baud rate: ";:QL=4:GOSUB 2500:BI$=Q$:IF BI$="" THEN BI$=B$
6520 LOCATE Q+4,47:PRINT SPACE$(4-LEN(BI$));BI$;
6525 GOSUB 6910:PRINT"Parity: ";:QL=1:GOSUB 2500:GOSUB 2555:PI$=Q$:IF PI$="" THEN PI$=P$
6530 LOCATE Q+4,52:PRINT PI$;
6535 GOSUB 6910:PRINT"# data bits: ";:QL=1:GOSUB 2500:DI$=Q$:IF DI$="" THEN DI$=D$
6540 LOCATE Q+4,54:PRINT DI$;
6545 GOSUB 6910:PRINT"# stop bits: ";:QL=1:GOSUB 2500:SI$=Q$:IF SI$="" THEN SI$=S$
6550 LOCATE Q+4,56:PRINT SI$;
6555 '
6560 GOSUB 6910:PRINT"Echo on (y/n)? ";:QL=1:GOSUB 2500:GOSUB 2555:EI$=Q$:IF EI$="" THEN EI$=E$:GOTO 6570
6565 IF EI$<>"Y" THEN EI$="N
6570 LOCATE Q+4,61:PRINT EI$;
6575 GOSUB 6910:PRINT"Messages on (y/n)? ";:QL=1:GOSUB 2500:GOSUB 2555:MI$=Q$:IF MI$="" THEN MI$=M$:GOTO 6585
6580 IF MI$<>"Y" THEN MI$="N
6585 LOCATE Q+4,66:PRINT MI$;
6590 '
6595 GOSUB 6910:LOCATE 22,1:PRINT"Strip/convert characters (y/n)? ";:QL=1:GOSUB 2500:GOSUB 2555:IF Q$="" THEN TI=CVI(T$):CI$=C$:GOTO 6655
6600 IF Q$="0" OR Q$="N" THEN TI=0:CI$=STRING$(26,47):GOTO 6645
6605 IF Q$<>"Y" THEN BEEP:GOTO 6595
6610 GOSUB 6905:LOCATE 22,1:PRINT"old strip/cnvt string: ";C$
6615 LOCATE 23,1:PRINT"change this (y/n)? ";:QL=1:GOSUB 2500:GOSUB 2555:IF Q$<>"Y" THEN TI=CVI(T$):CI$=C$:LOCATE 23,1:PRINT SPACE$(20);:GOTO 6655
6620 LOCATE 24,1:PRINT"(please refer to instructions in the documentation)";:LOCATE 23,1:PRINT"new strip/cnvt string: ";:QL=24:GOSUB 2500:CI$=Q$
6625 CI$=CI$+STRING$(26-LEN(CI$),47)
6630 LOCATE 21,40:PRINT"new string ok (y/n)?";SPACE$(20);:LOCATE 21,61:QL=1:GOSUB 2500:GOSUB 2555:IF Q$="N" THEN LOCATE 23,1:PRINT SPACE$(79):GOTO 6620
6635 P=INSTR(CI$,"//"):IF P=1 THEN TI=0:GOTO 6655
6640 IF P MOD 8<>0 THEN BEEP:GOTO 6610 ELSE TI=P/8
6645 GOSUB 6905:LOCATE Q+4,71:IF TI=0 THEN PRINT "N" ELSE PRINT USING "#";TI
6650 '
6655 GOSUB 6910:LOCATE 22,1:PRINT"Pacing? p=";:QL=3:GOSUB 2500:LI$=Q$:GI=LEN(LI$)
6660 IF Q$="0" OR Q$="N" OR Q$="n" THEN LI$="N":GI=0:LOCATE Q+4,75:PRINT"  N  ";:GOTO 6800
6665 IF LI$="" THEN LI$=L$:GI=CVI(G$):GOTO 6800
6670 LOCATE Q+4,75:PRINT "p="+LI$+SPACE$(3-GI)
6800 '
6805 LSET N$=NI$:RSET R$=RI$:LSET X$=MKI$(XI):RSET B$=BI$:LSET P$=PI$:LSET D$=DI$:LSET S$=SI$:LSET E$=EI$:LSET M$=MI$:LSET T$=MKI$(TI):LSET C$=CI$:LSET L$=LI$:LSET G$=MKI$(GI)
6810 GOSUB 6905:LOCATE 22,1:PRINT"Is entry #";DE$;" ok (y/n)? ";:QL=1:GOSUB 2500:GOSUB 2555:Q1$=Q$
6815 IF Q1$<>"Y" AND Q1$<>"" THEN LOCATE 22,1:PRINT SPACE$(35);:GOTO 6470
6820 PUT#2,VAL(DE$)+4:GOTO 6030
6825 '
6830 GOSUB 6900:MSG$="Modem dialing command:":GOSUB 6845:PUT #2,2:GOTO 6030
6835 GOSUB 6900:MSG$="Long distance +#:":MSG1$="Long distance append +#:":GOSUB 6845:PUT #2,3:GOSUB 6841:APPEND1$=Q$:GOSUB 6842:GOTO 6030
6840 GOSUB 6900:MSG$="Long distance -#:":MSG1$="Long distance append -#:":GOSUB 6845:PUT#2,4:GOSUB 6841:APPEND2$=Q$:GOSUB 6842:GOTO 6030
6841 LOCATE 21,1:PRINT MSG1$;SPACE$(79-LEN(MSG1$));:LOCATE 21,LEN(MSG1$)+2:QL=15:GOSUB 2500:RETURN
6842 CLOSE #3:OPEN "LDAPPEND.DAT" FOR OUTPUT AS #3:PRINT #3,APPEND1$:PRINT #3,APPEND2$:CLOSE #3:RETURN
6845 LOCATE 21,1:PRINT MSG$;SPACE$(79-LEN(MSG$));:LOCATE 21,LEN(MSG$)+2:QL=36:GOSUB 2500:RI$=Q$:XI=LEN(RI$):RSET R$=RI$:LSET X$=MKI$(XI):RETURN
6850 '
6855 GOSUB 6900:LOCATE 21,1:PRINT"Clear directory from entry #:";:QL=2:GOSUB 2500:I1=VAL(Q$):IF I1<1 THEN I1=61
6860 PRINT" ... through entry #:";:QL=2:GOSUB 2500:I2=VAL(Q$):IF I2>60 THEN I2=60
6865 PRINT:PRINT"-- Are you sure (y/n)? ";:QL=1:GOSUB 2500:GOSUB 2555:IF Q$<>"Y" THEN 6030
6870 LSET N$=IFIL$:LSET R$="":LSET X$=MKI$(0):LSET B$="":LSET P$="":LSET D$="":LSET S$="":LSET E$="":LSET M$="":LSET T$=MKI$(0):LSET C$="":LSET L$="":LSET G$=MKI$(0):PUT#2,1
6875 IF MODM$="" THEN MODM$="ATDT"
6880 LSET N$="":RSET R$=MODM$:LSET X$=MKI$(LEN(MODM$)):PUT#2,2:RSET R$=SERV1$:LSET X$=MKI$(LEN(SERV1$)):PUT#2,3:RSET R$=SERV2$:LSET X$=MKI$(LEN(SERV2$)):PUT #2,4
6885 LSET N$="------------------------":RSET R$="- --- --- ----":LSET X$=MKI$(14)
6890 RSET B$="300":LSET P$="E":LSET D$="7":LSET S$="1":LSET E$="N":LSET M$="N":LSET T$=MKI$(0):LSET C$=STRING$(26,"/"):LSET L$="":LSET G$=MKI$(0)
6895 FOR I=I1 TO I2:PUT#2,I+4:NEXT:RETURN
6900 '
6905 LOCATE 21,27,0:PRINT SPACE$(52);:FOR I=22 TO 25:LOCATE I,1:PRINT SPACE$(79);:NEXT:LOCATE ,,1:RETURN
6910 LOCATE 22,1,0:PRINT SPACE$(79);:LOCATE 22,1,1:RETURN
6915 '
7000 '
7010 BEEP:IF KPG=0 THEN KPG=1
7015 LOCATE 1,39,0:PRINT CHR$(213)+STRING$(38,205)+CHR$(184)
7020 LOCATE 2,39:PRINT VL$;"     ===FUNCTION KEY DIRECTORY===     ";VL$
7025 LOCATE 3,39:PRINT VL$;SPACE$(15);:COLOR HI,BG:PRINT KPG$(KPG);:COLOR FG,BG:PRINT" F1-10";SPACE$(13);VL$
7030 LOCATE 4,39:PRINT VL$;:COLOR BG,FG:PRINT"F-   Input String";SPACE$(21);:COLOR FG,BG:PRINT VL$
7035 FOR I=1 TO 10:P=(KPG-1)*10+I
7040 LOCATE I+4,39,0:PRINT VL$;:PRINT USING "##";I;:PRINT" = ";
7045 K=LEN(K$(P)):IF K>33 THEN K=33
7050 FOR J=1 TO K:Q=ASC(MID$(K$(P),J,1)):IF Q>31 THEN PRINT CHR$(Q); ELSE IF Q=13 THEN PRINT XCR$; ELSE COLOR HI,BG:PRINT CHR$(Q+64);:COLOR FG,BG
7055 NEXT J:PRINT SPACE$(33-K)+VL$+"  ";:NEXT I
7060 LOCATE 15,39,1:PRINT CHR$(198)+STRING$(38,205)+CHR$(181)
7100 '
7105 GOSUB 7435:LOCATE 16,40,1:PRINT"Press:  R to revise ";KPG$(KPG);"-F assignments
7110 LOCATE 17,44:PRINT"F / B to page through directory
7115 LOCATE 18,48:PRINT"X to exit to terminal
7120 LOCATE 16,46,1:Q$=INPUT$(1):GOSUB 2555
7125 IF Q$="R" THEN 7200
7130 IF Q$="X" THEN CLOSE #2:GOSUB 2700:GOSUB 7435:LOCATE 16,40:PRINT GO$;:LOCATE ROW,COL:GOTO 515
7135 IF Q$="F" THEN KPG=KPG+1:IF KPG=5 THEN KPG=1:GOTO 7015 ELSE GOTO 7015
7140 IF Q$="B" THEN KPG=KPG-1:IF KPG=0 THEN KPG=4:GOTO 7015 ELSE GOTO 7015
7145 BEEP:LOCATE 21,76:PRINT SPACE$(LEN(Q$)):GOTO 7120
7200 '
7205 GOSUB 7435:CLOSE #2:OPEN KFIL$ AS #2:FIELD #2, 126 AS K$,2 AS L$
7210 GET#2,1:IF LEFT$(K$,LEN(IFIL$))<>IFIL$ THEN GOSUB 7425
7215 LOCATE 16,40:PRINT"Press Func. key to revise:
7220 LOCATE 18,43:PRINT"or X to exit to terminal
7225 LOCATE 16,66:Q$=INKEY$:IF Q$="" THEN 7225 ELSE IF LEN(Q$)>1 THEN 7240
7230 GOSUB 2555:IF Q$="X" THEN CLOSE #2:GOSUB 2700:GOSUB 7440:LOCATE 16,40:PRINT GO$;:LOCATE ROW,COL:GOTO 515
7235 BEEP:GOTO 7225
7240 Q=ASC(MID$(Q$,2,1))
7245 IF Q>58 AND Q<69 THEN K=(KPG-1)*10+Q-58:Q$=KPG$(KPG)+"-F"+STR$(Q-58):GOTO 7270
7250 IF Q>103 AND Q<114 THEN K=Q-93:Q$=" Alt-F"+STR$(K-10):GOTO 7270
7255 IF Q>83 AND Q<94 THEN K=Q-63:Q$="Shft-F"+STR$(K-20):GOTO 7270
7260 IF Q>93 AND Q<104 THEN K=Q-63:Q$="Ctrl-F"+STR$(K-30):GOTO 7270
7265 BEEP:GOTO 7225
7270 KY=K:GET#2,KY+1
7275 '
7280 GOSUB 7450:LOCATE 16,1:PRINT"New input string for ";Q$;":":LOCATE 20,1:PRINT STRING$(80,196)
7285 LOCATE 21,1:PRINT"Use ";XCR$;" as substitute for carriage returns
7290 LOCATE 22,8:PRINT ENT$;" to leave key unchanged
7295 LOCATE 23,1:PRINT"<space>";ENT$;" to clear key
7300 LOCATE 17,1:PRINT CHR$(16);:QL=126:GOSUB 2500:KI$=Q$
7305 IF KI$="" THEN KI$=K$
7310 IF KI$=" " THEN KI$="
7315 LI=LEN(KI$)
7400 '
7405 LSET K$=KI$:LSET L$=MKI$(LI):PUT#2,KY+1
7410 IF Q$="0" THEN K$(10)=KI$:GOSUB 7455:GOTO 7015
7415 K$(KY)=KI$:GOSUB 7455:GOTO 7015
7420 '
7425 LSET K$=IFIL$:LSET L$="":PUT#2,1
7430 LSET K$="":LSET L$=MKI$(0):FOR I=2 TO 41:PUT#2,I:NEXT:RETURN
7435 '
7440 FOR I=16 TO 18:LOCATE I,39,0:PRINT VL$;SPACE$(38);VL$;"   ";:NEXT
7445 LOCATE 19,39:PRINT CHR$(212);STRING$(38,205);CHR$(190);"   ";:LOCATE ,,1:RETURN
7450 LOCATE 15,1,0:PRINT STRING$(80,205);:GOTO 7460
7455 LOCATE 15,1,0:PRINT SPACE$(80);
7460 FOR I=16 TO 23:LOCATE I,1:PRINT SPACE$(80);:NEXT:LOCATE 24,1:PRINT SPACE$(79);:LOCATE ,,1:RETURN
7465 '
8000 '
8010 COMA=0:Q1DELAY=QDELAY 'COMA--To recognize pauses if used in DIAL$
8015 FOR I=1 TO LEN(DIAL$):IF MID$(DIAL$,I,1)="," THEN COMA=COMA+38
8020 NEXT:IX=0:CLS:V$=TIME$:LOCATE 20,4,0:PRINT"To change disconnect delay time press ";:COLOR HI,BG:PRINT"]";:COLOR FG,BG:PRINT" after '**  DIALING:' appears above.";:LOCATE 1,1
8025 MSG$="  Redialing...  *** HIT R TO RECYCLE. HIT SPACE BAR TO TERMINATE ***"     :GOSUB 2600:LOCATE 2,54:PRINT"Redial Started at: ";:COLOR HI,BG:PRINT V$;:      COLOR FG,BG:LOCATE 1,1
8030 Q1$="":Q$="":PRINT"  ===REDIALING ";N$;:LOCATE 1,45:PRINT                       "Time at Start of This Pass: ";:COLOR HI,BG:PRINT TIME$:COLOR FG,BG:            LOCATE 2,1:PRINT #1,MODM$+DIAL$:ROW=CSRLIN:COL=POS(0)
8035 EVWAIT!=(12000/VAL(BAU$))+COMA+1:I=0:IX=IX+1:AFLG=0
8040 WHILE I<>Q1DELAY
8045  LOCATE 22,4:PRINT"THIS IS TRY #: ";IX;"  ELAPSED TIME THIS PASS ";I;
8050  B1$=INKEY$:IF B1$="R" OR B1$="r" GOTO 8115
8055  IF B1$="]" GOTO 8165
8060  '
8065  IF B1$=" " GOTO 8155
8070  IF LOC(1)>0 THEN Q$=INPUT$(LOC(1),1):Q1$=Q1$+Q$ ELSE 8080 'See Ln 9055
8075  IF INSTR(Q1$,MODM$+DIAL$)<>0 AND AFLG=0 THEN LOCATE ROW,COL:PRINT            "  ** DIALING: ";MODM$+DIAL$:PRINT"  ** COM PARAMS: ";MID$(COMM$,6,10):         PRINT"  ** DISCONNECT DELAY PERIOD IS: "Q1DELAY:AFLG=1:ROW=CSRLIN:COL=POS(0)
8080  I=I+1
8085  IF INSTR(Q1$,CONNECT$)<>0 GOTO 8130
8090  IF INSTR(Q1$,"BUSY")<>0 OR INSTR(Q1$,"NO CARRIER")<>0 GOTO 8125
8095  EVWAIT!=19.5:GOSUB 40800
8100 WEND
8105 '  -- Delay Time has Expired
8110 LOCATE ROW,COL:COLOR HI,BG:PRINT"  ** DELAY PERIOD EXPIRED **";:COLOR 7,BG
8115 PRINT #1,"A":EVWAIT!=30:GOSUB 40800:EVWAIT!=1:GOSUB 40800:GOSUB 8180:CLOSE #1:OPEN COMM$ AS #1:         GOTO 8025
8120 '  -- Busy or No Carrier
8125 LOCATE ROW,COL:COLOR HI,BG:PRINT"  *** LINE BUSY OR NO CARRIER ***":COLOR FG,BG:EVWAIT!=27:GOSUB 40800:GOSUB 8180:GOTO 8025
8130 '  -- Connected
8135 STRT$=TIME$:MSG$=" REMOTE COMPUTER ON LINE *** HIT ANY KEY TO PROCEED ***"      :GOSUB 2600
8140 LOCATE 12,15:COLOR 31,BG:PRINT"  <<<  CONNECTED WITH "N$"  >>>":                COLOR FG,BG:LOCATE ,,1
8145 IF INKEY$="" THEN PLAY "MBMSL64N39N46":GOTO 8145 ELSE CLS:GOSUB 2800:GOTO 515
8150 '  -- Redial Terminate
8155 PRINT #1,"A";:PLAY "MFL64N42":EVWAIT!=1:GOSUB 40800
8160 CLS:BEEP:PRINT"===REDIAL TERMINATED...Back in Terminal Mode ===":PRINT GO$:     GOSUB 2800:GOTO 515
8165 LOCATE 13,1:INPUT"GIVE NEW DELAY IN SECONDS (10 sec. minimum  cr=default)";     Q1DELAY
8170 IF Q1DELAY=0 THEN Q1DELAY=QDELAY ELSE IF Q1DELAY<10 THEN Q1DELAY=10
8175 LOCATE 13,1:PRINT SPACE$(78);:GOTO 8070
8180 LOCATE 2,1:FOR I=1 TO 4:PRINT SPACE$(40):NEXT:LOCATE 1,1:RETURN
8200 '
8210 IF STRT$="--" THEN MLPSD=0:GOTO 8220
8215 MSTRT=VAL(MID$(STRT$,1,2))*60+VAL(MID$(STRT$,4,2)):MSTOP=VAL(MID$(TIME$,1,2))*60+VAL(MID$(TIME$,4,2)):MLPSD=INT(MSTOP-MSTRT):IF MSTRT>MSTOP THEN MLPSD=MLPSD+1440
8220 LOCATE 1,39:PRINT CHR$(213)+STRING$(38,205)+CHR$(184);
8225 LOCATE 2,39:PRINT VL$;"  Elapsed time this call = ";:COLOR HI,BG:PRINT MLPSD;:PRINT" min     ";:LOCATE 2,78:COLOR FG,BG:PRINT VL$;
8230 LOCATE 3,39:PRINT CHR$(192)+STRING$(38,205)+CHR$(217);
8235 LOCATE ROW,COL:GOTO 515
8240 '
8900 '
8910 BEEP:PRINT:PRINT"*** This program requires that you have a serial port."
8915 PRINT:PRINT:PRINT:PRINT STRING$(32,32);"Have a good day!":PRINT:PRINT:PRINT"(returning to DOS)":PLAY "MBL32N36N32L16N36":END
8920 '
8925 COLOR HI,BG:PRINT"<<";MSG$;">>";:COLOR FG,BG:RETURN
8930 IF ERR=52 OR ERR=64 OR ERR=67 THEN MSG$="Not a valid file name.
8935 IF ERR=53 THEN MSG$="File not found.
8940 IF ERR=70 THEN MSG$="Disk is write protected.
8945 IF ERR=71 THEN MSG$="Check disk drive.
8950 IF ERR=72 THEN MSG$="Disk media error.
8955 RETURN
8960 '
9000 '
9002 IF ERL=3645 AND ERR=31 THEN PRINT "DISK  *NOT*  READY!":RESUME 3650
9003 IF ERL=3645 THEN RESUME 3646
9005 IF ERL=170 THEN CLOSE #1:OPEN "LDAPPEND.DAT" FOR OUTPUT AS #1:PRINT #1,"  ":PRINT #1,"  ":CLOSE #1:RESUME 170
9010 IF ERL=215 THEN RESUME 5405 
9015 IF ERL=225 THEN RESUME 245
9020 IF ERL=5665 THEN RESUME 5670
9025 IF ERL=425 THEN RESUME 245
9030 IF ERR=27 THEN BEEP:MGS$="CHECK PRINTER":GOSUB 8925:PR=0:IF ERL=1610 THEN RESUME 515 ELSE RESUME 820 
9035 IF ERL=5280 THEN BEEP:GOSUB 5295:PRINT TAB(31);"***  Invalid communication parameter.  Try again.";:EXIT=0:RESUME 5215
9040 IF ERL=6215 AND ERR=64 THEN BEEP:LOCATE 20,1:PRINT"*** Invalid parameters for entry #";Q$:RESUME 6400
9045 IF ERL=6245 THEN BEEP:LOCATE 20,1:PRINT"*** Invalid stripping for entry #";Q$:RESUME 6400
9050 IF ERR=24 THEN MSG$="TIMEOUT":GOSUB 8925:IF PR THEN PR=0:MSG$="PRINTOUT OFF":GOSUB 8925:PR=O:CLOSE #3:RESUME 820 ELSE MSG$="CHECK MODEM":GOSUB 8925:RESUME 515
9055 IF ERR=57 THEN MSG$="":GOSUB 8925:IF RC$="X" THEN RESUME 4525 ELSE IF TC$="X" THEN RESUME 4725 ELSE RESUME 515
9060 IF ERR=69 THEN PRINT #1,XF$;:PSE=-1:MSG$="OVERFLOW":GOSUB 8925:IF NOT PR THEN RESUME 515 ELSE MSG$="PRINTOUT OFF":PR=0:CLOSE #3:RESUME 515
9065 IF ERR=15 AND ERL=660 THEN MSG$="OVERFLOW--PRINTOUT OFF":GOSUB 8925:PR=0:CLOSE #3:RESUME 515
9070 IF ERL=3640 THEN BEEP:PRINT"*** File(s) not found. Try again.":RESUME 3645
9075 IF ERR=61 AND RC$="X" THEN BEEP:PRINT"*** DISK IS FULL":RESUME 4645
9080 IF ERR=61 THEN BEEP:PRINT:PRINT"===DISK IS FULL===":IF RC THEN RESUME 3000 ELSE RESUME 3820
9085 IF ERL=3810 THEN LOCATE 1,40:COLOR HI,BG:PRINT"***CAN'T OPEN ";DUMP$;"***";:LOCATE ROW,COL:RESUME 3820
9090 IF ERR=67 AND ERL=3595 THEN PRINT"*** Either too many files, or
9095 IF ERL=3595 THEN MSG$="":GOSUB 8930:BEEP:PRINT"*** ";MSG$;" Try again.":RESUME 3500
9100 IF ERR=67 OR ERR=70 OR ERR=71 THEN BEEP:PRINT"*** Can't read/write file in the default drive.":PRINT"Correct and hit any key to resume..":Q$=INPUT$(1):IF ERL<400 THEN RESUME 215 ELSE CLS:RESUME 405
9105 IF ERR=68 THEN GOTO 8910
9115 IF ERR=62 AND ERL=3420 THEN RESUME 3425
9120 IF ERR=53 AND ERL=11137 THEN BEEP:PRINT "===File NOT FOUND===":                 RESUME 11130
9125 IF ERR=53 AND ERL=11167 THEN BEEP:PRINT "===File NOT FOUND===":                 RESUME 11160
9130 IF ERL=810 THEN MSG$="Please check your printer, then press any key. ":GOSUB 2600:TEMP$=INPUT$(1):GOSUB 2825:RESUME 810
9200 '************* MUSIC ERRORS *************05-04-84
9210 IF ERR=5 AND ERL=12420 THEN GOTO  9212 ELSE 9220
9212 GOSUB 4970:Z$="":C$="":RESUME 637
9220 IF ERR=15 AND ERL=645 THEN 9222 ELSE 9290
9222 GOSUB 4970:Z$="":C$="":RESUME 637
9232 GOSUB 4970:Z$="":C$="":A$="":GOTO 637
9240 '
9242 GOSUB 4970:Z$="":C$="":A$=RRL$:GOTO 637
9290 '
9900 IF ERR=5 THEN RESUME 615
9905 CLOSE:BEEP:MSG$=" Sorry, NON-RECOVERABLE ERROR "+STR$(ERR)+" at line"+STR$(ERL):GOSUB 2600:ON ERROR GOTO 0
9999 DATA "Compatibility changes by:  Dorn W. Stickle, 6/84.   Higher level then 840517"
10000 IF SP THEN SP=0:TMP$="":LOCATE ROW,COL,1:PRINT:PRINT ELSE 10010
10001 PRINT"===Split Screen Operation Off":BEEP:PRINT:ROW=CSRLIN:COL=POS(0)
10002 LOCATE 25,1,0:PRINT CLIN$:LOCATE ROW,COL,1:GOTO 515
10010 SP=-1:BEEP:PRINT:PRINT"===Split Screen Operation On":ROW=CSRLIN
10012 COL=POS(0):LOCATE 25,1,1:GOTO 515
11000 OUT &H3FB,(INP(&H3FB) OR &H80):OUT &H3F8,0:OUT &H3F9,1:OUT &H3FB,(INP(&H3FB) AND &H7F):DORN=1:RETURN
11010 IF B$=CR$ THEN B$=TMP$+B$:TMP$="":LOCATE 25,1,0:PRINT CLIN$;:GOTO 558
11020 IF B$=CHR$(27) THEN TMP$="":LOCATE 25,1,0:PRINT CLIN$;:XPOS=1 ELSE 11040
11022 LOCATE 25,XPOS,1:GOTO 560
11030 LOCATE 25,XPOS,1:GOTO 560
11032 XPOS=XPOS-1:GOSUB 2655:LOCATE 25,XPOS,1:GOTO 560
11040 IF B$=BS$ AND XPOS>1 THEN TMP$=LEFT$(TMP$,LEN(TMP$)-1) ELSE 11060
11050 XPOS=XPOS-1:GOSUB 2655:LOCATE 25,XPOS,1:GOTO 560
11055 IF XPOS>79 THEN XPOS=1
11060 IF B$=BS$ AND XPOS=1 THEN 560
11070 LOCATE 25,XPOS,1:PRINT B$;:TMP$=TMP$+B$:XPOS=XPOS+1
11080 IF XPOS>79 THEN XPOS=1
11090 GOTO 560 ' End of PC3SC.MRG.
11100 BEEP:PRINT "=== SPECIFY DIRECTORY ==="
11101 GOTO 11182
11102 GOSUB 11180
11112 QL=63:PRINT "New  Directory  Name:";
11114 GOSUB 2500:PRINT:IF Q$="" THEN GOTO 11124
11116 IF LEFT$(Q$,1)<>"\" THEN PRINT "Directory Name must begin with \":              GOTO 11112
11118 NEWDIR$=DRIV$+Q$+CHR$(0):RETCD%=0 :CALL CHDIR(NEWDIR$,RETCD%)
11120 IF RETCD%=0 THEN CURDIR$=NEWDIR$:NEWDIR$="":GOSUB 11180:GOTO 515
11122 IF RETCD%=3 THEN BEEP:PRINT "PATH/DIRECTORY NOT FOUND":GOTO 11124
11123 PRINT "Invalid Return Code from CHDIR = ";RETCD%:GOTO 11124
11124 BEEP:PRINT "===CANCELLED===":GOTO 515
11130 IF RC OR TR THEN BEEP:PRINT "ALT-1/0 KEYS CANNOT BE LOADED DURING FILE OPERATIONS": GOTO 11124
11132 BEEP:PRINT "SPECIFY FILENAME TO LOAD FROM === : "
11134 GOSUB 2500:PRINT:IF Q$="" THEN GOTO 11124
11136 ALTFILE$=Q$:CLS
11137 CLOSE #3:OPEN ALTFILE$ FOR INPUT AS #3
11138 FOR IA=1 TO 10:
11140 INPUT #3,ALTSTR$:PRINT "Alt-";IA;" = ";ALTSTR$
11142 IAX = INSTR(ALTSTR$,XCR$): IF IAX = 0 THEN 11143 ELSE MID$(ALTSTR$,IAX,1)       = CHR$(13): GOTO 11142
11143 IF LEN(ALTSTR$)>50 THEN ALT$(IA)=LEFT$(ALTSTR$,50) ELSE ALT$(IA) =ALTSTR$
11144 NEXT
11145 CLOSE #3
11146 BEEP:PRINT "Alt-1 THRU Alt-0 LOADED FROM:";ALTFILE$:GOTO 515
11160 IF RC OR TR THEN BEEP:PRINT "ALT-1/0 KEYS CANNOT BE SAVED  DURING FILE OPERATIONS": GOTO 11124
11162 BEEP:PRINT "SPECIFY FILENAME TO SAVE INTO === : "
11164 GOSUB 2500:PRINT:IF Q$="" THEN GOTO 11124
11166 ALTFILE$=Q$:CLS
11167 CLOSE #3:OPEN ALTFILE$ FOR OUTPUT AS #3
11168 FOR IA=1 TO 10:
11170 ALTSTR$ = ALT$(IA)
11172 IAX = INSTR(ALTSTR$,CR$): IF IAX = 0 THEN 11173 ELSE MID$(ALTSTR$,IAX,1)        = XCR$: GOTO 11172
11173 PRINT "Alt-";IA;" = ";ALTSTR$:
11175 PRINT #3,CHR$(34);ALTSTR$;CHR$(34)
11176 NEXT
11177 CLOSE #3
11178 BEEP:PRINT "Alt-1 THRU Alt-0 SAVED INTO:";ALTFILE$:GOTO 515
11179 '  -- Service Subroutines for SUBDIRECTORY SUPPORT -- John Chapmen
11180 IF CURDIR$<>"" THEN PRINT:PRINT"Current Directory is: [";DRIV$;"]";             MID$(CURDIR$,INSTR(CURDIR$,"\"))
11181 RETURN
11182 CURDIR$="":NEWDIR$="                                "
11183 NEWDIR$=   NEWDIR$+"                                "+CHR$(0)
11184 '     If driv$="" or driv$=" " then driv$="@"
11185 CALL GETDIR(NEWDIR$,DRIV$,RETCD%)
11186 IF RETCD%<>0 THEN PRINT "Return Code from GETDIR = ";RETCD%: GOTO 11188
11187 IA=INSTR(NEWDIR$,CHR$(0)):CURDIR$="\"+LEFT$(NEWDIR$,IA-1)
11188 GOTO 11102
11999 GOTO 515 ' FAILSAFE EXIT
12000 '************* ESC CONTROL **************
12010 CLEN=LEN(C$)
12020 CEND$=MID$(C$,CLEN,1)
12025 IF CLEN<>2 THEN 12030
12027 IF ASC(CEND$)<>91 THEN RETURN 'INVALID ESC SEQ
12030 ON FF GOTO 12300,12070,12070,12400,12500,12600,12700,9240
12050 RETURN
12060 '************* COLOR CONTROL ************
12070 FOR J=1 TO INT(CLEN/3):Z = VAL(MID$(C$,(3*J),2))
12080 IF Z = 30 THEN FG = 0: GOTO 12290 'BLACK
12090 IF Z = 31 THEN FG = 4: GOTO 12290 'RED
12100 IF Z = 32 THEN FG = 2: GOTO 12290 'GREEN
12110 IF Z = 33 THEN FG = 6: GOTO 12290 'BROWN
12120 IF Z = 34 THEN FG = 1: GOTO 12290 'BLUE
12130 IF Z = 35 THEN FG = 5: GOTO 12290 'MAGENTA
12140 IF Z = 36 THEN FG = 3: GOTO 12290 'CYAN
12150 IF Z = 37 THEN FG = 7: GOTO 12290 'WHITE
12160 IF Z = 40 THEN BG = 0: GOTO 12290 'BLACK
12170 IF Z = 41 THEN BG = 4: GOTO 12290 'RED
12180 IF Z = 42 THEN BG = 2: GOTO 12290 'GREEN
12190 IF Z = 43 THEN BG = 6: GOTO 12290 'BROWN
12200 IF Z = 44 THEN BG = 1: GOTO 12290 'BLUE
12210 IF Z = 45 THEN BG = 5: GOTO 12290 'MAGENTA
12220 IF Z = 46 THEN BG = 3: GOTO 12290 'CYAN
12230 IF Z = 47 THEN BG = 7: GOTO 12290 'WHITE
12240 IF Z = 0  THEN BG = BGI: FG = FGI:IFLAG = 0:BFLAG=0: GOTO 12290
12250 IF Z = 2  THEN CLS   : LOCATE 1,1:GOTO 12290 'CLEAR
12260 IF Z = 1  THEN IFLAG = 8:GOTO 12290 'INTENSITY HIGH
12270 IF Z = 5  THEN BFLAG = 16:GOTO 12290 'BLINK
12280 '
12290 NEXT J:FFG=FG+IFLAG+BFLAG:COLOR FFG,BG:RETURN
12300 '*********** CURSOR POSITION ************
12310 '
12320 PROW=VAL(MID$(C$,CLEN-5,2))
12330 PCOL=VAL(MID$(C$,CLEN-2,2))
12340 LOCATE PROW,PCOL
12350 RETURN
12400 '***********  MUSIC  CONTROL ************
12410 '
12420 PLAY MID$(C$,3,(CLEN-3))
12430 RETURN
12500 '*********** SCREEN  CONTROL ************
12510 '
12520 MODE=VAL(MID$(C$,CLEN-11,2))
12530 BURST=VAL(MID$(C$,CLEN-8,2))
12540 APAGE=VAL(MID$(C$,CLEN-5,2))
12550 VPAGE=VAL(MID$(C$,CLEN-2,2))
12560 SCREEN MODE,BURST,APAGE,VPAGE
12570 RETURN
12600 '*********** STRING   INPUT  ************
12610 '
12620 INPUT I$:PRINT #1,I$
12630 RETURN
12700 '****** ESCAPE SEQUENCE VERIFY ******
12710 '
12720 RETURN 655
13000 IF IB THEN IB=0:PRINT"===I.B.M. 3101 Operation Off":BEEP:GOTO 515
13015 IB=-1:BEEP:PRINT"===I.B.M. 3101 Operation On":GOTO 515
13030 FOR I = 1 TO LEN(A$):C$=MID$(A$,I,1)
13035 ON ESCSEQ GOTO 13145,13170,13180
13040 IF C$<" " THEN 13070
13045 PRINT C$;:COL=COL+1:IF COL>80 THEN COL=1:ROW=ROW+1:IF ROW>24 THEN ROW=24
13050 GOTO 13355
13055 '
13060 ' 3101 Control character encountered
13065 '
13070 C=ASC(C$)
13075 IF C=13 THEN COL=1:GOTO 13350
13080 IF C=30 AND ROW>1 THEN ROW=ROW-1:GOTO 13350
13085 IF C=22 THEN C=10:C$=CHR$(C)
13090 IF C=10 AND ROW<24 THEN ROW=ROW+1:GOTO 13350
13095 IF C=10 THEN PRINT C$;:GOTO 13355
13100 IF C=8  AND COL>1 THEN COL=COL-1:GOTO 13350
13105 IF C=28 AND COL<80 THEN COL=COL+1:GOTO 13350
13110 IF C=30 THEN ROW=1:COL=1:GOTO 13350
13115 IF C=12 THEN ROW=1:COL=1:CLS:GOTO 13350
13120 IF C<>27 THEN 13355
13125 '
13130 ' ESC sequence; read next character and come back
13135 '
13140 ESCSEQ=1:GOTO 13355
13145 ESCSEQ=0:IF C$<>"Y" THEN 13205
13150 '
13155 ' Repositioning cursor; now get row and column bytes
13160 '
13165 ESCSEQ=2:GOTO 13355
13170 ROW=ASC(C$)-31:IF ROW<1 OR ROW>24 THEN ROW=1
13175 ESCSEQ=3:GOTO 13355
13180 COL=ASC(C$)-31:IF COL<1 OR COL>80 THEN COL=1
13185 ESCSEQ=0:GOTO 13350
13190 '
13195 ' Handle cursor up
13200 '
13205 IF C$<>"A" THEN 13235
13210 IF ROW >1 THEN ROW=ROW-1
13215 GOTO 13350
13220 '
13225 ' Handle cursor down
13230 '
13235 IF C$<>"B" THEN 13270
13240 IF ROW <24 THEN ROW=ROW+1
13245 GOTO 13350
13250 '
13255 ' Handle cursor right
13260 '
13265 '
13270 IF C$<>"C" THEN 13300
13275 COL=COL+1:IF COL >80 THEN COL=1:IF ROW > 23 THEN ROW=24 ELSE ROW=ROW+1
13280 GOTO 13350
13285 '
13290 ' Handle cursor left
13295 '
13300 IF C$<>"D" THEN 13330
13305 COL=COL-1:IF COL <1 THEN COL=80:IF ROW > 1 THEN ROW=ROW-1 ELSE ROW=1
13310 GOTO 13350
13315 '
13320 ' Handle erase to end of page
13325 '
13330 IF C$<>"J" THEN 13355
13335 IF ROW<24 THEN PRINT SPACE$(81-COL);
13340 IF ROW<23 THEN FOR TROW=ROW+1 TO 23:PRINT SPACE$(80);:NEXT TROW
13345 IF ROW<24 THEN PRINT SPACE$(79); ELSE PRINT SPACE$(80-COL);
13350 LOCATE ROW,COL,1
13355 NEXT
13360 GOTO 515
40000 'Reset parity and Number of Data Bits on the Fly ********
40100 IF PAR$="N" AND DTA$="7" THEN NEWPD=2
40200 IF PAR$="E" AND DTA$="7" THEN NEWPD=26
40300 IF PAR$="O" AND DTA$="7" THEN NEWPD=10
40400 IF PAR$="M" AND DTA$="7" THEN NEWPD=42
40500 IF DTA$="8" THEN NEWPD=3
40600 OUT LCR,NEWPD
40700 RETURN
40800 DEF SEG=0
40810 JONES!=PEEK(&H46C)+256*PEEK(&H46D)
40820 STICKLE!=PEEK(&H46C)+256*PEEK(&H46D)
40830 IF STICKLE!<JONES! THEN STICKLE!=STICKLE!+65536!
40840 IF STICKLE!<(JONES!+EVWAIT!) THEN 40820
40845 ECNT=0
40850 RETURN
40900 IF DEDD<3 THEN EVWAIT!=10:GOSUB 40800:EVWAIT!=1:GOSUB 40800:DEDD=DEDD+1:GOTO 40910 ELSE RETURN
40910 IF NOT EOT THEN RETURN 4805 ELSE RETURN 4845
40950 IF DEDD<3 THEN EVWAIT!=10:GOSUB 40800:EVWAIT!=1:GOSUB 40800:DEDD=DEDD+1:GOTO 40960 ELSE RETURN
40960 PRINT:PRINT"***Re-sending block...";:PRINT #1,A$;:RETURN 4755
65000 PRINT "PC-TALK was originally written by Andrew Fleugelmen.  Later, Andy combined all": PRINT "the enhancements that people were writing for PC-TALK into the latest official"
65010 PRINT "version, PC-TALK III.  Again, numerous improvements have been made by various": PRINT "people:": PRINT
65040 PRINT "                   Wes Meier      Ctrl-Home Split Screen                                           Jim Gainsley    Alt-H   Hang-Up Modem                                                           Alt-Q   Redail
65050 PRINT "                   John Chapman    Alt-G   Get New Directory                                                       Alt-I   Load Keys 1-0 from file                                                 Alt-U   Save Keys 1-0 to file
65060 PRINT "                   Jack Wright     Alt-V   Original Show Free Space                                Leroy Casterline        PCFixLC1 & 2 appends account numbers                                            to phone numbers for Sprint & MCI
65070 PRINT "                   Kent Galbraith  Alt-A   3101 Emulation":PRINT
65071 PRINT"Naturally, you should not call Andy about problems with these mods, since they": PRINT "are unofficial.  One good place to go for help is the IBM SIG on CompuServe."
65072 PRINT"Remember to send in your payment for the original PC-TALK!"
65080 PRINT: PRINT "(Press Enter to continue.)";
65090 IN$=INKEY$: IF IN$="" THEN 65090 ELSE CLS
65150 RETURN
```
{% endraw %}

## BBS-TALK.DOC

{% raw %}
```
                      BBS-TALK.MRG Documentation

                       
     BBS-TALK.MRG represents a commendable effort by Dorn Stickle to bring
together a large number of merge files into one giant merge for PC-TALK III.
Dorn took several merges written by different authors, combined it with
his own 450BAUD.MRG and his new file for finding the amount of unused
space on a diskette, and then resolved all the line number conflicts 
between the various merges and the original PC-TALK Version 3.0 Level 830424.
BBS-TALK.MRG incorporates:

    3101CMW.MRG (Windows, Music & color graphics)
    ANSI.MRG    (redundant with 3101CMW.MRG)
    PCFIXLC1.MRG (Appends account # for Long Distance Dialing service)
    PCFIXLC2.MRG (ALT-H for hang-up modem after connection)
    PCTSPLT.MRG (Split screen input option on line 25 of your screen:
                 sends your input a line at a time with ENTER key)
    TALK450.MRG (ALT P for 450 baud option)
    PCT-365.MRG (PC-TALK version 3.65) Shift Tab to set/clear ALT 1 - 0
                                       temporary input string storage.
                                       ALT-I load ALT 1 to 0 from a file
                                       ALT-U unload ALT 1 to 0 to a file
                                       Improved ALT-H hang-up modem
                                       REDIAL routine rewritten
                                       ALT-G path and subdirectory support
                                       Manual dialing allows new comm parameters

     Please note: 3101CMW.MRG automatically provides the user with the
ability to view RBBS-PC bulletin board color graphics and music.  Plus
for those Bulletin Boards with WINDOW capability, the user selects the
W)indow option on the Bulletin Board and then ALT A to switch to 3101
mode for using Windows and then toggle ALT A after exiting from Windows.
Do not toggle ALT A unless you are using the Bulletin Board Window feature.

     After BBS-TALK has dialed a number, any key will disconnect the modem
up to the time the carrier-detect signal is received and you are
connected to the remote computer.  After connection, use ALT H to hang up
the modem; the program will try 4 times to hang up, then recycle.

     The split screen option <CONTROL-HOME> activates line 25 on your
screen, and rather than sending data one char at a time, accumulates your
input on line 25 and waits for the <ENTER> key before sending a stream
of data to the remote computer. 

     The ALT I option will allow you to upload a file from your disk to
temporary string storage in one of the ALT 1 to ALT 0 keys (for later
sending a long message to a remote computer).  The ALT U option then
allows you to download a string you previously stored (with ALT I) to
the remote computer.  You will need carriage returns in your file.
The ALT U option is inconsistent with the split screen option, because
the split screen option is looking for the ENTER key to begin sending
date to the remote computer, while the ALT U option is typically used
to send a series of data lines to be entered as a MESSAGE on the remote
Bulletin Board.  <SHIFT-TAB> sets/clears temporary ALT key strings.

     <ALT-G> allows you to change sub-directories on your hard disk
for uploading or downloading data.  However, if you are running PC-TALK
off of your hard disk, you will need to change back to the sub-directory
containing the PC-TALK program after you are finished, or you could
hang up your computer if PC-TALK attempts to cycle back to its own file.

     To use the 450 baud option, you must first call the Bulletin Board
at 300 baud, then after signing on, select the 450 baud option on the
Bulletin Board menu, and when prompted, select ALT P to change to 450 baud.
The Bulletin Boards cannot answer at 450 baud, only 300 and 1200 baud.

     BBS-TALK.MRG already contains the above mentioned merges, and most
importantly, Dorn Stickle has resolved all line number conflicts between
the various merges and a virgin copy of PC-TALK.BAS from Andrew Flugleman
(NOT the QUBIE-modified version for QUBIE modems).  BBS-TALK will only run
in the compiled version because of the machine-language object modules
required by the LINK command below.

     Start with a virgin copy of PC-TALK.BAS (Line 9999 shows 830424)
and BBS-TALK.MRG and make sure both are saved in ASCII:
BASICA <ENTER> LOAD "BBS-TALK.MRG <ENTER> SAVE "BBS-TALK.MRG",A
Then merge the two files together using the BASIC MERGE command, and
compile and link in this manner:

   BASCOM PC-TALK/e/w/s/c:4096/o;

   LINK   PC-TALK+IBMCOM+DISKSPAC+GETDIR+CHDIR

To do the linking you will need the following object modules:
                   
                   IBMCOM.OBJ    (comes with the BASIC compiler)
                   DISKSPAC.OBJ  (New file by Dorn Stickle: ALT-R then
                                 ? <ENTER> for space remaining on disk
                                 or use ALT T or ALT V and ? <ENTER>)
                   GETDIR.OBJ    (supports PATH commands DOS 2.x)
                   CHDIR.OBJ     (change sub-directories on hard disk)

Authorship and commendations:

   PC-TALK.BAS  Version 3.0 Level 830424 Andrew Fleugelmen
                                         The Highlands Press
                                         PO Box 862
                                         Triburon, CA  94920
   
   3101CMW.MRG   Kent Galbraith, Kingwood, TX

   PCFIXLC1.MRG  Leroy Casterline, Fort Collins, CO
   PCFIXLC2.MRG  Leroy Casterline (modified by Jim Gainsley)

   PCTSPLT.MRG   (PCT3SC.MRG) Wes Meier, Walnut Creek, CA

   TALK450.MRG   Dorn Stickle, Dallas, TX
   DISKSPAC.OBJ  Dorn Stickle, Dallas, TX

   PCT-365.MRG   Jim Gainsley, Minneapolis, MN

   GETDIR.OBJ    John Chapman, CIS 70205;1217
   CHDIR.OBJ     John Chapman

   Plus countless hours spent by a large number of people devoted to
the free exchange of public domain software, who are unknown to us
or who have expended effort on earlier versions, revisions and merges,
including Jack Wright, who did the original code for finding unused
disk space remaining, and countless others who have contributed one
way or another, like Charles Innusa.

   Dorn Stickle made an attempt to incorporate the PCT3JR.MRG for
IBM PCjr, but this program is too large to fit in the approximately
70K partition left in the 128K-sized PCjr.  Dorn is working on down-
sizing this program, with the PCT3JR.MRG sized for the PCjr, as a
separate program.



                                    Typed by Greg Rismoen



July 17, 1984
Houston, Texas

After consultation with Kent Galbraith, I changed the compiler codes
in the above documentation. Also, I made certain minor changes to clarify
the documentation. 

                                     Duane C. Hendricks
```
{% endraw %}

## FILES335.TXT

{% raw %}
```
------------------------------------------------------------------------
Disk No 335  Mods for PC-TALK                                   v1   DS
------------------------------------------------------------------------
 
This disk contains BBS-TALK.EXE [and various support programs]  BBS-TALK
adds functions to PC-TALK v3.0 level 830424.  The functions are detailed
in BBS-TALK.DOC
 
BBS-TALK DOC  Details added functions to PC-TALK v3.0, level 83024 and
              tells how to create BBS-TALK.EXE from scratch.
BBS-TALK EXE  Executable PC-TALK including new functions
BBS-TALK MRG  Basic [Ascii format] file when merged with PC-TALK v3.0
              level 83024 creates BBS-TALK basic source file to compile.
CHDIR    OBJ  Object file linked with BBS-TALK to change sub-directories
              on hard disk.
COMPILE  BAT  Batch file to automatically compile and link BBS-TALK.EXE
DISKSPAC OBJ  Object file to link with BBS-TALK to give space remaining
              space on disk
GETDIR   OBJ  Object file linked witn BBS-TALK to support PATH commands
              for DOS 2.x
SPD      COM  Put in your autoexec.bat file and run with BBS-TALK.  Speeds
 
 
PC Software Interest Group (PC-SIG)
1030 E Duane, Suite J
Sunnyvale, CA 94086
(408) 730-9291
```
{% endraw %}

## PCT-XMOD.DOC

{% raw %}
```
PCTRLX.DOC               9/22/84          DOCUMENTATION FOR PCTRLX.MRG
 
              MERGE FILE FOR PC-TALK III, LEVEL 830424.
 
  May also be used with PC-TALK III which has been modified with any
     of the following master Merge programs: PCT365, 366, 3661.
 
 
PCTRLX.MRG when merged with PC-TALK 3, will provide significantly
superior performance during XMODEM file transfers on networks such as
CompuServe.
 
This file is a pre-release module from a master Merge file PCT37.MRG,
which contains many more enhancements for PC-TALK 3.
 
This module is being released ahead of PCT37, because of the problems
encountered in using the current PC-TALK 3 XMODEM implementation with
CIS' newly supported XMODEM transfer protocol.
 
The current implementation in the distribution version of PC-TALK was
designed to support mainly single user communications, such as are
encountered in PC to the typical BBS, which is usually a single PC with
BBS, RBBS, IBBS, etc. software.
 
A major difference in a large network environment is the delays in
what would otherwise be a continuous data exchange. These delays are
the result of packet or other switching techniques, by which the
network can serve perhaps thousands of simultaneous users at the
'same' time.
 
The implementation provided by PCTRLX.MRG is designed to work around
network switching. It also alters the original PC-TALK Xmodem protocol
in 3 major ways:
 
1)   The currently recommended XMODEM protocol is entirely RECEIVER
     DRIVEN. This was not true of the original protocol, nor of the
     PC-TALK implementation. This Merge file provides that feature.
 
2)   The RECEIVER can now control the timing of block transmissions,
     both at the beginning of the transfer and interactively during
     the transfer. Additional and as an aid to the user in modifying
     timing, screen printouts of the actual times is now given.
 
3)   The original protocol provided that errors be tried 10 times.
     This modification alters that to 20 times.
 
 
OPERATION:
 
Receive:
 
     Open your file as previously. If you simply use '=x', the block
     timing will be 4 seconds as before.  You may enter a number
     between 2 & 70 in format: '=x10' or '=x4', which would then set
     the block timing at 10 seconds or 4 seconds per block.
 
     As the transfer proceeds, the screen will show the time per
     block, the avg. time per block, and the max time for the longest
     transfer of a block up to that point.
 
     If the current time in effect is less than the max time shown,
     then the user should change the current timing. This is done by
     pressing the TAB key and entering 2 digits from 2-70, in the
     manner 06, or 20 etc. It is also ok to enter one digit and a
     space.  DO NOT press <cr>.
 
     The new timing takes effect immediately after the keyboard
     receives the second character.  When the TAB key is pressed the
     screen will print out 'ct=xx 'Enter (02-70)'. When the new time
     is entered, then 'nt=xx' is indicated.
 
     NOTE: THE XFER WILL HALT UNTIL THE SECOND CHARACTER OF THE NEW
     TIME STRING IS ENTERED. DON'T DALLY!!
 
     The default is 4 seconds. The default will be put into effect if
     an invalid time is entered. The screen will also indicate 'INVL:
     No Chg'
 
     Though experience with the new timing is limited, I have found
     that the timing should best be set at about 4 seconds over the
     max shown, when working with networks, and at about 1-2 seconds
     over the max shown when working with BBS'.
 
     The major problem with setting block timing too long is the
     chance of getting line garbage, necessitating a retry for the
     block.
 
     WHILE THE OVER-TIMING IS NOT CRITICAL, ONE SHOULD MAKE AN ATTEMPT
     TO KEEP REASONABLY WITHIN BOUNDS, BUT SHOULD NOT FEEL COMPELLED
     TO CONTINUOUSLY CORRECT THE PROGRAM!!
 
     Nothing is lost if you see a time that is greater than your
     current setting, after all the block did make it. It is future
     blocks where your concern lies, and to guard against problems
     with them, you increase the timing a bit.
 
     Nothing in these changes alters in any manner the error checking
     features of the protocol.
 
     Error blocks and situations will now be retried 20 times,
     provided the sender allows it.
 
 
Transmit:
 
     There is no user interaction in the transmit mode and no changes
     in procedure from previous. Note however, that now in the send
     mode, this program will NOT send a block until the receiver
     requests it.
 
As stated above these changes are new, and even though a good deal of
testing has been done, they are still of an experimental nature and
other changes may follow. However, what is presented here is most
definitely a considerable improvement over what is currently in place.
 
 
 
yy: Jim Gainsley (SysOp)  [76703,1007]
    CIS IBMPROSIG  PCS-131

```
{% endraw %}

{% comment %}samples_end{% endcomment %}

### Directory of PC-SIG Library Disk #0335

     Volume in drive A has no label
     Directory of A:\

    BBS-TALK DOC      7040   7-17-84   1:17a
    BBS-TALK EXE    103808  10-14-84   7:16a
    BBS-TALK MRG     32870  10-09-84   6:59p
    SCRSUB   OBJ       163  11-28-83  12:00p
    DISKSPAC OBJ       128  10-10-84  11:52a
    READ     ME        604   9-02-84  10:24a
    SPD      COM       128   7-17-84   1:36a
    COMPILE  BAT        95  10-09-84   7:12p
    BBS-TALK BAS     62412  10-13-84   9:57p
    CHDIR    OBJ       512  10-10-84  11:53a
    GETDIR   OBJ       512  10-10-84  11:53a
    IBMCOM   OBJ      3200   1-01-80  12:02a
    PCT-XMOD DOC      5043  10-17-84   9:41a
    FILES335 TXT      1408   5-23-85   1:57p
           14 file(s)     217923 bytes
                           96256 bytes free
