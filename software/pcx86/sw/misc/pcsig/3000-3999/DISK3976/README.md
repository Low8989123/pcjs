---
layout: page
title: "PC-SIG Diskette Library (Disk #3976)"
permalink: /software/pcx86/sw/misc/pcsig/3000-3999/DISK3976/
machines:
  - id: ibm5170
    type: pcx86
    config: /machines/pcx86/ibm/5170/cga/1024kb/rev3/machine.xml
    diskettes: /machines/pcx86/diskettes.json,/disks/pcsigdisks/pcx86/diskettes.json
    autoGen: true
    autoMount:
      B: "PC-SIG Library Disk #3976"
    autoType: $date\r$time\rB:\rDIR\r
---

{% include machine.html id="ibm5170" %}
{% comment %}samples_begin{% endcomment %}

## CDROM.TXT

{% raw %}
```
T h e  P C - S I G  L i b r a r y  o n  C D - R O M,

                1 2 t h E d i t i o n



++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

The PC-SIG Library on CD-ROM, winner of the Optical Publishing
Association's Best Consumer Product Award, has added a hypermedia
interface that makes it easy to find and download any type of program
you could want. The WordCruncher text retrieval program has also been
implemented to assist you insearching this vast collection.

This CD-ROM contains over 3700 fully functional shareware programs, each
with a detailed review. The 12th Edition has added over 300 new programs
and over 500 updates since the release of the 11th Edition. The
collection is always kept current and now contains over 70 megabytes of
Windows 3.0 and 3.1 applications, fonts, icons, games and wallpaper
files.

The range of software is phenomenal! There are huge assortments of
games, everything from adventure games with full SVGA and SoundBlaster
support to favorites like Klondike, Chess and Othello. Spreadsheets,
databases, wordprocessors and graphics programs are instantly available
and there are literally hundreds of unique and specialized programs that
will save you time and money. This amazing collection will help you get
a handle on all your business and home accounting and also teach your
children about zoology.

Each of the more than 3700 programs has a one-line description for quick
reference, Just pick one of the 13 software categories and a subcategory
to begin browsing for a program that interests you. You might choose the
Games Category, where you can pick from 12 subcatgories including
Adventure, Arcade, Cards and more. A mouse click (or keyboard stroke) on
the program title takes you to a detailed description of the program.
you can immediately download the software to your hard or floppy drive,
and in many cases view a screen shot.

You can find any program in the collection quickly and easily by using
the search button. When you are in a program category just type in the
title of the program and you will be taken to the description of that
program. The popular WordCruncher text retrieval program has been added
to allow searching every description for any word within that
description, not just in the title or keywords chosen by someone who
thinks differently than you do. The WordCruncher is ideal for finding
programs which perform a specific function, just try searching for
"split", "math" or "subtract". Or switch to the Disks section where you
will find an alphabetical list of all the programs which can be searched
by program title or disk number.

Everyone has their favorite programs and we're no exception. Our 44
favorite programs can be run immediately. No downloading is necessary,
all you do is click on the word "RUN" in the program description and
you'll be working or playing with top notch software right on the CD.

The power of hypermedia will allow you to try out more software than you
ever thought possible. We are sure that you will find a multitude of
programs to your liking on the P-SIG Library on CD-ROM.

System Requirements: IBM PC/AT PS/2 or compatible with 640K, DOS 3.3 or
higher, Microsoft MS-DOS CD-ROM Extensions and a CD-ROM player. We
recommend a 386 with a VGA monitor.










T h e E s s e n t i a l H o m e & B u s i n e s s C o l l e c t i o n
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

"Never before has such a valuable collection of popular shareware been
compiled on one CD-ROM that everyone can afford." Dr. File Finder a.k.a.
Michael Callahan

Finally, 368 of the most useful, popular, important shareware programs
have been put together on one CD. No matter what your need, it's on The
Essential Home & Business Collection.  Everything from Administration to
Windows software is here.

The Essential CD incorporates the WordCruncher text retrieval system.
Every program on the disc is indexed by title, filename, PC-SIG disk
number, and every word in the program description.  A new utility, Narc,
is implemented so you can look at the program files and the author's
on-line documentation without having to first copy the program to your
hard disk.  By using WordCruncher and Narc, you can quickly find the
program you want and review it to be sure, without ever having to run it
from your hard disk.

If you've got a CD-ROM player at home and want to get more use of it and
your computer, or if you're trying to avoid purchasing another Nintendo
cartridge, or if you just enjoy looking at new software, you need The
Essential Home & Business Collection.

System Requirements:

IBM PC/XT/AT PS/2 or compatible with 384K memory DOS 3.1 or higher and
Microsoft MS-DOS CD ROM extensions.


T h e  P C - S I G   G a m e s    C D - R O M
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Now you can play a game a day fo over a year.  This CD-ROM is jammed
with over 380 shareware games of all types, designed to appeal to the
new generation of CD-ROM users out for fun.  The CD incorporates a
hypermedia interface and allows 250 of the games to be played directly
from the CD-ROM.

The hottest games in shareware are on this disk, including the
action/arcade games "Jill of the Jungle" and "Wolfenstein 3D," which
rival or surpass commercial PC and Nintendo for use of animation,
SoundBlaster audio, and VGA graphics.  There are also games designed to
teach children mathematics, spelling and even ecology.  All these games
for less than a dime each!

Over 250 of the games can be played directly from the CD without copying
them to a floppy or a hard drive.  Being able to run from the CD means
that users can explore games without using up valuable hard disk space
or spending time downloading and deleting files.  The hypermedia
interface makes it easy to browse the titles, read a one line
description or full review, and copy or start a game by clicking the
mouse or using the keyboard.

T h e   P C - S I G   W o r l d   o f   G a m e s   C D - R O M
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

The new PC-SIG World of Games CD-ROM contains over 550 of the best
shareware games, including 53 educational games for children and 57
Windows games. 430 of them can be played directly from the CD without
using your hard drive space.

This edition employs the award-winning HyperReader interface, allowing
easy searching and playing by using a mouse or the keyboard.

This CD is the first in a six-volume PC-SIG Encyclopedia of Shareware
series. Each volume will include the programs from a section of the
PC-SIG collection and also the programs and text from the current issue
of Shareware Magazine. This CD contains the entire text from the
May/June issue of Shareware Magazine, featuring hardware reviews of
the Tandy Sensation and the Media Vision Pro 16 Multimedia System.
Software reviews included cover 58 new shareware releases, security,
educational, CD audio and PIM's. 159 of the programs mentioned in the
magazine are included and can be downloaded using the HyperReader
interface.

There are also 89 programs which were updated since the last issue of
Shareware Magazine, helping those of you who have purchased the 12th
edition of the PC-SIG Library keep on top of the everchanging world
of shareware.

As well, a description of every program in the PC-SIG Library can be
searched with the WordCruncher text retrieval program. This Games CD
continues the ten year PC-SIG tradition of providing quality programs
and information to help you find the best program for your purpose.

System Requirements: IBM PC/AT/PS/2 or compatible computer with 640K,
DOS 3.3 or higher, Microsoft MS-DOS CD-ROM Extensions and a CD-ROM
player. We recommend a 386 with a VGA monitor.



To Order in the U.S.A.: Call 800-245-6717 and ask for Customer Service.

For Technical information: Call 408-730-9291 and ask for Technical
Support

Outside the U.S.A.: Call (408) 730-9291 for the name of the dealer near
you.
```
{% endraw %}

## EDITORS.DOC

{% raw %}
```


***************************************************************************

                                EDITORS.DOC
                             ObjectEase 2.0
          (c) Copyright 1992 - David S. Reinhart Associates

***************************************************************************


        This document serves to briefly describe the functions of the 
two editors included with the ObjectEase library, 16IMAGE.EXE and
256IMAGE.EXE. These programs are used for creating 16 color and 256
color bitmap images respectively. The files are created and saved in
the format used by the Borland function getimage().

        You must first have a mouse driver loaded to utilize these
editors. The drawing tools should all be intuitive. If not, a little
experimentation should provide you with all the explanation you will
need. Use the left mouse button in each editor to select the foreground
color and the right mouse button to select the background color. The 
only function that may not be intuitive is how to save the bitmap images 
you create.

                             16IMAGE.EXE

        Using the 16 color image editor, select the scissors tool. Press
the left mouse button with the cursor positioned at the upper left        
corner of the image you wish to capture. With the left mouse button 
depressed, drag the mouse downward and to the right until the image is fully
enclosed in the rectangle. When you release the left mouse button a window
will appear in the upper right corner of the screen, prompting you for
a file name. You can give the file any extension you like.

                             256IMAGE.EXE

        Using the 256 color image editor, select the "rubber band" tool.
Press the left mouse button with the mouse cursor at the upper left
corner of the image to be captured. With the left mouse key depressed
drag the mouse downward and to the right until the image is fully
enclosed in the rectangle. When you release the left mouse key, the file
name box at the bottom of the screen will become active. Enter a filename
and press <ENTER>. The default extension ".CUT" will ba added, however, you
may change this to any desired extension as the Bitmap class member
functions do not rely on a particular file extension as do the Icon and
Button classes.


        Note that using either editor, you cannot capture an image which
constitutes more than 64K. This is the maximum size of a Borland getimage() 
buffer.
```
{% endraw %}

## ICONEDIT.DOC

{% raw %}
```



                                  ICONEDIT
                                (and VGAEDIT)

        ICONEDIT was born out of the necessity to create small graphic 
images for use with the ObjectEase library objects, namely, buttons and icons.
It was always meant to be nothing more than a developer's tool, not a full 
blown graphics tool by any means. It serves its function with a minimum of 
bells and whistles, but quite effectively all the same.

        The controls in ICONEDIT give the user the ability to:

                1. Choose between button or icon image editing.
                2. Shift the entire image within the editing area in any 
                        direction.
                3. Copy 'cels' for easy creation of animation sequences 
                        within icons.
                4. Select individual 'cels' for editing.
                5. Play back the animation as a repeated sequence or as a 
                        back and forth sequence. For instance 1->10,1->10...
                        or 1->10,10->1...
                6. Save the images for use with the ObjectEase library 
                        functions.

        Start the ICONEDIT program by entering ICONEDIT on the DOS command 
line. Use the two animated icons on the control panel to select whether you
will be editing an icon or a button. Icon editing is the initial default 
mode. Whenever you switch between the different editing modes the editing 
area is redrawn to reflect you choice. Note that this mode change is made 
with no warning of any unsaved files. Be sure to save your work before 
switching to a different editing mode.

        Color selection can be made at any time by moving the mouse pointer
to the desired color on the color bar and pressing the left mouse button. 
To color any pixel of the image, move the mouse cursor to the appropriate 
location within the editing area and press the left mouse key. Continuous 
drawing can be done by holding down the left mouse key as you move the 
mouse cursor around the editing area.

        There are six different buttons with arrows on them in the control 
panel. Each of the single headed arrows will shift the entire editing area 
one pixel in that direction. The row or column of pixels that is shifted 
off of the end is moved to the beginning row or column. The double headed 
arrows will flip or mirror the entire editing area.

        The COPY button and the two animation buttons are only active while
editing an icon. After creating the first 'cel' of your animation use the 
COPY button to copy the image to 'cel' number two. The FRAME SELECTION 
panel on the main control panel shows at all time how many 'cels' are in 
the current animation sequence, and which of these is the current active 
'cel'in the editiong area. All of the 'cels' in the animation are shown 
in blue, and the active 'cel' is highlighted in red. Once you have copied 
one 'cel' to the next, simply move the mouse cursor to the number of the 
'cel' you wish to modify in the FRAME SELECTION panel and press the left 
mouse key, The newly selected frame will be displayed in the editing area. 
Keep in mind that at this point it is still exactly the same as the 
previous frame. You must now make any necessary changes to the image to 
create the illusion of animation. After making modifications to this 'cel', 
copy it to the next 'cel', repeating this process until you have finished 
all of the frames in the animation sequence. 

        You can preview the animation at any point by pressing one of the 
two animation control buttons on the main control panel. Once selected, two 
additional button will appear labelled "FASTER" and "SLOWER." Use these 
buttons to change the speed of your animation. For your reference when 
including these icons in your programs, the initial delay speed when 
previewing is 3 and pressing either FASTER or SLOWER increases or decreases 
the current value by one. To stop the animation and return to editing mode
either press the right mouse key or any key on the keyboard.

        Use the two buttons at the top of the control panel to SAVE and 
RESTORE your images. When saving or restoring DO NOT give your filename 
an extension. File extensions are appended by ICONEDIT and are .BTN and 
.ICN for buttons and icons respectively. No menu of available images is 
given so you will have to know the name of the file you want to retrieve 
or press <ESCAPE> to end the retrieval.

        You can experiment with the buttons and icons which are part of
the ICONEDIT program. All of these files are in the same directory as the
executable code. The icons used are ICON.ICN and BUTTON.ICN. You can 
recognize the many buttons used by their .BTN extension.

        That's all there is to it in a nutshell. The saved images you 
create are in proper form to be used by the functions in the ObjectEase 
library. I continually make improvements to this program as my needs 
change, and registered users of the ObjectEase library will receive the 
updated ICONEDIT program along with the ObjectEase library updates. Your 
suggestion for improvements are welcomed as well.


                               VGAEDIT

        VGAEDIT is a much simpler program than ICONEDIT. It also serves
to create button and icon images, this time though for the 320x200 256
color graphics mode. You cannot create animated icons with VGAEDIT at 
this time. Also, there is no distinction within the program as to whether
you are creating a button or an icon. In this particular mode these two
objects are the same size so no distinction is needed. The files are saved
by default with the ".BTN" extension. If you are going to use the image
as an icon be sure to change the extension to ".ICN". Choose a drawing 
color by moving the cursor to the color bar at the top of the screen and
then carefully sliding it back off of the bar once positioned on the 
desired color. You can also select a color by positioning the mouse cursor
over a previously colored square and pressing the right mouse button. This
will effectively "pick up" that color.


```
{% endraw %}

## OBJEASE.DOC

{% raw %}
```



			      ObjectEase v2.0

	      (c)Copyright 1992 - David S. Reinhart Associates
		  1004 Marticville Rd. Pequea, PA  17565
			      (717) 284-3736



	The ObjectEase libraries are for use with any and all versions
of Borland's C++ compilers. 




				  Welcome

	Welcome to the world of object oriented programming.  Welcome to 
the world of ObjectEase!  The ObjectEase library of C++ classes and 
member functions is going to do more for your programming efficiency 
than any other library, book, video tape, or any other learning tool or 
tool kit that you could purchase!  Guaranteed!   There is no learning 
curve involved in using this library.  All of the classes are intuitive.  
You've been using them in someone else's programs for years, but you've 
just never been able to duplicate them in your own.  Not because you 
don't have the programming skill, but because you didn't want to waste 
time developing tools when you could spend your valuable time developing 
a completed project. I, on the other hand have always been fascinated 
with the tools that are used to piece together a successful application, 
and that is what I have spent my time perfecting.  Now you can exploit 
the work that I have already done by harnessing the power of the tools 
that are contained in the ObjectEase class library!

	What is the prime advantage that we keep hearing about OBJECT 
ORIENTED programming?  That's right... OBJECTS that can be pieced 
together in various ways to form different applications.  Predefined 
objects that YOU put together in whatever way you desire to produce your 
programs.  You don't have to re-code anything.  Just include the 
ObjectEase library in your project file and use these objects over and 
over to produce PROFESSIONAL QUALITY, HIGHLY RESPECTED applications.

	Enough said!  If you haven't already done so, stop reading right 
now and run the demo programs that have been provided.  The demos are 
called TUIDEMO.EXE, GUIDEMO.EXE, and VIDDEMO.EXE and are in the 
directory in which you have unpacked the ObjectEase DEMOS.ZIP files.  
This is the quickest and easiest way to see for yourself the QUALITY, 
EASE OF USE and POWER that YOU inherit through object oriented programming 
using the ObjectEase library! Go ahead... try it now!!!




			     Meet The Objects

	There are 23 object classes in this library.  "Only 23," you 
ask...  Well, combined these 23 classes have over 500 member functions 
that give you TOTAL control.  I dare say you will NEVER have the need to 
use all 23 classes in the same application.  Some are exclusively for 
text mode use, some for graphics mode.  Some to make things easier for 
you, the programmer.  Some to make life easier for the end users of your 
programs.  You will know, instinctively, which objects to use and in 
which situations.  Let's take a look now at the objects, and later we'll 
define all of the member functions for each.





TEXT MODE OBJECTS

Twindow         Pop up window object
Tmenu           Point and shoot type menu object
Tstring         String input object
Tnumeral        Numeral (int,long,float) input object
Tdate           Date input object
Tbutton         Pushbutton object
Tcheckbox       Checkbox object


GRAPHICS MODE OBJECTS

Point           The base object for all other graphics objects
Gstring         Graphics mode string input object
Colorbutton     A generic object useful for such things as color
		  selection bars, as in paint programs
Icon            Icon object used as a selection tool
Acticon         Animated icons. Really! It's great!!!
Gcheckbox       Graphics version of the checkbox object
Gradio          Graphics mode radiobutton control
Button          Graphic pushbuttons with both text and graphics
Bitmap          Bitmap image object
Panel           Sort of a graphics popup window object
Bevel           Fancier version of the panel object
Gmenu           Graphic pulldown menu
Gmenubutton     Used to create a graphics mode menu bar
Screen          Object determining the current mode and appearance
			of the video screen

BI-MODAL OBJECTS

Mcursor         The mouse cursor
SoundQ          Sound queue for playing music and sounds in the
			background while other things keep happening in the
			foreground                      


	These objects provide you with all the power you need to quickly 
piece together applications without wasting your time creating the 
visual "tools" which control the program flow.  The tools are all here, 
you just code in the appropriate reaction for every action!

	With this brief overview in hand, let's dive deeper into the world 
of each of these objects. Let's find out what makes them tick, and how 
YOU can control their every action.


				 PART 1       

			    TEXT MODE OBJECTS

	Probably the vast majority of any programmer's work has been done 
in the text mode, whether 80 or 40 column mode.  Most of the tools used 
have been part of the standard library of functions supplied with the 
compiler, if any!  Now you've got a new arsenal of tools which are as 
powerful to employ as they are easy to implement.

	NOTE: These classes and member functions are supplied in the fol-
lowing files:
	TUI_S.LIB - Small memory model library
	TUI_L.LIB - Large memory model library
	TUI.H     - Header file

	See the source code for TUI.CPP for more examples of their use.

Twindow

	What program comes without at least one of these familiar fellows?  
The popup window, useful and attractive for displaying and framing just 
about any piece of information on the screen.  Sure, there are many C 
libraries available for producing popup windows, but that's about all 
they do!  And they don't do it with the ease and power available through 
object oriented programming and the ObjectEase library!


Twindow::Twindow()
	The default constructor.


Twindow::~Twindow()
	The destructor.  Frees any and all memory associated with the
	window.  Note that destructors are never directly callable.


void Twindow::init(int xpos,int ypos,int x1pos,int y1pos,int fore,
	int back,int shadow,int shadowcolor)
	
	The toughest function call you'll ever have to remember.
	xpos - the upper left x coord of the window.
	ypos - the upper left y coord of the window.
	x1pos - the lower right x coord of the window. (NOT THE WIDTH)
	y1pos - the lower right y coord of the window. (NOT THE HEIGHT)
	fore - the foreground color used for drawing the lines.
	back - the background color of the window.
	shadow - 1 or 0. 1 represents the window has a shadow, 0 means
	no shadow.
	shadowcolor - 0 to 15 representing the color that any underlying
	text that is in the shadow region will be shown as.  If there is 
	no shadow this color should be 0. 

	example:        Twindow mainwindow;
				mainwindow.init(10,5,71,20,14,4,1,9);


void Twindow::show()
	Displays the window on the screen.  All underlying images are
	saved so that the screen can later be restored.

	example:        Twindow mainwindow;
				mainwindow.init(10,5,71,20,14,4,1,9);
				mainwindow.show();


void Twindow::zoom()
	Displays the window on the screen, but with a "zoom" effect rather 
	than an "all at once" approach.  Again, all underlying screen 
	information is automatically saved.




	example:        Twindow mainwindow;
				mainwindow.init(10,5,71,20,14,4,1,9);
				mainwindow.zoom();

void Twindow::hide()
	Removes the window from the screen restoring the portion of the
	screen which was obscured by the window.  Calling Twindow::hide
	does not destroy the window.  The window can be re-shown at any
	time as long as it is still in scope.

	example:        Twindow mainwindow;
				mainwindow.init(10,5,71,20,14,4,1,9);
				mainwindow.show();      //display the window
				getch();
				mainwindow.hide();      //remove the window
				getch();
				mainwindow.show();      //redisplay the window


int Twindow::getborder() 
	Returns the border style of the window.  The styles DOUBLE and
	SINGLE are predefined in the header file.  SINGLE is the default
	style unless otherwise specified.

	example:        Twindow mainwindow;
				mainwindow.init(10,5,71,20,14,4,1,9);
				mainwindow.show();
				if(mainwindow.getborder()==DOUBLE)
					printf("Double border");


void Twindow::fill()
	Fills the window with its current background color effectively
	erasing anything that was shown in the window.

	example:        Twindow mainwindow;
				mainwindow.init(10,5,71,20,14,4,1,9);
				mainwindow.show();
				getch();
				mainwindow.wprintc(3,14,4,"Hi");// Print in 
									// window  
				getch();
				mainwindow.fill();


void Twindow::border()
	Forces a redraw of the window's border.  Must be called after
	the border style is changed.

	example:        Twindow mainwindow;
				mainwindow.init(10,5,71,20,14,4,1,9);
				mainwindow.show();
				mainwindow.setborder(DOUBLE);   //border is now 
									//double
				mainwindow.border();            //must call to 
									//show double 
									//border 

int Twindow::setborder(int style)
	Sets the current border style of the window to SINGLE or DOUBLE.
	The new border style will not be shown until you call 
	Twindow::border to redraw the window border.
	
	see example for Twindow::border() 


void Twindow::cfgd(int fore)
	Changes the window's foreground color to that specified in the
	fore parameter.  The border (and only the border) is
	automatically redrawn to reflect the new color.
	
	example:        Twindow mainwindow;
				mainwindow.init(10,5,71,20,14,4,1,9);
				mainwindow.show();
				getch();
				mainwindow.cfgd(15); fgd is now color 15


void Twindow::cbgd(int back)
	Changes the window's background color to that specified in the
	back parameter.  The background is automatically redrawn in the
	new color, effectively erasing anything that was in the window.
	
	example:        Twindow mainwindow;
				mainwindow.init(10,5,71,20,14,4,1,9);
				mainwindow.show();
				getch();
				mainwindow.cbgd(0); bgd is now color 0


int Twindow::getfgd()
	Returns the integer value of the window's current foreground
	color. 
	
	example:        Twindow mainwindow;
				mainwindow.init(10,5,71,20,14,4,1,9);
				mainwindow.show();
				if(mainwindow.getfgd()==14)
					printf("The color is yellow");


int Twindow::getbgd()
	Returns the integer value of the window's background color.
	
	example:        Twindow mainwindow;
				mainwindow.init(10,5,71,20,14,4,1,9);
				mainwindow.show();
				if(mainwindow.getbgd()==4)
					printf("The background is red");


void Twindow::divider(int direction,int style,int offset)
	Creates a divider in the window in the direction of the
	direction parameter, with the style of the style parameter and
	offset spaces in from the top or left, depending on the
	direction.  Use the predefined HOR and VER to represent
	direction and SINGLE and DOUBLE to represent style.
	
	example:        Twindow mainwindow;
				mainwindow.init(10,5,71,20,14,4,1,9);
				mainwindow.show();
				getch();
				mainwindow.divider(HOR,SINGLE,3); 


void Twindow::title(char txt[15])
	Displays a title on the window in the upper left corner.
	
	example:        Twindow mainwindow;
				mainwindow.init(10,5,71,20,14,4,1,9);
				mainwindow.title(" MAIN ");
				mainwindow.show();


int Twindow::isshown()
	Returns 1 if the window is currently displayed on the screen, 0
	otherwise.

	example:        Twindow mainwindow;
				mainwindow.init(10,5,71,20,14,4,1,9);
				if(!mainwindow.isshown())
					mainwindow.show();


int Twindow::isx()
	Returns the integer value of the upper left x coord


int Twindow::isy()
	Returns the integer value of the upper left y coord


int Twindow::isx1()
	Returns the integer value of the lower right x coord


int Twindow::isy1()
	Returns the integer value of the lower right y coord


int Twindow::size()
	Returns the size in bytes of the area occupied by the window.


void Twindow::wprintat(int x,int y,int fgd,int bgd,char *txt)
	Prints text relative to the window, not the screen, in the
	specified foreground and background colors.


	example:        Twindow mainwindow;
				mainwindow.init(10,5,71,20,14,4,1,9);
				mainwindow.show();
				mainwindow.wprintat(3,3,14,4,"This text is in 3 
					and down 3 from the upper left corner");

void Twindow::wprintc(int y,int fgd,int bgd,char *txt)
	Centers text within a window on the given line and in the
	specified foreground and background colors.

	example:        Twindow mainwindow;
				mainwindow.init(10,5,71,20,14,4,1,9);
				mainwindow.show();
				mainwindow.wprintc(2,14,4,"Centered on line 2");




	So, what do you think?  Will these member functions give you all 
the control over popup windows that you ever dreamed of or what?! Be 
sure to see the code for the demo program for further examples of the 
use of the member functions for the Twindow class.






Tmenu

	Tmenu is the point and shoot menu object.  Being inherited from 
Twindow, Tmenu automatically includes all of the functionality of the 
Twindow class.  This means that practically anything you can do to a 
Twindow instance you can also to with a Tmenu instance.  An "instance" 
is an actual variable within your program of a given type. 

	Tmenu does not have its own constructor and destructor, but uses 
those it inherits from Twindow.


void Tmenu::init(int itemcnt,itemarray item,int xpos,int ypos,
	int width,int fore,int back,int hfore,int hback,int shadow,
	int shadowcolor)

Well, maybe Twindow::init wasn't the toughest! OK here goes.
	itemcnt - the number of items in the menu.
	item - type itemarray is defined in the header file.  You must
		fill and itemarray structure with items and pass it to
		Tmenu.   
	xpos - the upper left x coord of the menu
	ypos - the upper left y coord of the menu
	width - the width in characters of the menu.  Make sure this is
		wide enough to accomodate you longest menu entry.       
	fore - the foreground color of the menu and unhighlighted text.
	back - the background color of the menu and unhighlighted text.
	hfore - the foreground color of the highlighted menu entry.
	hback - the background color of the highlighted menu entry.
	shadow - 0 for no shadow, 1 for a shadow.
	shadowcolor - 0 to 15 representing the color of any text within
		the shadow region.
	example:        itemarray menuitems;
				Tmenu the_menu;
				
				strcpy(menuitems[1],"Number 1");
					//ALWAYS start with itemarray[1], NOT [0]
				strcpy(menuitems[2],"Number 2");
				strcpy(menuitems[3],"Number 3");
				
				the_menu.init(3,menuitems,5,2,10,15,1,1,7,0,0);
				the_menu.show();
				


int Tmenu::show()
	This function displays the menu, handles all keyboard input while 
	the menu is displayed, and returns the integer value of the menu 
	selection, providing the user pressed the <ENTER> key to make 
	a selection.  If the user presses the <ESC> key the function 
	returns 0. 
	
	example:        itemarray menuitems;
				Tmenu the_menu;
				int menuchoice;
				
				strcpy(menuitems[1],"Number 1");
				strcpy(menuitems[2],"Number 2");
				strcpy(menuitems[3],"Number 3");
				
				the_menu.init(3,menuitems,5,2,10,15,1,1,7,0,0);
				choice=the_menu.show();
				switch(choice) {
					case 1:printf("selection #1");
							break;
					case 2:printf("selection #2");
							break;
					case 3:printf("selection #3");
							break;
					case 0:printf("<ESC> key pressed");
					}
				the_menu.hide();//inherited from Twindow


	This rounds out the Tmenu object, but don't forget that you can 
use practically all of the Twindow member functions with the Tmenu class 
as well!








Tstring


	The Tstring class is going to very quickly become one of your best 
friends.  There is simply no easier way to get user text input from the 
users of your programs than with Tstring and its children Tnumeral and 
Tdate.  All of the standard editing keys (HOME, END, BACKWARD AND 
FORWARD ARROWS, DELETE, BACKSPACE, ENTER, ESC...) are supported as well 
as UP ARROW, DOWN ARROW, and TAB which allows you to EASILY create great 
forms, something that I have found no other library function anywhere 
could do the way I wanted to do.  Lets get to know your new best friend!


Tstring::Tstring()
	The default constructor.


Tstring::~Tstring()
	The default destructor.


void Tstring::init(int xloc,int yloc,int len,int uppercase)
	xloc - x coord for the left side of the string field.
	yloc - y coord for the string field
	len - the maximum length of the string field.
	uppercase - 1 if the string should be all uppercase, 0 if case
		is not important.
		
	example:        Tstring the_string;
				the_string.init(10,5,10,0);


void Tstring::show()
	Displays the input field on the screen, though it does not yet
	become active.  This is helpful for displaying all of the fields 
	in a form at one time.
	
	example:        Tstring the_string;
				the_string.init(10,5,10,0);
				the_string.show();


void Tstring::input()
	Checks for an input character, and immediately exits if there is
	none. This function can be useful for apparent multitasking. 

	example:        Tstring the_string;
				int x=0;
				the_string.init(10,5,10,0);
				the_string.show();

				while(1) {
					the_string.input();
					gotoxy(1,1);
					printf("%5d",x++);
					}


	Even though you can continue to edit the Tstring instance, the
	variable x keeps incrementing and displaying to the screen.


void Tstring::get_input()
	This is the function that you will most commonly call for single
	string input.  Basically this function continually calls
	Tstring::input() and exits when the user presses either the ENTER
	key or the ESC key.  Even if the user presses ESC anything in the
	input field will be captured and can be retrieved, though this is
	not generally the case.

	example:        Tstring the_string;
				the_string.init(10,5,10,0);
				the_string.get_input();//automatically calls
					//Tstring::show if the field is not 
					//already displayed. 
				if(the_string.escapehit())
					exit(0);


int Tstring::escapehit()
	Returns 1 if the ESC key was been pressed to end editing of a
	field. 

	See example for Tstring::get_input().


int Tstring::returnhit()
	Returns 1 if the ENTER key was pressed to end editing of a field.

	example:        Tstring the_string;
				the_string.init(10,5,10,0);
				the_string.get_input();
				if(the_string.returnhit())
					printf("\a");


int Tstring::tabhit()
	Returns 1 if the TAB key was pressed while editing a field.

	example:        Tstring the_string;
				the_string.init(10,5,10,0);
				the_string.get_input();
				if(the_string.tabhit())
					printf("\a");


int Tstring::uparrowhit()
	Returns 1 if the UP ARROW key was pressed while editing a field.
	This function is very useful for form input and is used with the
	Tstring::get_form_input member function.

	See the example with the Tstring::get_form_input() function.



int Tstring::dnarrowhit()
	Returns 1 if the DOWN ARROW key was pressed while editing a field. 
	This function is very useful for form input and is used with the 
	Tstring::get_form_input member function.

	See the example with the Tstring::get_form_input() function.


int Tstring::isshown()
	Returns 1 if the string field has been displayed on the screen,
	0 if not.


int Tstring::hit()
	Returns 1 if the left mouse button is pressed while the mouse
	cursor is on the string field.  This function is used in
	conjunction with the Tstring::get_form_mouse_input() function.

	example:        Tstring the_string;
				extern Mcursor the_mouse;       //See Mcursor for 
									//details.

				the_string.init(10,5,10,0);
				the_mouse.init();                       //See Mcursor
				the_mouse.show();                       //See Mcursor
				the_string.get_form_mouse_input();
				if(the_string.hit())
					printf("\a);


void Tstring::setincolors(int fgd,int bgd)
	Sets the foreground and background colors of the input field.
	By default these colors will be yellow (14) on blue (1).  Use this
	member function to change these default values.
	
	example:        Tstring the_string;
				the_string.init(10,5,10,0);
				the_string.setincolors(0,7);
				the_string.get_input();


void Tstring::get_form_input()
	VERY useful function for getting input in form fashion from the
	user.  I remember reading when I first learned Pascal that a
	skilled Pascal programmer would never use a GOTO statement, but
	would find a more elegant way control program flow.  BULL!
	Skillful use of a GOTO statement can be very powerful indeed as
	we will now see.
	
	example:        Tstring string1;
				Tstring string2;
				Tstring string3;
				
				string1.init(10,5,10,0);
				string2.init(10,7,10,0);
				string3.init(10,9,10,0);
				
				string1.show();
				string2.show();
				string3.show();


			getstring1:                     //This is a label
				string1.get_form_input();
				if(string1.escapehit()) goto esc;
				if(string1.uparrowhit()) goto getstring3;
				if(string1.dnarrowhit()) goto getstring2;

			getstring2:                     //Another label
				string2.get_form_input();
				if(string2.escapehit()) goto esc;
				if(string2.uparrowhit()) goto getstring1;
				if(string2.dnarrowhit()) goto getstring3;

			getstring3:                     //And another
				string3.get_form_input();
				if(string3.escapehit()) goto esc;
				if(string3.uparrowhit()) goto getstring2;
				if(string3.dnarrowhit()) goto getstring1;
				goto continue;
			esc:
				exit(0);
			continue:
				...  //program continues.

	In this way a user can move continuously among the different
	input fields until everything is perfect before leaving this
	particular screen.


void Tstring::get_form_mouse_input()
	This function is very similar to Tstring::get_form_input, but it
	also checks to see if you have clicked the left mouse button on
	another field within the form. 
	
	example:        Tstring string1;
				Tstring string2;
				extern Mcursor the_mouse;       //See Mcursor

				the_mouse.init();
				the_mouse.show();
				string1.init(10,5,10,0);
				string2.init(10,7,10,0);

			getstring1:
				string1.get_form_mouse.input();
				if(the_mouse.LBP()) {           //See Mcursor
					if(string2.hit()) goto getstring2;
			getstring2:
				string2.get_form_mouse_input();
				if(the_mouse.LBP()) {
					if(string1.hit()) goto getstring1;

char * Tstring::getstring()
	Returns a pointer to the string that the Tstring instance
	contains.  This is the only way to get at the contents of the
	Tstring input field.

	example:        Tstring the_string;
				the_string.init(10,5,10,0);
				the_string.get_input();
				printf("%s",the_string.getstring());


void Tstring::preset(char *)
	Use this function to automatically display a predefined string
	in the input field.  The user can still edit this field in the
	usual manner.

	example:        Tstring the_string;
				the_string.init(10,5,10,0);
				the_string.preset("Yes");
				the_string.get_input();


void Tstring::reset()
	Clears the contents of a Tstring input field.

	example:        Tstring the_string;
				char stringholder[80];

				the_string.init(10,5,10,0);
				the_string.get_input();
				strcpy(stringholder,the_string.getstring());
				the_string.reset();
				the_string.show();


void Tstring::erase()
	Clears the contents of a Tstring input field and automatically
	redisplays the blank field on the screen.

	example:        Tstring the_string;
				char stringholder[80];

				the_string.init(10,5,10,0);
				the_string.getinput();
				strcpy(stringholder,the_string.getstring());
				the_string.erase();


	That wraps it up for the Tstring class. VERY POWERFUL STUFF!!! You 
can do some incredible things with this class and its member functions, 
and the best part is that you can do them EASILY! Now let's take a look 
at Tstring's descendants, Tnumeral and Tdate.




Tnumeral


	Being descended from Tstring, Tnumeral of course inherits all of 
Tstring's power and ease of use. Some member functions, however, have 
been modified somewhat for the particulars of a numeral class as opposed 
to a string class. Let's examine Tnumeral's member functions.

void Tnumeral::init(int xpos,int ypos,int length,int int_or_float)
This member function looks similar to that of Tstring, but some 
	particulars have been changed. The first three parameters again          
	refer to the x and y screen coordinates for the input field to 
	begin, and the length of the input field respectively. The fourth 
	parameter now specifies whether or not the field is to display an 
	integer or a float value. 

	int_or_float - 0 for int or long values, 1 for float values.

	example:        Tnumeral the_int;
			Tnumeral the_float;
				the_int.init(10,10,5,0);
				the_float.init(10,12,5,1);


int Tnumeral::getint()
	Returns the integer value input by the user.

	example:        Tnumeral the_int;
			int myint;
				the_int.init(10,10,5,0);
				the_int.get_input();
				myint=the_int.getint();


long Tnumeral::getlong()
	Returns a long value input by the user.

	example:        Tnumeral the_long;
			long mylong;
				the_long.init(10,10,5,0);
				the_long.get_input();
				mylong=the_long.getlong();

float Tnumeral::getfloat()
	Returns a float value input by the user.

	example:        Tnumeral the_float;
			float myfloat;
				the_float.init(10,10,5,1);
				the_float.get_input();
				myfloat=the_float.getfloat();


	These are the specifics of the Tnumeral class. Don't forget that 
you can still use any of the member functions inherited from the Tstring 
class. This is the essential power of object oriented programming!

Tdate

	The Tdate class is a specialized version of the Tstring class used 
specifically for entering date information. Slashes will be displayed in 
the input field at the appropriate places, and all user input will take 
place around these slashes, never overwriting them or requiring the user 
to forward space over them. When the user presses <ENTER> the date value 
will be validated, and if the date is not valid a warning beep will 
sound and editing will continue until a valid date is entered or the 
user presses <ESC>.


void Tdate.init(int xpos,int ypos)
	xpos - the x screen coordinate at which to begin the date field.
	ypos - the y screen coordinate at which to begin the date field.

	example:        Tdate the_date;
				the_date.init(10,10);


int Tdate::verified()
	Returns 0 if the date entered is NOT a valid date, 1 if it is 
	valid.

	example:        Tdate the_date;
			int date_is_OK=0;
				the_date.init(10,10);
				the_date.get_input();
				if(the_date.verified())
					date_is_OK=1;


char * Tdate::getdatestring()
	Returns a character string representing the date as literally 
	entered by the user. An example of a string returned by this 
	function would be "06/06/92".

	example:        Tdate the_date;
			char mydate[8];
				the_date.init(10,10);
				the_date.get_input();
				strcpy(mydate,the_date.getdatestring());


long Tdate::getdate()
	Returns a long number representing the date as entered by the 
	user. If the user entered a date of 01/13/64 the Tdate::getdate 
	function would return a value of 640113. This value is useful for 
	comparing two or more dates.

	example:        Tdate the_date;
			long mydate;
				the_date.init(10,10);
				the_date.get_input();
				mydate=the_date.getdate();


	That's all there is to tell about Tstring and its descendants 
Tnumeral and Tdate. As stated earlier, I'm sure these classes are going 
to make life much easier for you, the programmer, as well as the users 
of your programs. Now let's move on to explore some of the other text 
mode objects of the ObjectEase library.




Tbutton

	Tbutton is the class which represents the text mode pushbutton. 
With the growing popularity of the GUI and mouse usage, text mode 
graphic objects also become increasingly necessary if your programs are 
to remain efficient and easy to use. The Tbutton class is just for this 
purpose. Sometimes a menu is just too much, and that is where the 
Tbutton excels. Tbuttons can be activated by the mouse or by a keyboard 
trigger. The usual keyboard trigger is the ALT key in combination with 
the highlighted letter from the Tbutton. This is the method the will be 
used in the following examples.

Tbutton::Tbutton()
	The default constructor.


Tbutton::~Tbutton()
	The default destructor.


void Tbutton::init(int xpos,int ypos,char* text,int highlight)
	xpos - the x screen coordinate to display the Tbutton.
	ypos - the y screen coordinate to display the Tbutton.
	text - the string to be displayed on the Tbutton.
	highlight - the position within the string of the letter to 
	highlight (for use as a keyboard trigger).

	example:        Tbutton mybutton;
				mybutton.init(10,10,"Hello",1);
				//The 'H' in Hello, being the first letter, will 
				//be highlighted.


void Tbutton::show(int bgd)
	Displays the Tbutton instance on the screen. The bgd parameter is 
	the color of the background on which the Tbutton instance will be 
	displayed.

	example:        Tbutton mybutton;
				mybutton.init(10,10,"Hello",1);
				settextbackground(1);
				clrscr();
				mybutton.show(1);



int Tbutton::hit()
	Returns 1 if the mouse cursor is on the Tbutton, 0 otherwise.

	example:        Tbutton mybutton;
			Mcursor the_mouse;      //see Mcursor class
				mybutton.init(10,10,"Hello",1);
				mybutton.show(0);
				if(the_mouse.LBP()) {
					if(mybutton.hit()) {
						mybutton.press(0);
						while(the_mouse.LBP());
						mybutton.show(0);
						}
					}


void Tbutton::press(int bgd)
	Displays the Tbutton on the screen in the depressed mode.

	See the example for Tbutton::hit()


int Tbutton.ispressed()
	Returns 1 if the Tbutton instance is in the depressed state, 0 
	otherwise.

	example:        Tbutton mybutton;
				mybutton.init(10,10,"Hello",1);
				mybutton.show(0);
				if(!mybutton.ispressed()) 
					mybutton.press(0);






	These examples have shown how to activate a Tbutton instance using 
the mouse as a trigger. Let me now provide an example of how to use the 
keyboard as a trigger. I will be using some additional functions in this 
example which ARE included in the ObjectEase library even though they 
are not member functions of a particular class.

	example:        Tbutton mybutton;
			char ch;
				mybutton.init(10,10,"Hello",1);
				settextbackground(1);
				clrscr();
				mybutton.show(1);

				ch=getch();
				if(altkey()) {  //included function
					ch=getch();
					if(ch==ALTH) {  //defined in the                
								//included header file
						mybutton.press(1);
						while(altkey());
						mybutton.show(1);
						//branch here to any action
						}
					}


	Again, see the source code for the demo program for further 
examples if this is not totally clear to you.




Tcheckbox


	The Tcheckbox class allows you to offer multiple choices and have 
the user make multiple selections. You can then "ask" the Tcheckbox if 
it has been checked by the user and take the appropriate actions. The 
mouse or the keyboard can act as a trigger to toggle the state of a 
Tcheckbox. When the keyboard is used, it is usually the SPACE BAR that 
serves as the trigger. Let's see how...
	

void Tcheckbox::init(int xpos,int ypos,int fgd,int bgd)
	xpos - the x screen coordinate of the Tcheckbox.
	ypos - the y screen coordinate of the Tcheckbox.
	fgd - the foreground color to use for the Tcheckbox.
	bgd - the background color to use for the Tcheckbox.

	example:        Tcheckbox mybox;
				mybox,init(10,10,15,0);


void Tcheckbox::show()
	Displays the Tcheckbox instance on the screen.

	example:        Tcheckbox mybox;
				mybox.init(10,10,15,0);
				mybox.show();


void Tcheckbox::check()
	Displays an 'X' in the Tcheckbox, marking it as selected.

	example:        Tcheckbox mybox;
				mybox.init(10,10,15,0);
				mybox.show();
				mybox.check();




void Tcheckbox::uncheck()
	Clears the 'X' from a checked Tcheckbox.

	example:        Tcheckbox mybox;
				mybox.init(10,10,15,0);
				mybox.show();
				getch();
				mybox.check();
				getch();
				mybox.uncheck();

int Tcheckbox.ischecked()
	Returns 1 if the Tcheckbox is checked, 0 otherwise.

	example:        Tcheckbox mybox;
				mybox.init(10,10,15,0);
				mybox.show();
				mybox.check();
				if(mybox.ischecked())
					mybox.uncheck();
				else
					mybox.chech();


void Tcheckbox::grabcursor()
	Moves the cursor to a particular Tcheckbox instance.

	example:        Tcheckbox mybox;
				mybox.init(10,10,15,0);
				clrscr(); //cursor is now at 1,1
				mybox.show();
				mybox.grabcursor(); //cursor is now at mybox


int Tcheckbox::hit()
	Returns 1 if the mouse cursor is on the Tcheckbox, 0 otherwise.

	example:        Tcheckbox mybox;
			Mcursor the_mouse;  //See Mcursor

				mybox.init(10,10,15,0);
				mybox.show();
				if(the_mouse.LBP()) {
					if(mybox.hit()) {
						if(mybox.ischecked())
							mybox.uncheck();
						else
							mybox.check();
						while(the_mouse.LBP());
						}               
					}


	Let me now give an example of how to use the keyboard to toggle 
the state of a Tcheckbox instance.

	example:        Tcheckbox mybox;
			char ch;
			int done=0;

				mybox.init(10,10,15,0);
				mybox.show();
				mybox.grabcursor();
				while(!done) {
					ch=getch();
					if(ch==32) {
						if(mybox.ischecked())
							mybox.uncheck();
						else
							mybox.check();
						}
					}

	
	This concludes the text mode class descriptions. In the next 
section we will look at the graphic mode objects in detail.


				  PART 2
			    GRAPHICS MODE OBJECTS


	  Using the graphic objects of the ObjectEase library

	In order to utilize the objects and functions in the ObjectEase
library you need only add the GUI.LIB library to your project, and 
include the header file in your program code. You can then declare 
object instances and call the functions as you would with any other 
library. You must, of course, first initialize the graphics mode with a 
call to initgraph(), or preferably through one of the member functions 
of the screen class. The graphic objects are available only in the large 
memory model of the library. This is because the use of graphics 
can be very memory intensive and the large memory model gives the 
program access to all of the available RAM, not just a single 64K 
data segment.

	This documentation is divided into sections describing each of the 
various graphic objects followed by a description and examples of 
all of the methods that may be used with the object. Please take 
special note of the example fragments as they may be of great help 
to you in getting to know the proper use of these objects and 
methods. 

	The following classes are available in these files:

	GUI.LIB - Large memory model library
	GUI.H   - Header file

	See the source code for the sample program GUIDEMO.EXE for
	more examples of these classes and their use.

Panels

	Panels can be associated with pop-up windows in a text 
environment. They serve to contain and draw attention to other objects 
such as text or pushbuttons. 

	The class POINT from which Panel is derived is the base class for 
all of the graphic objects in this library.

	In order to facilitate the initialization of the inorout and 
thickorthin variables the definitions IN, OUT, THICK and THIN 
may be used. These are defined in the header file.

	To declare an instance of class PANEL and display it in your 
application follow the example in the following code fragment.

	Panel mypanel;
	mypanel.init(10,10,100,100,IN,THICK);
	mypanel.show();

	It's just that simple. Remember that the graphics mode must first 
be initialized by a call to initgraph. If you are unfamiliar with 
this function consult your compiler documentation.

	All of the objects in this library contain the method "init". 
You must call "init" with the proper parameters before trying 
to display the object. There's no telling what might happen if 
you try to display an uninitialized object.





Bevels


	Bevels are just like panels with a more decorative border. All 
calls to their methods are identical except that a call to 
Bevel.init() takes one less parameter. You do not need to specify 
IN or OUT because Bevel borders always go out. 



PushButtons


	Pushbuttons simulate keyboard keys on the screen. They serve to 
get user input for a variety of purposes. They are very intuitive 
and can display either a text title or a graphic image.

	To declare an instance of class Button you need to supply the 
parameters for the upper left x and y positions, a string which 
either represents the text to be displayed on the button or the 
name of the file containing the image to be used on the button, 
and an integer flag representing whether or not the last parameter 
refers to text or a filename.

The definitions TEXT and IMAGE can be used in this parameter and are 
defined in the header file.

	Consider this example:

	Button textbutton;
	textbutton.init(10,10," EXIT ",TEXT);
	textbutton.show();

	This would create and display a button that said " EXIT " on it.

	Consider this:

	Button graphbutton;
	graphbutton.init(10,10,"EXIT",IMAGE);
	graphbutton.show();

	This would create and display a button containing the image stored 
in the file "EXIT.BTN". The file extension should not be included 
in the parameter as ".BTN" is the assumed extension. The graphic 
file must be present on the disk before trying to call this function. 

	Using the ICONEDIT program supplied with this package you can very 
easily create these graphics to be included on buttons.

	Note that you do not need to specify the width and height of 
buttons. If you are using text labels the button width is determined 
automatically to accomodate up to 40 characters, and if your are using 
graphics the button defaults to 20x20. This is the size of the button 
graphics created by the ICONEDIT program.

	Pressing the button is usually done with the mouse cursor, 
however, you may find it useful to use some other trigger to press the 
button. 

	The button method "hit()" determines if the mouse cursor is within 
the boundaries of the button. For a detailed discussion on the use of 
the mouse functions see the appropriate section of this documentation. 
If you don't understand all of the functions in this next code fragment 
you can find explanations elsewhere in this document.

	Button mybutton;                       DECLARES INSTANCE OF BUTTON
	mybutton.init(10,10,"EXIT",TEXT);      INITIALIZES MYBUTTON
	mybutton.show();                       DISPLAYS MYBUTTON ON SCREEN

	while(!kbhit()) {                      DO THIS WHILE NO KEYS ARE        
							 HIT
	  if(the_mouse.LBP()) {                IF THE LEFT MOUSE KEY IS
						 PRESSED
	    if(mybutton.hit()) {               IF MOUSE CURSOR IS ON    
							 MYBUTTON
	      mybutton.press();                DISPLAY MYBUTTON AS PRESSED
	      while(the_mouse.LBP());          WAIT UNTIL LEFT MOUSE KEY        
							 HAS BEEN RELEASED
	      mybutton.show();                 DISPLAY MYBUTTON IN NORMAL 
						 STATE
	      }
	  }
	}                       

	Immediately after restoring the button to the normal (undepressed) 
state the program can branch to take whatever action the button 
calls for.  By using the Button method "press()" all of the 
redrawing and repositioning of the text and/or graphic images is 
handled automatically by the ObjectEase library.


Colorbuttons


	Colorbuttons don't do much except tell you when they are hit and
return their current color. This is very useful if you are coding a 
paint program and need some way to set the current foreground and 
background colors. I'm sure you can find some other good uses for this 
class as well.

	Call "init()" with integer parameters for the x and y position,
the width, the height, and the color of the button. Call "show()" with
an integer value representing the color of the rectangle you wish to 
have surrounding the Colorbutton. By manipulating this value you can 
effectively show an "active" Colorbutton in a row of Colorbuttons. 
"Hit()" simply returns whether or not the mouse cursor is in the 
Colorbutton area, and "getcolor()" returns the color of the Colorbutton.




	A quick way to make a color selection bar is as follows:

	Colorbutton colorarray[16];
	for(int i=0;i<16;i++) {
		colorarray[i].init(100+(i*20),100,20,20,i);
		colorarray[i].show(15);
		}



Gcheckbox

	The Gcheckbox is the graphics mode counterpart to the Tcheckbox   
class. Like the Tcheckbox, Gcheckbox should be used to allow the user to 
make multiple selections. Call "init()" with the following three 
parameters to initialize a Gcheckbox. The x int coordinate, the y int 
coordinate, and a char * representing the descriptive text to be 
displayed with the Gcheckbox. Call "show()" to display the Gcheckbox on 
the screen. Calling "check()" and "uncheck()" will toggle the state of 
the Gcheckbox, and calling "is_checked()" will tell you its current 
state. The "hit()" member function returns true if the mouse cursor is 
positioned on the Gcheckbox.

	Follow this example:

	Gcheckbox mybox;
	int done=0;

	mybox.init(100,100,"This is a Gcheckbox");
	mybox.show();
	while(!done) {
		if(the_mouse.LBP()) {
			if(mybox.hit()) {
				if(mybox.is_checked())
					mybox.uncheck();
				else
					mybox.check();
				}
			}
		}


	You don't have to use the mouse as the trigger to toggle states. 
Any keypress or key combination that you choose can be used to toggle 
the state.



Gradio

	Gradio is the graphics mode version of the radio button. Basically 
the way a radio button works is this: First, you must have more than one 
of them. If you only need one use a Gcheckbox instead. One of the series 
of Gradios is initially selected. When the user selects a different 
radio button, the first one becomes de-selected, and the new one becomes 
selected, and so on. Remember, unlike a series of Gcheckboxes, only ONE 
Gradio can be selected at a time.

	Initialize a Gradio by calling "init()" with three parameters. The 
first two are ints specifying the x and y coordinates respectively to 
display the Gradio, and the third is a char* representing the 
descriptive text to be displayed to the right of the Gradio. After 
initializing the Gradio you can show it with a call to "show()". Like a 
Gcheckbox you can toggle the state of a Gradio with calls to "check()" 
and "uncheck()", and test if it has been hit with the mouse cursor by 
calling "hit()". Calling "is_checked()" will tell you the current state 
of the Gradio.

	Let's look at an example:
	
	Gradio rb1,rb2;
	int done=0;

	rb1.init(100,100,"This is a radio button");
	rb2.init(100,120,"So is this");
	rb1.show();
	rb2.show();
	while(!done) {
		if(the_mouse.LBP()) {
			if(rb1.hit()) {
				if(rb1.is_checked()) {
					rb1.uncheck();
					rb2.check();
					}
				else {
					rb1.check();
					rb2.uncheck();
					}
			if(rb2.hit()) {
				if(rb2.is_checked()) {
					rb2.uncheck();
					rb1.check();
					}
				else {
					rb2.check();
					rb1.uncheck();
					}                                       
				}
			}
		}


Icons

	Icons can be used in much the same way as buttons. They will 
always contain a graphic image, although text can be a part of the 
graphic. They are not 3 dimensional like pushbuttons.

	The graphic images for these Icon objects are created using the 
ICONEDIT program. This program produces 32x32 pixel icons that can be 
single or multi-framed. More on this in a moment.

	Like the other graphic objects, the Icon class must first be 
initialized with a call to "init()." Init() takes three parameter, 
the x and y coordinates of the upper left corner, and the file name 
of the file containing the graphic image for the icon. The filename 
parameter should be given without an extension as the default 
extension ".ICN" is assumed. The file named in this parameter must 
exist in the current directory.

	Let's look at a short example:

	Icon myicon;
	myicon.init(10,10,"paint");
	myicon.show();

	This example declares an instance of class Icon using the file 
"paint.icn" as the graphic, and then displays the icon.

	As with the pushbutton, the method "hit()" determines if the 
mouse cursor is within the boundaries of the icon. If it is, 
and if a mouse key is pressed, we can change the appearance of 
the icon to mark it as selected using the method "choose()." Here's 
a quick example, similar to that presented for the pushbutton:

	Icon myicon;
	myicon.init(10,10,"paint");
	myicon.show();

	while(!kbhit()) {
		if(the_mouse.LBP()) {
			if(myicon.hit()) {
				if(!myicon.ispressed()) {
					myicon.choose();
					while(the_mouse.LBP());
					myicon.show();
					}
				}
			}
		}

	Usually when an icon has been selected you will want to make 
sure that the last icon to be selected gets reset to its normal 
state with a call to "show()." Whatever action needs to be taken 
as a result of the icon's selection can be done after the call to 
"choose()." The method "ispressed()" simply returns whether or not 
the icon is already displayed in its selected state.




Acticons


	Acticons are exactly like Icons except that instead of simply 
reversing their image to mark them as the selected icon, they 
become animated. Acticons are created using the ICONEDIT program. 
They are created in the same manner as an Icon, but instead of just 
a single frame graphic, they contain several (up to 32) frames.



	Like Icons, they are initialized with a call to "init()" with 
parameters for the upper left x and y coordinates, and the file 
name containing the graphic images. When you call "show()", however, 
you must supply an integer parameter specifying which frame to 
display. Usually you will want to make this frame 0 because if 
you call "choose()" the negative image of frame 0 will be displayed 
by default.

	For example:
	
	Acticon myicon;
	myicon.init(10,10,"paint");
	myicon.show(0);

	Just like an Icon except for the parameter in the call to 
"show()."       If you want to use choose to show the reverse image of the 
Acticon it is done the same as it is for class Icon. If however you want 
to animate the Acticon you must call "animate()" or "backforth()." 
Both of these methods will put the Acticon in motion. "Animate()" 
will display the frames in ascending order and then restart at 
frame 0. "Backforth()" will display the frames in ascending order, 
but when it reaches the last frame it will then display the frames 
in reverse order back to frame 0. Both of these methods take a 
single parameter which specifies the delay between displaying each 
frame. This delay is expressed in eighteenths of a second. The 
lower the value, the faster the animation. You do not need to 
specify the number of frames in the Acticon as this information is 
contained in the graphic file created by ICONEDIT. Let's take a look:

	Acticon myicon;
	myicon.init(10,10,"paint");
	myicon.show(0);

	while(!kbhit()) {
		if(the_mouse.LBP()) {
			if(myicon.hit()) {
				while(the_mouse.LBP()) 
					myicon.animate(3);
				}
			}
		}

	In this code fragment, if the left mouse key is pressed while the 
cursor is on the Acticon, then the Acticon will animate for as long 
as the left mouse key is pressed. Note that "animate()" and 
"backforth()" will only change the animation by one frame, so for 
continuous motion you must include calls to these methods within 
some sort of loop.
	



Bitmaps



	The Bitmap object is used to display and capture graphic images. 
There are two editors included in this package to create bitmap images. 
The files are in the Borland getimage() format, which is certainly not 
the most compressed format for image storage. Future versions of this 
library are sure to include Bitmap objects with various graphic file 
formats. The bitmap editors are 16IMAGE.EXE and 256IMAGE.EXE for 
creating 16 and 256 color bitmaps respectively.

Bitmap::Bitmap()
	The default constructor.


Bitmap::~Bitmap()
	The default destructor.


void Bitmap::init(int x,int y)
	Initializes a bitmap object. The x and y parameter represent the 
	x,y coordinates for displaying the bitmap. If this coordinate pair 
	is not known when you initialize the bitmap instance, simply 
	initialize it to 0,0.   

void Bitmap::changexy(int x,int y)
	Changes the x,y coordinates at which to display the bitmap.



void Bitmap::load(char* name)
	Loads the bitmap image specified in the name parameter from disk. 
	This file must have been created by one of the bitmap editors 
	included with the ObjectEase library, or by a previous call to 
	Bitmap::save(char*).


void Bitmap::save(char* name)
	Saves a bitmap image to disk. Under most circumstances, this will 
	be an image that has been captured using the 
	Bitmap::capture(int,int,int,int) member function.


void Bitmap::capture(int x,int y,int x1,int y1)
	Captures the area bounded by the rectangle x,y,x1,y1 to a Bitmap 
	object. This area MUST NOT exceed 64K as this is the maximum size 
	for a Borland getimage() buffer.


void Bitmap::moveto(int x,int y)
	Hides a displyed Bitmap object and re-displays it at the new x,y 
	coordinates.


void Bitmap::hide()
	Removes a displayed Bitmap object from the screen.


void Bitmap::show_COPY()
	Displays a Bitmap image using the COPY_PUT mode.


void Bitmap::show_XOR()
	Displays a Bitmap object using the XOR_PUT mode.


void Bitmap::show_OR()
	Displays a Bitmap object using the OR_PUT mode.


void Bitmap::show_NOT()
	Displays a Bitmap using the NOT_PUT mode.


void Bitmap::show_AND()
	Displays a Bitmap object using the AND_PUT mode.


int Bitmap::isshown()
	Returns 1 if the Bitmap object is displayed on the screen, 0 
	otherwise.


int Bitmap::hit()
	Returns 1 if the mouse cursor is on the Bitmap object, 0 
	otherwise.


int Bitmap::xsize()
	Returns an integer representing the horizontal size of the Bitmap.


int Bitmap::ysize()
	Returns an integer representing the vertical size of the Bitmap.


int Bitmap::bitmapx()
	Returns the upper left x coordinate of the Bitmap.


int Bitmap::bitmapy()
	Returns the upper left y coordinate of the Bitmap.


int Bitmap::LBSCLK()
	Returns 1 if the left mouse button has been pressed while the 
	mouse cursor was on the Bitmap object, 0 otherwise


int Bitmap::LBDCLK()
	Returns 1 if the left mouse button was pressed twice while the 
	mouse cursor was on the Bitmap object. The button must have been 
	pressed two time with 1/2 of a second or else the timer resets.
	
	
Gstrings

	No, it's not something a stripper wears, the G in Gstring simply 
stands for graphic. These object are used for getting text input 
while in graphics mode. They display their own input fields and can 
handle all of the text editing keys like arrows, backspace, delete, 
etc...

	Once again a call to "init()" is necessary to begin. The necessary 
parameters are the x and y coordinates of the upper left corner of 
the input field, the length of the field, and an integer flag to 
indicate whether of not to force the input into all capital letters. 
Any nonzero value will force all caps. 

	Two methods that are part of Tstring that you might find useful 
are "preset()" and "reset()." Call "preset()" with a string parameter 
that you wish to have displayed in the input field by default, and 
"reset()" with no parameters to clear the input field. For example, 
if you wanted the input field to be displayed with the preset value 
of "Married" you would use code similar to the following:

	Gstring mystring;
	mystring.init(100,10,10,0);
	mystring.preset("Married");
	mystring.show();

	If you don't use the "preset()" method the input field will just 
be blank, probably what you want in most cases anyway. To allow 
user input just add the statement:
	
	mystring.get_input();

	This will allow text input until the user presses either <ESCAPE> 
or <ENTER>. You can test for the <ESCAPE> key with the Tstring 
method "escapehit()." Let's put it all together...

	Gstring mystring;
	char *the_string;

	mystring.init(100,10,10,0);
	mystring.get_input();
	if(mystring.escapehit())
		exit(0);
	else
	strcpy(the_string,mystring.getstring());

	The Tstring method "getstring()" returns a char * to the actual 
	text string that was entered by the user.


 

Gmenubutton & Gmenu

	The classes Gmenubutton and Gmenu provide the capabilities for you 
to include pulldown menus in you graphics applications. The 
Gmenubutton is simply the text that will appear in the menu bar 
whereas the Gmenu is the moving bar menu that will pop up when a 
Gmenubutton is selected. Since these two objects are so closely 
related I will discuss them together. 

	The data element gitemarray is a predefined two dimensional 
array containing the strings that will appear in the Gmenu. 
The maximum number of items in a Gmenu is 10, and the width of 
the pop-up menu is fixed at 100 pixels. When initializing the 
strings in the gitemarray always start at index 1 rather than 
index 0. Like this:

	gitemarray menu1array;
	strcpy(menu1array[1],"ITEM 1");
	strcpy(menu1array[2],"ITEM 2");
	etc...

	A Gmenubutton is initialized with parameters for x and y screen 
locations, normal state fgd and bgd colors, selected state fgd 
and bgd colors, and the text to be displayed.

	A Gmenu is initialized with parameters for the x and y screen 
locations, the number of entries to be in the menu, and the 
gitemarray containing the item strings. The Gmenu is popped-up 
with a call to "show()" which returns an integer representing the 
index of the gitemarray the bar was on when the selection was made. 
If no selection was made "show()" returns 11.

	Let's look at an example to hopefully clear this all up.

	gitemarray itemarray;
	Gmenu mymenu;
	Gmenubutton mymenubutton;
	int menuchoice;

	strcpy(itemarray[1],"ITEM 1");
	strcpy(itemarray[2],"ITEM 2");
	strcpy(itemarray[3],"ITEM 3");
	strcpy(itemarray[4],"ITEM 4");

	setfillstyle(SOLID_FILL,15);        MAKE A MENU BAR AT TOP OF   
							SCREEN
	bar(0,0,getmaxx(),10);

	mymenubutton.init(0,0,0,15,15,0,"MENU 1");
	mymenubutton.show();

	mymenu.init(0,11,4,itemarray);





	if(the_mouse.LBP()) {
		if(mymenubutton.hit()) {
			mymenubutton.press();
			choice=mymenu.show();
			mymenu.hide();
			mymenubutton.show();
			}
		}


	In this example the integer variable choice will contain the 
number of the item that was selected. Execution can then branch 
to the appropriate functions based on this value using case 
statements.                    
	

Screen

	The final graphics class that we will discuss is the Screen 
object. This object greatly simplifies the process of putting the screen 
into various modes. You should use this object to manipulate the screen 
as it initializes variables which are used by other object instances to 
determine the current screen mode.


void Screen::Screen()
	The default constructor.


void Screen::~Screen()
	The default destructor.


void Screen::VGA_480_16()
	Puts the screen into 640x480 16 color graphics mode.

	example:        Screen the_screen;
				the_screen.VGA_480_16();


void Screen::VGA_350_16()
	Puts the screen into 640x350 16 color graphics mode.


void Screen::VGA_200_16()
	Puts the screen into 320x200 16 color graphics mode.


void Screen::VGA_200_256()
	Puts the screen into 320x200 256 color graphics mode.


void Screen::fill(int color)
	Fills the background of the graphics screen (any mode) with the 
	color specifies in the color parameter.

	example:        Screen screen;
				screen.VGA256();
				screen.fill(48);




Printing Text

	Although not part of a class library, there is a text output
function included in the library that you will find most useful. The
"outtextxy()" function which is part of the Borland library will only
take a char* as the parameter to write to the screen. You cannot give
it a variable to format into a string for you. There is a function in 
the ObjectEase library called gprintxy() that will format variables into
printable text for you. The definition is:

	gprintxy(int,int,char *fmt,...)

	You can use this function just as you would the "printf()" 
function in text mode. So for example you could write:

	int age=27;
	gprintxy(100,100,"%d",age);

	"gprintxy()" will format the variable and print it to the screen
correctly. The two integer parameters represent the x and y position to
print the string. Remember that this function is dependent on the 
current text justification settings. Use the Borland library function 
"settextjustify()" to alter these settings.


	Next we'll explore the bi-modal objects of the ObjectEase library. 
That is, objects that can be used in both the text mode and the graphics 
mode.



			     Bi-Modal Objects

	The final discussion of objects in the ObjectEase library will be 
about the bi-modal objects...objects that can be used in both the text 
mode as well as the graphics mode. These are the objects SoundQ,and Mcursor.

	The code for these objects is included in both the TUI libraries
and the GUI library.

SoundQ

	The SoundQ class is used for playing music and sounds in the 
background while foreground processes continue to execute. This is a 
feature that you will commonly find in use in game programs, but can be 
useful in any application. If you're like me, you have probably tried to 
find some way to do this before, but the necessary functions are simply 
not available as part of the standard C or C++ libraries. Now you have 
the tools... you have the POWER...the power of the OBJECT!

	NOTE: When you include an instance of the SoundQ class in your 
program the timer chip will be reset to tick 500 times per second. The 
normal rate for this chip is 18.2 times per second. Clock functions will 
continue to operate normally as the SoundQ object issues a clock tick at 
the normal rate of 18.2 times per second, however, you may find that you 
need to make adjustments in any delays issued by the "void delay(long)" 
function that comes with the standard library.

	Let's take a look at the details of the SoundQ class...

SoundQ::SoundQ
	The default constructor.


SoundQ::~SoundQ
	The default destructor.


void SoundQ::adjust_speed(float)
	Adjusts the speed of the sounds being played in the background. 
	The default value is 1.0. Increasing this value will slow down the 
	playback, decreasing it will of course speed up the playback. 
	Changing this value to 2.0 will effectively play back the sounds 
	at half speed.

	example:        SoundQ sq;
				sq.adjust_speed(2.0);


void SoundQ::play(int freq,int duration)
	Places notes in the queue to be played by the SoundQ object. The 
	notes placed in the queue will begin to play immediately. Remember 
	that the timer tick has been reset to tick 500 times per second by 
	the SoundQ object, therefore, to make a note sound for 1 second 
	the duration parameter must be 500.




	example:        SoundQ sq;
				sq.play(440,100);

	Note: The following have been defined in the header file, and make  
the programming of music much simpler:

	#define C 523   Frequency of Middle C
	#define CS 554  C Sharp
	#define D 587   D
	#define DS 622  D Sharp
	#define E 659   E
	#define F 698   F
	#define FS 740  F Sharp
	#define G 784   G
	#define GS 831  G Sharp
	#define A 880   A
	#define AS 932  A Sharp (or B Flat)
	#define B 988   B
	#define C1 1046 C one octave above middle C

	#define SN 32   Duration of sixteenth note
	#define EN 63   Eighth note
	#define QN 125  Quarter note
	#define HN 250  Half note
	#define WN 500  Whole note
	
	#define ENT 20  Duration of eighth note triplet
	#define QNT 41  Duration of Quarter note triplet
	#define HNT 83  Duration of Half note triplet

	#define BN 30000,5      Place between two notes of the same     
					frequency to clearly define the sounding        
					of two notes.
	#define SR 30000,32     Plays a sixteenth note rest
	#define ER 30000,63     Plays an eighth note rest
	#define QR 30000,125    Plays a quarter note rest
	#define HR 30000,250    Plays a half note rest
	#define WR 30000,500    Plays a whole note rest
	#define NM 30000,1      Stops the sounding of a tone. Use at the        
					end of a song.

	Let's use these defines to play the C Major Scale with quarter  
	notes...

		SoundQ sq;
			sq.play(C,QN);
			sq.play(D,QN);
			sq.play(E,QN);
			sq.play(F,QN);
			sq.play(G,QN);
			sq.play(A,QN);
			sq.play(B,QN);
			sq.play(C1,QN);
			sq.play(NM);    //used to stop the sound


	These defined values can be multiplied or divided to play sounds 
from different octaves. Remember that once you have created a song you 
only need to use SoundQ::adjust_speed to vary the playback speed of the 
song.


Mcursor


	The Mcursor object controls and gets information about the mouse 
cursor. Again, this class is available in both text and graphics modes. 
Several predefined shapes for the graphics mouse cursor have been 
included in the ObjectEase library, however, at this time there is no 
provision for including your own designs with the Mcursor class.

	Note: The instance "Mcursor the_mouse;" has been pre-defined in 
the header file. This is because many of the objects in this library 
make use of the Mcursor object on their own. You need to declare this 
same instance of the Mcursor class within your code or the mouse will 
not function as you expect. When you declare an Mcursor instance in your 
code simply declare it as external like this:

	extern Mcursor the_mouse;       //you MUST name your instance   
					//the_mouse


int Mcursor::init()
	Initializes the mouse. This function must be called before trying 
	to use any of the other mouse functions. If a mouse driver is 
	detected the function will return 1, if no mouse driver is present 
	it will return 0.

	example:        extern Mcursor the_mouse;
				if(!the_mouse.init()) {
					puts("No mouse driver detected");
					exit(0);
					}
	The Mcursor instance is immediately put into a state of "unarmed."
	You must "arm" the instance before it can be displayed.


void Mcursor::show()
	Makes the mouse cursor visible on the screen.

	example:        extern Mcursor the_mouse;
				the_mouse.init();
				the_mouse.show();

	Note: upon initialization the state of the mouse cursor will be 
	visible.


void Mcursor::hide()
	Makes the mouse cursor invisible.
	
	example:        extern Mcursor the_mouse;
				the_mouse.init();
				getch();
				the_mouse.hide();


void Mcursor::unarm()
	Makes the mouse cursor invisible, and keeps other object instances 
from turning it back on. Any object that needs to draw itself on the 
screen will turn off the mouse cursor while it is manipulating the 
screen and then turns it back on when it is finished. If you don't want 
an object to have the capability of restoring the mouse cursor to the 
screen you must call Mcursor::unarm().

	example:        extern Mcursor the_mouse;
				the_mouse.init();
				the_mouse.unarm();      //hides the mouse cursor 
								//and keeps it from     
								//being restored by     
								//other objects                 
								//instances.


void Mcursor::arm()
	Restores the mouse cursor to the screen and allows other object 
instances to restore it to the screen when they have finished updating 
the screen. YOU MUST CALL THIS MEMBER FUNCTION AFTER INITIALIZING THE
MOUSE BECAUSE IT IS UNARMED UPON INITIALIZATION!

	example:        extern Mcursor the_mouse;
				the_mouse.init();
				the_mouse.unarm();

				...do some screen manipulation

				the_mouse.arm();


void Mcursor::set_hor_bounds(int left,int right)
	Sets the horizontal bounds of the mouse cursor movement.

	example:        extern Mcursor the_mouse;
				the_mouse.init();
				the_mouse.set_hor_bounds(100,getmaxx()-100);
				// the mouse cursor now cannot move closer than 
				//100 pixels to the sides of the screen.








void Mcursor::set_ver_bounds(int top,int bottom)
	Sets the vertical bounds of the mouse cursor movement.

	example:        extern Mcursor the_mouse;
				the_mouse.init();
				the_mouse.set_ver_bounds(100,getmaxy()-100);
				//the mouse cursor now cannot move closer than  
				//100 pixels to the top or bottom of the screen.


void Mcursor::position(int x,int y)
	Moves the mouse to the specified coordinates on the screen.

	example:        extern Mcursor the_mouse;
				the_mouse.init();
				the_mouse.position(0,0);
				//the mouse cursor is now in the upper left     
				//corner of the screen. 


void Mcursor::conditional_off(int x,int y,int x1,int y1)
	Declares a portion of the screen where the mouse cursor will not 
	be visible.

	example:        extern Mcursor the_mouse;
				the_mouse.init();
				the_mouse.conditional_off(0,0,100,100);
				//the mouse cursor will not be visible in the   
				//upper left corner of the screen.


int Mcursor::LBP()
	Returns 1 if the left mouse button is pressed, 0 otherwise.

	example:        extern Mcursor the_mouse;
			int done=0;
				the_mouse.init();
				while(!done) {
					if(the_mouse.LBP()) 
						done=1;
					}
				printf("\a");

int Mcursor::RBP()
	Returns 1 if the right mouse button is pressed, 0 otherwise.

	example:        extern Mcursor the_mouse;
			int done=0;
				the_mouse.init();
				while(!done) {
					if(the_mouse.RBP()) 
						done=1;
					}
				printf("\a");

int Mcursor::mx()
	Returns an integer representing the x coordinate of the mouse 
	cursor.         

	example:        extern Mcursor the_mouse;
			int x;
				the_mouse.init();                       
				x=the_mouse.mx();


int Mcursor::my()
	Returns an integer representing the y coordinate of the mouse 
	cursor.

	example:        extern Mcursor the_mouse;
			int y;
				the_mouse.init();
				y=the_mouse.my();


void Mcursor::changeto(int)
	Changes the shape of the graphics mouse cursor. Has no effect on 
	the text mode mouse cursor. This function first determines the 
	current shape of the mouse cursor. If the current shape is the 
	same as the one you are requesting it to change to the function 
	will exit with no action taken.

	example:        extern Mcursor the_mouse;
				the_mouse.init();
				the_mouse.changeto(CROSSHAIR);

	Note:   The following cursor shapes are predefined and may be used 
as the parameter to the Mcursor::changeto(int) function:

	#define UPARROW 1
	#define DOT 2
	#define PENCIL 3
	#define CROSSHAIR 4
	#define ARROW 5
	#define FINGER 6
	#define POINT 7
	#define CLOCK 8
	#define DISK 9
	#define IBAR 10
	#define PAINTCAN 11
	#define HAND 12
	#define ERASOR 13
	#define GUNSIGHT 14
	#define SCISSORS 15
	#define JAWS 16



	These are the member functions of the Mcursor class. I'm sure 
you'll find them as easy to implement as they are powerful to use. In 
these days of the Graphical User Interface, mouse routines are becoming 
a standard even in text based applications. These tools out the power of 
the mouse in your hands.



	Next I will briefly discuss the many functions that are included 
in this library that are not necessarily member functions of a 
particular object.




	    Miscellaneous Functions of the ObjectEase Library

Note: The designations TUI and GUI included with the following function
descriptions designate which library the function can be found in.

TUI
void vprintat(int cols,int rows,int fore,int back,char *,...);
	Writes directly to video memory in the specified fgd & bgd colors 
	at the specified location. Accepts variables in the same way as 
	the printf() function.

TUI
void vprintc(int row,int fore,int back,char *,...);
	Centers texts directly in video memory at the specified row in the 
	specified fgd & bgd colors. Accepts variables in the same way as 
	the printf() function.

TUI
void printat(int,int,int,int,char *);
	Same as vprintat, however, only literal text is accepted, not 
	variables.

TUI
void printc(int,int,int,char *);
	Same as vprintc, however, only literal text is accepted, not 
	variables.

TUI
void cprintat(int,int,int,int,char *,...);
	Same as vprintat, however, the cursor is moved to the end of the 
	string after the write.

TUI
void cprintc(int,int,int,char *,...);
	Same as vprintc, however, the cursor is moved to the end of the 
	string after the write.

TUI
void clear(char ch,int fore,int back);
	Fills video memory with the specified character in the specified 
	fgd & bgd colors.

TUI
void cursoroff();
	Turns off the text cursor.

TUI
void cursoron();
	Turns on the text cursor.

TUI
void settext(int fgd,int bgd);
	Sets the current text attributes to the specified fgd & bgd 
	colors.

TUI
void chsattr(int fgd,int bgd);
	Changes the attributes of the entire screen to the specified fgd & 
	bgd colors, leaving all character info on the screen intact.

TUI
void chcattr(int xpos,int ypos,int length,int fgd,int bgd);
	Changes the screen attributes to the specified fgd & bgd colors 
	starting at xpos,ypos and continuing for length characters.

TUI/GUI
void dlay(int ticks);
	Causes a delay of the specified number of clock ticks. Clock ticks 
	occur 18.2 times per second.

TUI/GUI
long getticks();
	Returns the time as a long number representing the number of clock 
	ticks since the preceding midnight.

TUI/GUI
int altkey();
	Returns 1 if an ALT key is pressed, 0 otherwise.

TUI/GUI
int ctrlkey();
	Returns 1 if a CTRL key is pressed, 0 otherwise.

TUI/GUI
int lshiftkey();
	Returns 1 if the LEFT SHIFT key is pressed, 0 otherwise.

TUI/GUI
int rshiftkey();
	Returns 1 if the RIGHT SHIFT key is pressed, 0 otherwise.

TUI/GUI
void flushkeys();
	Clears any and all keypresses from the keyboard buffer.

TUI/GUI
unsigned char getvidmode();
	Returns an unsigned char value representing the current video 
	mode.





	The remaining functions are all part of the VIDBIOSS & VIDBIOSL
libraries.

void set_default_palette();
	Sets all palette values to their initial values.

void blankcolor(int);
	Sets the palette values of the color specified to 0,0,0. In other 
	words to BLACK.

void fade1_3();
	Fades any object or text displayed from color 1, BLUE, to color 3, 
	CYAN.

void fade3_1();
	Fades any object or text displayed from color 3, CYAN, to color 1, 
	BLUE.

void fade1_4();
	Fades any object or text displayed from color 1, BLUE, to color 4, 
	RED.

void fade4_1();
	Fades any object or text displayed from color 4, RED, to color 1, 
	BLUE.

void fade1_5();
	Fades any object or text displayed from color 1, BLUE, to color 5, 
	MAGENTA.



void fade5_1();
	Fades any object or text displayed from color , MAGENTA, to color 
	1, BLUE.

void fadein(int color);
	Fades the specified color from 0,0,0, (BLACK) to its normal 
	palette value.

void fadeout(int color);
	Fades the specified color from its normal palette value to 0,0,0 
	(BLACK).

void rgb(int color,int R,int G,int B);
	Sets the specified color to the specified values of Red, Green, 
	and Blue. Valid RGB values are from 0 to 63.

void make_grayscale();
	Resets the normal palette to its grayscale equivalents.

void screenbord(int);
	Makes the screen border the color specified.

void disable_blink();
	Disables the ability to make characters blink, however, this 
	allows you to use colors 8 through 15 as background colors in text 
	mode.

void enable_blink();
	Restores the ability to make characters blink, however, colors 8 
	through 15 will not be available for use as background colors in 
	the text mode.

void disable_refresh();
	Disables the video refresh, effectively blanking the screen.

void enable_refresh();
	Enables the video refresh, restoring a screen blanked by a call to 
	disable_refresh().


```
{% endraw %}

## WHATSNEW.DOC

{% raw %}
```

                                WHATSNEW.DOC

                               ObjectEase V2.0
                (C) Copyright 1992 - David S. Reinhart Associates


        Let me begin by apologizing to all those who downloaded v1.0
of ObjectEase and tried in vain to get the demo to compile and run
successfully. I totally understand your frustration, and that is why I
am releasing v2.0 of this package already. The main reason that the
demo would not compile and run successfully for so many people has to do
with stack allocation. Since I wrote the demo on a 486 machine I never 
encountered many of the problems that people called me with. I am sorry,
and I assure you that these versions of the libraries and demos are 
compatible with all machines. The fact is that the library itself could 
have been used without the problems experienced in the demo, but I 
can totally understand how a person could give up on a package when even 
the supplied demo could not be made to function as expected. I have also 
taken the opportunity to fix a few minor bugs that were reported to me.

        The biggest change that you will notice is the large reduction in
price. Single user licenses of ObjectEase are now only $34.95! Source code
has also been made available to registered or registering users of the
libraries. See the file REGISTER.DOC for prices.

Fixes:
        The stack size in the large memory model version of the libraries
        has been set to 16384 bytes by default. This fixes the major
        problem with v1.0.

        The mouse cursor is now in the unarmed state upon initialization.
        You MUST call the_mouse.arm() before the mouse cursor can be made
        visible. 

        The mouse cursor has been made to turn off during screen updating
        procedures of the Tstring class.

        The mouse will be (re)initialized when changing screen modes with 
        the member functions of the Screen class. Some mice, including
        Logitech mice, could not adjust their boundaries to the new
        screen coordinates without being re-initialized. This resulted
        in the mouse cursor not being able to reach the lower half of the
        screen.
        
        Fixed the rubber banding mode of the files 256IMAGE.EXE and 
        16IMAGE.EXE so that it now stretches and contracts cleanly.

Changes:
        The libraries have been separated into TUI (text), GUI (graphics),
        and VIDBIOS (video bios). This makes it easier on me to supply 
        upgrades and makes the source code more affordable to you.



```
{% endraw %}

## PCSIG.TXT

{% raw %}
```


                            P C  -  S I G





++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Welcome to the world of Shareware, state of the art software you can
actually try before you buy.

Shareware, a term coined in the early eighties, refers to the method of
distribution chosen by the software authors.  With shareware, you can
receive a program and put it through its paces without having to pay for
it. If you find the program useful, and choose to keep the program, then
you pay a modest registration fee to the author.

For the last nine years, PC-SIG has been providing shareware and public
domain software to its customers and members.  Since 1982 PC-SIG has
developed an unprecedented library of shareware programs, constantly
updated, consistently strong in every category.  Our library of
shareware contains over 3500 titles divided into 120 logical categories.

Every program we add to the library is thoroughly reviewed and tested to
insure that each one meets the high standards of reliability and value we
insist upon and you expect.  As a result, our library doesn't contain
every shareware program available, just those that really work.

PC-SIG has grown into the premier distributor of shareware and and
shareware information by producing shareware collections on CD-ROM,
publishing an encyclopedia of shareware, and by publishing Shareware
Magazine, a bi-monthly magazine distributed world-wide.

Quality and support - guaranteed.  All of our programs are guaranteed
virus free.  We've isolated our systems and check every program
submitted to insure that no viruses make their way to your computer or
ours.

Our support staff is available by phone as well as on our BBS to help
you with questions about installation and operation of PC-SIG's
products.

Through our network of international distributors, PC- SIG strives to
bring you the most current, exciting, technically advanced software
available as shareware.

If you can't find the software you need in PC-SIG's library, it may well
not exist.

To order the latest in Shareware, in the U.S.A: Call (800) 245-6717

Outside the U.S.A.: Call (408) 730-9291 for the name of the dealer near
you.

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
```
{% endraw %}

## SHAREMAG.TXT

{% raw %}
```
              S H A R E W A R E  M A G A Z I N E
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Shareware Magazine has distinguished itself as the only internationally
distributed periodical devoted to the use and business of shareware.
Shareware Magazine provides detailed reviews of new products,
hard-hitting comparisons of shareware programs with regular retail
software, and timely information about changes in the industry and the
latest technology.

Intriguing columnists and regular features add to the excitement.  The
beginners section sheds light on new user's concerns regarding
everything from choosing the right operating system to alleviating the
intimidation of using on-line systems.

Educational sections focus on how low cost shareware can aid in
classroom learning, curriculum development, and as a forum for
discussing the impact of computers and technology in schools.

Graphics Gallery renders expert advice and suggestions on how to better
work with graphics, desktop publishing, CAD systems, and the Windows
environment.

Programmers benefit from others experience in developing new programs or
polishing existing ones as well as choosing the right programming
language.

And columnists provide that subjective component, sometimes
controversial, that calls for a closer look at the way we compute and
how shareware effects what we do.

Published bimonthly, Shareware Magazine is available on a subscription
or at your local newsstand or computer bookstore.  In conjunction with
PC-SIG, there are special benefits for subscribers as well as
opportunities for discount purchases from PC-SIG.


To Order, in the U.S.A.: Call 800-245-6717 and ask Customer Service.

Outside the U.S.A.: Call (408) 730-9291 for the name of the dealer near
you.
```
{% endraw %}

## SIGORDER.TXT

{% raw %}
```
                                      [B]

FROM:  ___________________________

       ___________________________

       ___________________________
[A]                                                                         [B]
       ___________________________


                                  PC-SIG Inc.
[A]                                                                         [B]
                            1030-D East Duane Avenue

                               Sunnyvale  California

                                     94086


























Fold - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - Fold

       HOW TO USE THIS RETURN ENVELOPE

       1.  Place any other pages underneath this page.
       2.  Using the Fold lines (above) as a guide, fold this flap under.
       3.  Fold the address flap so it covers this flap.
       4.  Tape or staple the envelope at the two spots marked [A].
       5.  Slip in any other enclosures (business cards, cheques, etc.).
       6.  Tape or staple the envelope at the spots marked [B].














THANKS FOR TAKING THE TIME TO PRINT THIS FORM -*- MAIL YOUR ORDER TO:
PC-SIG Inc. 1030-D East Duane Avenue Sunnyvale CA 94086






---------------------------------------------------------------------

     Do not mail cash.   Please allow four weeks for processing.

---------------------------------------------------------------------




Check the items desired:

PC-SIG Disks - Member $2.49 for 5.25" or $2.99 for 3.5"
           Non-member $3.50 for 5.25" or $4.00 for 3.5"

_____  _____  _____  _____  _____  _____  _____  _____  _____

_____  _____  _____  _____  _____  _____  _____  _____  _____

_____  _____  _____  _____  _____  _____  _____  _____  total  ______

One year subscription to Shareware Magazine            $19.95  ______

Super Saver Membership                                 $39.95  ______
(includes a 1 year subscription to Shareware Magazine,
 the PC-SIG Encyclopedia on Disk with WordCruncher,
 and 5 free disks)

The PC-SIG Catalog on Disk                              $5.00  ______
($5.00 is refundable with your first order)

The PC-SIG Encyclopedia on Disk with WordCruncher      $20.00  ______

The PC-SIG World of Games CD-ROM                       $19.95  ______ 

The PC-SIG 12th Edition Library CD-ROM                 $99.00  ______

Upgrade to the 12th Edition from ANY previous edition
of the PC-SIG Library on CD-ROM!                       $59.00  ______

Upgrade from ANY other CD-ROM just!                    $59.00  ______

The Essential Home & Business Collection CD-ROM        $39.00  ______  

The PC-SIG Encyclopedia of Shareware on CD-ROM
(1 year subscription)                                  $99.00  ______


                                                    Subtotal   ______

Shipping and Handling                                          $4.00

                    California residents add 8.25% sales tax   ______

                                                       TOTAL   ______



      If you have any comments or suggestions, please let us know!

To order by phone with VISA or MASTERCARD: Call (800) 245-6717
Ask for operator #2351
```
{% endraw %}

{% comment %}samples_end{% endcomment %}

### Directory of PC-SIG Library Disk #3976

     Volume in drive A has no label
     Directory of A:\

    OBJEAS2B ZIP    234201   1-18-93  10:20a
    GO-STRT  DAT       541   6-01-93  11:07a
    SIGORDER TXT      3336   6-01-93   2:30p
    GO-FORM  DAT      3336   6-01-93   2:30p
    GO       EXE     26022   1-10-92  12:14p
    PKUNZIP  EXE     29378   2-01-93   2:04a
    PCSIG    TXT      2329   6-01-93   2:31p
    SHAREMAG TXT      1831   6-01-93   2:32p
    CDROM    TXT      8196   6-01-93   3:26p
            9 file(s)     309170 bytes
                            8192 bytes free
